<meta name="apple-mobile-web-app-capable" content="yes">
<link rel="apple-touch-icon" href="https://i.postimg.cc/yNgrH20D/IMG-1108.jpg">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>甘梅炸机</title>
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Noto+Serif+SC:wght@500;700&family=Long+Cang&display=swap" rel="stylesheet">
    <style>

.msg-time {
    display: block;
    font-size: 0.65rem;
    color: #888;
    margin-top: 4px;
    text-align: right; 
    opacity: 0.8;
}
.msg-row.other .msg-time {
    text-align: left; 
}
#newspaper-modal {
    background: rgba(0,0,0,0.85);
    backdrop-filter: blur(5px);
    display: none; 
    align-items: center;
    justify-content: center;
    z-index: 3000;
}
.paper-full-view {
    width: 90%;
    max-width: 600px;
    height: 85vh;
    background: #fdf6e3;
    padding: 20px;
    box-shadow: 0 0 50px rgba(0,0,0,0.5);
    overflow-y: auto;
    font-family: "Times New Roman", serif;
    position: relative;
    transform: rotate(-1deg);
    border: 1px solid #ccc;
}
.paper-full-head { text-align: center; border-bottom: 3px double #333; padding-bottom: 10px; margin-bottom: 15px; }
.paper-title { font-size: 2.5rem; font-family: "Old English Text MT", serif; line-height: 1; }
.paper-body { font-size: 1rem; line-height: 1.6; text-align: justify; column-count: 1; }

#camera-ui {
    display: flex;
    flex-direction: column;
    height: 100%;
    background: #1a1a1a;
}
#canvas-area {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    position: relative;
    background-image: radial-gradient(#333 1px, transparent 1px);
    background-size: 20px 20px;
}
canvas {
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
    max-width: 95%;
    max-height: 95%;
}
.cam-tools {
    height: 100px; 
    background: #222;
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 0 15px;
    overflow-x: auto;
    border-top: 1px solid #333;
    flex-shrink: 0;
}
        :root {
            --bg-gradient-1: #cdd1d3;
            --bg-gradient-2: #e3e3e3;
            --tv-wood-light: #a05a2c;
            --tv-wood-dark: #5c2e14;
            --dock-bg: rgba(245, 245, 245, 0.4);
            --glass-border: 1px solid rgba(255,255,255,0.45);
            --glass-shadow: 0 8px 32px rgba(0,0,0,0.1);
            --icon-size: 58px;
            --news-bg: #fdf6e3; 
            --news-ink: #2b2626;
            --morandi-green: #97a89e; 
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

                body, html {
    margin: 0; padding: 0; 
    width: 100vw;       
    height: 100vh;      
    overflow: hidden;   
    background-color: #cdd1d3; 
}

#screen { 
    position: fixed;    
    top: 0; 
    left: 0; 
    width: 100vw;       
    height: 100vh;      
    z-index: 0;
 
    background: linear-gradient(135deg, var(--bg-gradient-1), var(--bg-gradient-2)); 
    background-size: cover;
    background-position: center;
}
        #pages-wrapper {
            display: flex; width: 100%; height: 100%;
            overflow-x: scroll; overflow-y: hidden;
            scroll-snap-type: x mandatory; scroll-behavior: smooth;
        }
        #pages-wrapper::-webkit-scrollbar { display: none; }

.page {
    min-width: 100%; height: 100%;
    padding-top: calc(50px + env(safe-area-inset-top)); 
    padding-left: 20px; padding-right: 20px;
    
    padding-bottom: 150px; 
    
    scroll-snap-align: start;
    display: flex; flex-direction: column; gap: 15px;
    align-items: center; 
    overflow-y: auto; 
    -webkit-overflow-scrolling: touch; 
}
        .header-info {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 10px 0; margin-bottom: 5px; width: 100%; flex-shrink: 0;
        }
        .time-widget { 
            font-size: 3.8rem; font-weight: 700; color: #2c3e50; 
            line-height: 0.9; letter-spacing: -2px; 
            font-family: "Georgia", serif; 
            text-shadow: 1px 1px 0px rgba(255,255,255,0.5);
        }
        .date-widget { 
            font-size: 1rem; font-weight: 600; color: #7f8c8d; 
            margin-top: 4px; text-transform: uppercase; letter-spacing: 2px;
        }
        .tv-container {
            width: 340px; height: 260px; flex-shrink: 0; position: relative; z-index: 10;
        }
        .tv-case {
            width: 100%; height: 100%;
            background: repeating-linear-gradient(90deg, var(--tv-wood-dark), var(--tv-wood-dark) 2px, var(--tv-wood-light) 3px, var(--tv-wood-light) 8px);
            border-radius: 16px; padding: 14px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5), inset 0 0 30px rgba(0,0,0,0.8);
            display: flex; flex-direction: column; border: 4px solid #3e1e0f; 
        }
        .tv-bezel-wrapper {
            flex: 1; background: linear-gradient(to bottom, #d4cfc9, #8f8f8f);
            padding: 8px; border-radius: 8px; border: 1px solid #666;
            display: flex; overflow: hidden;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }
        .tv-screen-frame {
            width: 100%; height: 100%; background: #000; border-radius: 20px;
            position: relative; overflow: hidden; border: 2px solid #222;
            box-shadow: inset 0 0 20px rgba(0,0,0,1);
        }
        .tv-screen {
            width: 100%; height: 100%; 
            background: #111;
            position: relative; overflow: hidden;
            display: flex; justify-content: center; align-items: center;
        }
        .tv-content { 
            width: 100%; height: 100%; object-fit: cover; display: block; 
            filter: contrast(1.1) brightness(1.1);
        }
        .crt-scanlines {
            position: absolute; inset: 0; pointer-events: none; z-index: 5;
            background:
                linear-gradient(135deg, rgba(255,255,255,0.1) 0%, transparent 40%, rgba(255,255,255,0.05) 100%),
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.05) 3px);
            box-shadow: inset 0 0 30px rgba(0,0,0,0.6);
        }
        .tv-control-panel {
            height: 40px; margin-top: 10px; display: flex; align-items: center; justify-content: space-between;
            padding: 0 10px; 
            background: linear-gradient(to bottom, #2b150a, #3e1e0f); 
            border-radius: 4px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .tv-logo-badge { 
            background: linear-gradient(to right, #d4af37, #f9e076); 
            padding: 2px 8px; font-family: serif; font-weight: bold; font-size: 0.7rem; color: #3e1e0f; 
            border-radius: 2px; letter-spacing: 1px; box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .tv-knobs { display: flex; gap: 12px; }
        .knob { 
            width: 24px; height: 24px; 
            background: radial-gradient(circle, #eee 30%, #bbb 100%); 
            border-radius: 50%; border: 1px solid #444; position: relative; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        .add-btn-trigger { position: absolute; inset: 0; z-index: 20; cursor: pointer; }
        .middle-grid { 
            display: flex; width: 100%; min-height: 220px; gap: 15px; flex-shrink: 0;
        }
        .left-apps-grid {
            width: 45%;
            display: grid; grid-template-columns: repeat(2, 1fr); grid-template-rows: repeat(3, 1fr);
            gap: 12px; align-items: center; justify-items: center;
        }
        .app-item { display: flex; flex-direction: column; align-items: center; gap: 5px; cursor: pointer; transition: transform 0.1s;}
        .app-item:active { transform: scale(0.95); }
        .app-icon {
            width: var(--icon-size); height: var(--icon-size); border-radius: 14px;
            display: flex; justify-content: center; align-items: center;
            font-size: 1.6rem; color: #fff; box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .app-name { font-size: 0.75rem; color: #444; font-weight: 500; }
.newspaper-wrap {
    flex: 1; 
    background-color: #f4ecd8;
    background-image: 
        linear-gradient(90deg, rgba(0,0,0,0.02) 1px, transparent 1px),
        linear-gradient(rgba(0,0,0,0.02) 1px, transparent 1px);
    background-size: 20px 20px; 
    
    color: #2b2626; 
    padding: 15px;
    border: 1px solid #d6cbb0;
    box-shadow: 
        1px 1px 0px rgba(0,0,0,0.1),
        3px 3px 0px rgba(0,0,0,0.05),
        5px 5px 15px rgba(0,0,0,0.1);
    
    display: flex; 
    flex-direction: column; 
    overflow: hidden; 
    position: relative;
    transform: rotate(0.5deg); 
    border-radius: 2px;
    transition: transform 0.2s;
    cursor: pointer;
}
.newspaper-wrap:active {
    transform: scale(0.98) rotate(0deg);
}

.news-header-section { 
    border-bottom: 3px double #2b2626; 
    padding-bottom: 8px; 
    margin-bottom: 10px; 
    text-align: center; 
}

.news-brand { 
    font-family: "Old English Text MT", serif; 
    font-size: 1.8rem; 
    line-height: 1; 
    color: #1a1a1a; 
    margin-bottom: 2px;
    text-shadow: 0 1px 0 rgba(255,255,255,0.5); 
}

.news-meta-bar { 
    border-top: 1px solid #2b2626; 
    padding-top: 2px; 
    display: flex; 
    justify-content: space-between; 
    font-size: 0.45rem; 
    font-weight: 700; 
    text-transform: uppercase; 
    letter-spacing: 1px;
    font-family: sans-serif;
}

.news-content { 
    flex: 1; 
    display: flex; 
    flex-direction: column; 
    overflow: hidden; 
}

.news-headline { 
    font-family: "Times New Roman", serif; 
    font-weight: 900; 
    font-size: 1.4rem; 
    line-height: 0.9; 
    text-transform: uppercase; 
    text-align: center; 
    margin-bottom: 10px; 
    color: #111;
    letter-spacing: -0.5px;
}
.news-img-halftone {
    width: 100%; 
    height: 70px; 
    margin-bottom: 10px;
    border: 1px solid #333;
    background-image: radial-gradient(circle, #333 20%, transparent 25%); 
    background-size: 4px 4px;
    background-color: #e0dcd0; 
    filter: contrast(0.8) sepia(0.4);
    opacity: 0.6;
}

.news-text-columns { 
    column-count: 2; 
    column-gap: 15px; 
    column-rule: 1px solid rgba(0,0,0,0.1);
    font-family: "Georgia", serif; 
    font-size: 0.45rem; 
    line-height: 1.4; 
    text-align: justify; 
    color: #333;
}
.newspaper-wrap.custom-cover-mode {
    border: none;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    background-color: transparent; 
    padding: 0; 
}

.newspaper-wrap.custom-cover-mode > * {
    opacity: 0; 
    pointer-events: none;
}

        .weather-glass {
            height: 85px; width: 100%; flex-shrink: 0;
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border-radius: 22px; border: var(--glass-border); box-shadow: var(--glass-shadow);
            display: flex; align-items: center; justify-content: space-between; padding: 0 24px;
            color: #333; margin-top: auto; 
        }
        .w-left h2 { margin: 0; font-size: 2.4rem; font-weight: 400; }
        .w-left p { margin: 0; font-size: 0.95rem; opacity: 0.7; }
        .w-icon { font-size: 3rem; }
     .dock-bar {
    position: fixed; 
    bottom: 30px;    
    
    left: 20px; right: 20px;
    height: 90px;
    background: var(--dock-bg); 
    backdrop-filter: blur(30px); 
    -webkit-backdrop-filter: blur(30px);
    border-radius: 35px; 
    display: flex; justify-content: space-around; align-items: center;
    border: var(--glass-border); 
    box-shadow: var(--glass-shadow); 
    z-index: 1000; 
}
        .page-2-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 25px 10px; padding-top: 40px; justify-items: center; width: 100%; }
        #tv-file-input { display: none; }
        .tv-placeholder { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #666; font-family: monospace; font-size: 0.8rem; text-align: center; z-index: 4; text-shadow: 0 0 5px rgba(255,255,255,0.5); font-weight: bold;}
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #f4ebe8; z-index: 2000;
            display: none; flex-direction: column;
            animation: fadeIn 0.3s ease;
            font-family: -apple-system, "Helvetica Neue", sans-serif;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .modal-header {
            padding: 0 20px; 
            height: 120px;
            padding-top: env(safe-area-inset-top); 
            background: #dcbdbd; color: #5e4b4b;
            font-size: 1.1rem; font-weight: bold;
            display: flex; justify-content: space-between; 
            align-items: flex-end; 
            padding-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            flex-shrink: 0; 
        }
        .close-btn { background: none; border: none; font-size: 1.8rem; color: #5e4b4b; cursor: pointer; padding: 10px; }
        .modal-body { flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 20px; padding-bottom: 100px; }

        .morandi-card {
            background: rgba(255, 255, 255, 0.6); border-radius: 16px; padding: 20px;
            box-shadow: 0 4px 15px rgba(189, 156, 156, 0.15); border: 1px solid rgba(255, 255, 255, 0.8);
        }
        .input-group { margin-bottom: 10px; }
        .input-group label { display: block; font-size: 0.8rem; color: #9e8a8a; margin-bottom: 5px; }
        .input-group input, .input-group select, .input-group textarea {
            width: 100%; padding: 12px; border-radius: 10px; border: 1px solid #e0d0d0;
            background: #fffdfd; color: #666; outline: none; transition: 0.2s;
        }
        .m-btn { flex: 1; padding: 12px; border: none; border-radius: 10px; font-weight: 600; cursor: pointer; transition: 0.2s; }
        .m-btn.primary { background: #cba8a8; color: white; }
        .m-btn.secondary { background: #e8d7d7; color: #7a6363; }
        .m-btn.small { flex: none; padding: 6px 12px; font-size: 0.8rem; background: #dcbdbd; color: white; }

        #fan-modal {
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            align-items: center; justify-content: center;
        }
        .elec-screen-container {
            width: 90%; max-width: 500px;
            background: #111;
            border: 2px solid #333;
            box-shadow: 0 0 20px rgba(0, 255, 128, 0.2);
            border-radius: 10px;
            position: relative;
            padding: 5px;
            margin-bottom: 10vh;
        }
        .elec-screen {
            background: repeating-linear-gradient(0deg, rgba(0, 20, 0, 0.9), rgba(0, 20, 0, 0.9) 2px, rgba(0, 40, 0, 0.9) 3px);
            border: 1px solid #0f0;
            border-radius: 4px;
            min-height: 200px;
            padding: 20px;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: flex-start;
        }
        .elec-text {
            font-family: "Courier New", monospace;
            color: #0f0;
            font-size: 1.1rem;
            line-height: 1.5;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.8);
            white-space: pre-wrap;
            z-index: 2;
        }
        .scanline-anim {
            position: absolute; top: 0; left: 0; width: 100%; height: 10px;
            background: rgba(0, 255, 0, 0.3);
            opacity: 0.5;
            animation: scan 3s linear infinite;
            pointer-events: none;
            z-index: 10;
        }
        @keyframes scan { 0% { top: -10%; } 100% { top: 110%; } }
        .elec-deco-bar {
            height: 20px;
            background: #222;
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 10px; margin-top: 5px;
        }
        .deco-dot { width: 8px; height: 8px; background: #555; border-radius: 50%; }
        .deco-dot.active { background: #0f0; box-shadow: 0 0 5px #0f0; }
        #chat-modal { 
            background: #f2f2f2; 
            background-size: cover; 
            background-position: center; 
            background-repeat: no-repeat;
            display: none; 
            position: fixed; 
            top: 0; left: 0; width: 100%; height: 100%;
            flex-direction: column; 
            z-index: 2000; 
        }
               .chat-header {
            position: absolute; 
            top: 0; left: 0; right: 0;
            height: 120px;
            background: rgba(255, 255, 255, 0.15); 
            backdrop-filter: blur(25px); 
            -webkit-backdrop-filter: blur(25px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.05);
            display: flex; 
            align-items: flex-end; 
            justify-content: space-between;
            padding: 0 15px; 
            padding-bottom: 10px; 
            z-index: 110; 
        } 
        .chat-header-center { display: flex; flex-direction: column; align-items: center; width: 60%; }
        .chat-title-input {
            border: none; background: transparent; font-size: 1.1rem; font-weight: bold;
            text-align: center; width: 100%; outline: none; padding: 0; color: #000;
        }
        .chat-status-toggle {
            font-size: 0.75rem; color: #666; margin-top: 2px;
            background: rgba(255,255,255,0.3); padding: 2px 8px; border-radius: 10px;
            cursor: pointer; display: flex; align-items: center; gap: 4px;
        }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #ccc; }
        .status-online .status-dot { background: #06c755; }
               .chat-body {
            position: relative; 
            flex: 1; 
            width: 100%;
            overflow-y: auto; 
            padding: 15px;
            padding-top: 110px; 
            padding-bottom: calc(max(20px, env(safe-area-inset-bottom)) + 70px);
            display: flex; flex-direction: column; gap: 15px;
            -webkit-overflow-scrolling: touch;
            background: transparent;
        }
        .chat-footer {
            position: absolute; 
            bottom: 0; left: 0; right: 0;
            min-height: 60px; 
            background: rgba(255, 255, 255, 0.15); 
            backdrop-filter: blur(25px); 
            -webkit-backdrop-filter: blur(25px);
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 -4px 30px rgba(0, 0, 0, 0.05);
            padding: 8px 10px; display: flex; align-items: center; gap: 8px;
            padding-bottom: max(20px, env(safe-area-inset-bottom)); 
            z-index: 110;
        }
        .chat-func-btn {
            width: 36px; height: 36px; display: flex; align-items: center; justify-content: center;
            font-size: 1.4rem; cursor: pointer; color: #555; background: none; border: none; padding: 0;
        }
        #chat-input-text { 
            flex: 1; padding: 10px; border-radius: 18px; 
            border: 1px solid rgba(255,255,255,0.4); 
            background: rgba(255,255,255,0.5); 
            font-size: 1rem; outline: none; height: 38px; 
            backdrop-filter: blur(5px);
        }
        .chat-send-btn {
            background: transparent !important; 
            border: none;
            padding: 0; width: 40px; height: 36px; 
            color: #E6CAFF; 
            font-size: 1.8rem; 
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: transform 0.2s;
            text-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .chat-send-btn:active { transform: scale(0.8); }
        .quote-preview-bar {
            display: none; 
            width: 100%; 
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            border-left: 4px solid #06c755;
            padding: 8px 10px; margin-bottom: 5px; border-radius: 4px;
            font-size: 0.85rem; color: #555;
            justify-content: space-between; align-items: center;
        }
        .quote-text-preview { 
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 85%;
        }
        .quote-close-btn { cursor: pointer; font-weight: bold; padding: 0 5px; color: #999; }
        .msg-quote-block {
            margin-bottom: 6px; padding: 4px 8px; 
            background: rgba(0,0,0,0.05); border-left: 3px solid #ccc;
            font-size: 0.75rem; color: #666; border-radius: 2px;
            display: flex; flex-direction: column;
        }
        .msg-quote-user { font-weight: bold; margin-bottom: 2px; }
        .msg-row.deleting { opacity: 1; }
        .msg-checkbox {
            width: 20px; height: 20px; margin-right: 10px; display: none;
            align-self: center;
        }
        .chat-body.delete-mode .msg-checkbox { display: block; }
        .chat-body.delete-mode .msg-avatar { pointer-events: none; } 
        .delete-toolbar {
            display: none; width: 100%; align-items: center; justify-content: space-between;
            color: #ff4444; font-weight: bold;
        }
        .msg-row { display: flex; gap: 8px; align-items: flex-start; max-width: 100%; width: 100%; }
        .msg-row.other { flex-direction: row; }
        .msg-row.me { flex-direction: row; justify-content: flex-end; }
        
        .msg-avatar { 
            width: 42px; height: 42px; background: #ccc; border-radius: 6px; flex-shrink: 0; 
            background-size: cover; background-position: center; border: 1px solid rgba(0,0,0,0.1);
            position: relative; overflow: visible; display: block; cursor: pointer; 
        }
        .avatar-frame { position: absolute; inset: -6px; width: calc(100% + 12px); height: calc(100% + 12px); pointer-events: none; z-index: 2; object-fit: contain; }
        .msg-bubble {
            padding: 10px 14px; border-radius: 8px; font-size: 0.95rem; line-height: 1.4;
            word-wrap: break-word; max-width: 70%; position: relative;
            background: #fff; color: #000; box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            overflow: visible; 
        } 
        .msg-row.me .msg-bubble { background: #95ec69; color: #000; text-align: left; }
        .msg-image { max-width: 150px; border-radius: 8px; border: 1px solid #ddd; display: block;}

        .msg-row.system { justify-content: center; margin: 10px 0; }
        .msg-system-text { font-size: 0.75rem; color: #999; background: rgba(0,0,0,0.05); padding: 3px 10px; border-radius: 10px; }
        .load-more-container { width: 100%; display: flex; justify-content: center; padding: 10px 0; }
        .load-more-btn {
            background: rgba(0,0,0,0.05); color: #666; border: none;
            padding: 5px 15px; border-radius: 15px; font-size: 0.8rem; cursor: pointer;
        }

     .chat-settings-panel {
    position: absolute; top: 0; right: 0; width: 85%; height: 100%;
    background: #fff; 
    z-index: 3000; /* ✅ 改大：确保浮在所有元素最上面 */
    transform: translateX(100%); transition: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: -5px 0 15px rgba(0,0,0,0.1); padding: 20px; overflow-y: auto; 
    /* ✅ 改大：避开顶部的标题栏区域 */
    padding-top: 130px !important; 
}  
        .chat-settings-panel.open { transform: translateX(0); }
        .range-group { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
        .range-group input { width: 70px; padding: 5px; text-align: center;}
        #sticker-modal {
            position: absolute; bottom: 70px; left: 10px; right: 10px;
            background: rgba(255,255,255,0.95); backdrop-filter: blur(10px);
            border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.15);
            padding: 10px; z-index: 150; display: none; border: 1px solid #ddd;
            height: 300px; display: flex; flex-direction: column;
        }
        .sticker-grid { flex: 1; overflow-y: auto; display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; padding: 5px; }
        .sticker-item-wrap { position: relative; width: 100%; aspect-ratio: 1; }
        .sticker-img { width: 100%; height: 100%; object-fit: contain; cursor: pointer; border-radius: 4px; background: #f5f5f5; }
        .sticker-img:active { transform: scale(0.9); }
        .sticker-del-btn {
            position: absolute; top: -5px; right: -5px; width: 20px; height: 20px;
            background: red; color: white; border-radius: 50%; font-size: 12px;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            display: none; 
        }
        .delete-mode .sticker-del-btn { display: flex; }
        .delete-mode .sticker-img { opacity: 0.7; }
        .sticker-toolbar { display: flex; justify-content: space-between; align-items: center; padding-top: 10px; border-top: 1px solid #eee; }
        #wb-container { display: flex; height: 100%; overflow: hidden; background: #fdfaf8; border-radius: 12px; border: 1px solid #e6dada; }
        .wb-sidebar { width: 110px; background: #ece0e0; overflow-y: auto; flex-shrink: 0; border-right: 1px solid #dcbdbd; }
        .wb-category { padding: 15px 10px; font-size: 0.8rem; color: #6b5858; border-bottom: 1px solid rgba(255,255,255,0.5); cursor: pointer; }
        .wb-category.active { background: #fff; color: #8b0000; font-weight: bold; border-left: 4px solid #8b0000; }
        .wb-main { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        .wb-toolbar { padding: 10px; background: #fff; border-bottom: 1px solid #eee; display: flex; gap: 8px; justify-content: flex-end; }
        .wb-list { flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 10px; }
        .wb-entry { display: flex; align-items: center; gap: 10px; background: #fff; padding: 12px; border-radius: 8px; border: 1px solid #f0f0f0; box-shadow: 0 2px 5px rgba(0,0,0,0.03); }
        .wb-entry-info { flex: 1; overflow: hidden; }
        #wb-editor-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #fff; z-index: 10; display: none; flex-direction: column; }
        .editor-header { padding: 10px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; background: #fdfaf8; }
        .editor-textarea { flex: 1; width: 100%; padding: 15px; border: 1px solid #eee; border-radius: 8px; resize: none; font-size: 1rem; outline: none; }

        .receipt-modal { background: #e0e0e0; }
        .receipt-card {
            background: var(--receipt-bg); width: 100%; max-width: 500px; margin: 0 auto; border-radius: 0;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1); position: relative;
            font-family: 'Courier New', Courier, monospace; color: var(--receipt-ink);
            display: flex; flex-direction: column; height: 100%;
            mask-image: linear-gradient(to top, transparent 1%, black 2%);
        }
        .receipt-header { text-align: center; padding: 35px 20px 10px 20px; border-bottom: 2px dashed #ccc; }
        .receipt-title { font-size: 1.5rem; font-weight: bold; margin-bottom: 5px; letter-spacing: 2px; }
        .receipt-tabs { display: flex; justify-content: space-around; padding: 10px 0; border-bottom: 1px dashed #ccc; font-size: 0.8rem; font-weight: bold; }
        .r-tab { cursor: pointer; padding: 5px 10px; border-radius: 4px; opacity: 0.5; }
        .r-tab.active { opacity: 1; background: #eee; text-decoration: underline; }
        .receipt-body { flex: 1; overflow-y: auto; padding: 15px 20px; display: flex; flex-direction: column; gap: 8px; }
        .word-item { display: flex; justify-content: space-between; align-items: flex-start; border-bottom: 1px dotted #e0e0e0; padding-bottom: 5px; }
        .hidden-file-input { display: none; }
#card-table-desk {
    width: 100%; height: 100%;
    position: relative;
    overflow-y: auto; 
    overflow-x: hidden;
    background: radial-gradient(circle at center, #3c3c3c 0%, #1a1a1a 100%);
    box-shadow: inset 0 0 100px rgba(0,0,0,0.8);
    padding-bottom: 100px; 
}
#card-area {
    width: 100%; height: 100%;
    position: relative;
    transform-style: preserve-3d;
    perspective: 1000px;
}
.playing-card {
    position: absolute;
    width: 60px; height: 90px;
    background-color: #1e3a5f;
    background-image: repeating-linear-gradient(45deg, rgba(255,255,255,0.1) 0px, rgba(255,255,255,0.1) 2px, transparent 2px, transparent 4px);
    border: 2px solid #fff;
    border-radius: 4px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.5);
    cursor: pointer;
    transition: transform 0.6s cubic-bezier(0.2, 0.8, 0.2, 1), z-index 0s;
    display: flex; justify-content: center; align-items: center;
    color: rgba(255,255,255,0.5); font-size: 1.5rem;
    transform-style: preserve-3d; 
}
.playing-card.flipped {
    background-color: #fff;
    background-image: none;
    transform: rotateY(180deg) scale(1) !important; 
    z-index: 1000 !important;
    box-shadow: 0 20px 50px rgba(0,0,0,0.6);
}
.playing-card-front {
    position: absolute; top:0; left:0; width:100%; height:100%;
    backface-visibility: visible; 
    transform: rotateY(180deg); 
    background-size: cover; background-position: center;
    border-radius: 4px;
    display: none; 
}
.playing-card.flipped .playing-card-front { display: block; }
.card-table-ui {
    position: absolute; bottom: 30px; left: 0; right: 0;
    display: flex; flex-direction: column; align-items: center; gap: 10px;
    z-index: 2000; pointer-events: none;
}
.card-table-ui button { pointer-events: auto; }
.paper-brand { font-family: "Old English Text MT", serif; font-size: 3rem; text-align: center; line-height: 1; margin-bottom: 5px; }
.paper-meta-row { display: flex; justify-content: space-between; border-top: 2px solid #000; border-bottom: 1px solid #000; padding: 4px 0; font-family: "Georgia", serif; font-size: 0.8rem; font-weight: bold; text-transform: uppercase; margin-bottom: 15px; }

.paper-split-body {
    display: flex;
    gap: 20px;
    height: calc(100% - 100px); 
}
.vertical-divider { width: 1px; background: #000; opacity: 0.3; height: 100%; flex-shrink: 0; }
.paper-col { flex: 1; display: flex; flex-direction: column; overflow-y: auto; }

.col-header { text-align: center; margin-bottom: 15px; border-bottom: 3px double #ccc; padding-bottom: 10px; }
.col-tag { background: #000; color: #fff; padding: 2px 6px; font-size: 0.6rem; text-transform: uppercase; font-weight: bold; display: inline-block; margin-bottom: 5px; }
.col-header h3 { font-family: "Times New Roman", serif; font-size: 1.6rem; margin: 0; line-height: 1.1; }

.news-cards-strip { 
    display: flex; gap: 5px; flex-wrap: wrap; justify-content: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px dashed #aaa; 
}
.mini-card-display { width: 40px; height: 60px; background: #ddd; border: 1px solid #333; background-size: cover; border-radius: 2px; }

.news-article { font-family: "Georgia", serif; font-size: 0.95rem; line-height: 1.6; text-align: justify; color: #111; }
.news-article h4 { font-size: 1.2rem; margin: 10px 0 5px 0; font-weight: bold; line-height: 1.2; text-align: left; }
.skeleton-text { color: #888; font-style: italic; text-align: center; margin-top: 50px; animation: pulse 1.5s infinite; }
@keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
.finance-nav {
    display: flex; justify-content: space-between; align-items: center;
    margin-bottom: 15px; color: #555; font-weight: bold;
}
.finance-nav button { background:none; border:none; font-size:1.2rem; color:#7d8c7c; cursor:pointer; }

.finance-chart-container {
    margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.5); 
    border-radius: 8px; font-size: 0.75rem;
}
.chart-row { display: flex; align-items: center; margin-bottom: 6px; }
.chart-label { width: 40px; text-align: right; margin-right: 8px; color: #666; }
.chart-bar-bg { flex: 1; background: #eee; height: 8px; border-radius: 4px; overflow: hidden; }
.chart-bar-fill { height: 100%; border-radius: 4px; transition: width 0.5s ease; }
.chart-val { width: 50px; text-align: right; margin-left: 5px; color: #888; }

.cat-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-top: 10px; }
.cat-btn {
    padding: 8px 2px; border: 1px solid #ddd; border-radius: 6px; 
    background: #fff; color: #555; font-size: 0.8rem; cursor: pointer; text-align: center;
    transition: all 0.2s;
}
.cat-btn:active { transform: scale(0.95); }
.cat-btn.expense { border-color: #e8d7d7; color: #a33; }
.cat-btn.income { border-color: #d4e8d7; color: #366; }

.history-selector {
    position: absolute; top: 50px; right: 20px; 
    background: #fff; border: 1px solid #ccc; padding: 10px;
    border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    display: none; z-index: 10;
}
#tarot-result-area {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background: #fdfbf7;
    z-index: 150;
    display: none;
    flex-direction: column;
    overflow-y: auto; 
    padding: 80px 20px 50px 20px; 
    box-sizing: border-box;
}
#tarot-app-modal .modal-body {
    padding: 0;
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden; 
    position: relative; 
}

#tarot-desk-area {
    flex: 1;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    position: relative;
    background: radial-gradient(circle at center, #3c3c3c 0%, #1a1a2e 100%);
}

#tarot-card-spread {
    flex: 1;
    width: 100%;
    overflow-y: auto; 
    overflow-x: hidden;
    padding: 20px 10px 120px 10px; 
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-content: flex-start;
    gap: 12px;
}
.tarot-bottom-bar {
    position: absolute;
    bottom: 30px;
    left: 0;
    right: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    z-index: 100; 
    pointer-events: none; 
}
.tarot-bottom-bar button {
    pointer-events: auto; 
    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    backdrop-filter: blur(5px);
    border-radius: 30px;
    padding: 12px 30px;
    font-weight: bold;
    transition: transform 0.1s;
}
.tarot-bottom-bar button:active { transform: scale(0.95); }
#selected-cards-header {
    display: flex !important;
    flex-direction: row !important;
    flex-wrap: nowrap !important;
    overflow-x: auto !important;
    overflow-y: hidden !important;
    justify-content: flex-start !important;
    align-items: flex-start !important;
    gap: 15px !important; 
    width: 100% !important;
    min-height: 140px !important; 
    padding: 10px 5px !important;
    margin-bottom: 20px !important;
    -webkit-overflow-scrolling: touch;
    position: relative;
    z-index: 10;
}
#selected-cards-header::-webkit-scrollbar {
    display: none;
}
.result-card-display {
    flex: 0 0 auto !important; 
    flex-shrink: 0 !important;
    width: 64px !important;
    height: auto !important;
    display: flex !important;
    flex-direction: column !important;
    align-items: center !important;
    position: relative;
    margin: 0 !important;
}
.result-card-img {
    width: 60px !important;
    height: 90px !important;
    background-size: cover;
    background-position: center;
    border-radius: 4px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    border: 1px solid rgba(255,255,255,0.8);
    transition: transform 0.3s;
    margin-bottom: 8px !important;
}
.result-card-tag {
    position: static !important; 
    width: 100%;
    text-align: center;
    font-size: 0.7rem;
    line-height: 1.2;
    color: #333;
    font-weight: bold;
    word-wrap: break-word; 
    white-space: normal;
}
.reverse-tag {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%) rotate(180deg) !important;
    
    background: rgba(180, 0, 0, 0.9);
    color: white;
    font-size: 0.5rem;
    padding: 2px 5px;
    border-radius: 3px;
    white-space: nowrap;
    pointer-events: none;
    z-index: 5;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
}
#tarot-history-panel {
    z-index: 3000 !important; 
    background: #fdfbf7;
    box-shadow: -5px 0 20px rgba(0,0,0,0.2);
}
.tarot-card-item {
    width: 60px; 
    height: 90px;
    position: relative;
    cursor: pointer;
    perspective: 1000px; 
    margin: 5px; 
}
.tarot-card-inner {
    position: relative;
    width: 100%;
    height: 100%;
    text-align: center;
    transition: transform 0.6s;
    transform-style: preserve-3d;
    border-radius: 4px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
}
.tarot-card-item.picked .tarot-card-inner {
    transform: rotateY(180deg);
}
.t-card-front, .t-card-back {
    position: absolute;
    width: 100%;
    height: 100%;
    backface-visibility: hidden; 
    -webkit-backface-visibility: hidden;
    border-radius: 4px;
    top: 0; 
    left: 0;
}
.t-card-back {
    background: #1e272e;
    border: 2px solid #d2b48c;
    background-image: repeating-linear-gradient(45deg, rgba(255,255,255,0.05) 0px, rgba(255,255,255,0.05) 2px, transparent 2px, transparent 4px);
    z-index: 2;
}
.t-card-front {
    background-color: #fff;
    background-size: cover;
    background-position: center;
    color: #333;
    display: flex;
    align-items: center; 
    justify-content: center;
    transform: rotateY(180deg); 
    border: 1px solid #ddd;
}

.letter-write-container {
    display: block; 
    width: 100%;
    height: 100%;
    overflow-y: auto; 
    padding: 20px;
    padding-bottom: 150px; 
    background: #e6e6e6; 
    box-sizing: border-box;
    -webkit-overflow-scrolling: touch; 
}
.paper-sheet {
    background-color: #fdf6e3;
    background-image: repeating-linear-gradient(#fdf6e3 0px, #fdf6e3 29px, #ccc 30px);
    background-attachment: local;     
    width: 100%;
    max-width: 600px;
    margin: 0 auto 30px auto; 
    padding: 30px 30px 50px 30px; 
    
    border-radius: 2px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    
    font-family: 'Long Cang', cursive, serif; 
    font-size: 1.3rem;
    line-height: 30px; 
    color: #2b2626;
    min-height: 80vh; 
    height: auto !important; 
    overflow: visible; 
    position: relative;
    transition: all 0.3s ease;
    display: flex;
    flex-direction: column;
}
.letter-textarea-clean {
    width: 100%; 
    min-height: 60vh;
    height: auto;
    border: none; 
    background: transparent; 
    resize: none; 
    outline: none;     
    font-family: inherit; 
    font-size: inherit;
    line-height: inherit;    
    overflow-y: hidden; 
    display: block;
    margin-top: 10px;
    flex: 1;
}
#reply-content-display {
    white-space: pre-wrap; 
    word-wrap: break-word;
    width: 100%;
    font-family: inherit;
    font-size: inherit;
    line-height: inherit;
    min-height: 200px;
}
.sheet-user { 
    transform: rotate(-0.5deg); 
    background-color: #fdf6e3;
}
.sheet-reply { 
    background-color: #fff0f5; 
    background-image: repeating-linear-gradient(#fff0f5 0px, #fff0f5 29px, #dcbdbd 30px);
    transform: rotate(0.5deg); 
}
.sheet-dice-bar {
    display: flex; gap: 10px; justify-content: center;
    padding-bottom: 15px; border-bottom: 2px dashed #ccc;
    margin-bottom: 15px;
}
.receipt-gift-wrapper {
    background: #fff; 
    width: 300px;   
    max-width: 90%;
    max-height: 85vh; 
    overflow-y: auto;
    margin: auto;     
    padding: 20px;
    font-family: 'Courier New', Courier, monospace;
    color: #333;
    box-shadow: 0 0 20px rgba(0,0,0,0.5); 
    position: relative;
    border-top: 1px dashed #ccc;
    border-bottom: 1px dashed #ccc;
}
.receipt-gift-wrapper::before, .receipt-gift-wrapper::after {
    content: ""; position: absolute; left: 0; width: 100%; height: 4px;
    background-size: 8px 8px;
}
.receipt-gift-wrapper::before {
    top: -4px; background-image: radial-gradient(circle, #fff 4px, transparent 5px);
}
.receipt-gift-wrapper::after {
    bottom: -4px; background-image: radial-gradient(circle, #fff 4px, transparent 5px);
    background-position: 4px 0;
}
.gift-invoice-head { text-align: center; border-bottom: 2px dashed #333; padding-bottom: 10px; margin-bottom: 15px; }
.gift-invoice-title { font-size: 1.5rem; font-weight: bold; letter-spacing: 2px; }
.gift-invoice-meta { font-size: 0.7rem; color: #666; margin-top: 5px; text-transform: uppercase; }

.gift-item-row { display: flex; justify-content: space-between; margin-bottom: 10px; font-weight: bold; font-size: 1.1rem; }
.gift-desc-block { font-size: 0.85rem; text-align: justify; line-height: 1.4; border-top: 1px solid #eee; padding-top: 10px; margin-bottom: 10px; }
.gift-reason-block { font-size: 0.7rem; background: #f0f0f0; padding: 8px; margin-top: 10px; border-radius: 4px; }
.gift-barcode { font-family: 'Libre Barcode 39', cursive; font-size: 2.5rem; text-align: center; margin-top: 15px; opacity: 0.7; transform: scaleY(0.8); }
.letter-write-container {
    height: 100%;
    overflow-y: auto;
    padding-bottom: 200px; 
}
.paper-sheet {
    height: auto !important; 
    min-height: 80vh; 
    overflow: visible; 
    display: flex;
    flex-direction: column;
}
.letter-textarea-clean {
    width: 100%;
    overflow-y: hidden; 
    height: auto;
    min-height: 300px;
    resize: none;
    display: block;
}
.tarot-bottom-bar {
    position: fixed; 
    bottom: 40px;    
    left: 50%;
    transform: translateX(-50%);
    z-index: 9999 !important;
    display: flex;
    gap: 15px;
    background: rgba(0,0,0,0.8); 
    padding: 12px 30px;
    border-radius: 50px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    backdrop-filter: blur(10px);
    width: auto;
    white-space: nowrap;
}
#theater-modal {
    background: #fff;
    transition: background 0.3s, color 0.3s;
}

.theater-theme-day {
    --th-bg: #f7f1e3;
    --th-text: #2c3e50;
    --th-accent: #8e44ad;
    --th-bar: #e5dbc9;
    --th-input-bg: rgba(255,255,255,0.6);
}

.theater-theme-night {
    --th-bg: #1e1e1e;
    --th-text: #a8a8a8;
    --th-accent: #9b59b6;
    --th-bar: #2d2d2d;
    --th-input-bg: rgba(0,0,0,0.3);
}
.theater-theme-green {
    --th-bg: #c7edcc; 
    --th-text: #2e3b2e; 
    --th-accent: #3e8e41;
    --th-bar: #b8dcb8; 
    --th-input-bg: rgba(255,255,255,0.5);
}

#theater-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 100%;
    background: var(--th-bg);
    color: var(--th-text);
    font-family: "Noto Serif SC", "Songti SC", serif; 
}
.theater-header {
    padding: 15px 20px;
    padding-top: max(15px, env(safe-area-inset-top));
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: var(--th-bar);
    border-bottom: 1px solid rgba(0,0,0,0.1);
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}
.th-title { font-size: 1.2rem; font-weight: bold; color: var(--th-accent); }
#theater-scroll-area {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    padding-bottom: 50px;
    scroll-behavior: smooth;
}

.novel-segment {
    margin-bottom: 25px;
    position: relative;
    line-height: 1.8;
    font-size: 1.1rem;
    text-align: justify;
    padding-bottom: 15px;
    border-bottom: 1px dashed rgba(128,128,128,0.2);
}
.novel-segment p { margin-bottom: 15px; text-indent: 2em; }

.segment-del-btn {
    position: absolute;
    right: 0;
    top: 0;
    font-size: 0.8rem;
    color: #ff6b6b;
    opacity: 0.3;
    cursor: pointer;
    padding: 5px;
}
.novel-segment:hover .segment-del-btn { opacity: 1; }
.theater-footer {
    padding: 15px;
    padding-bottom: max(20px, env(safe-area-inset-bottom));
    background: var(--th-bar);
    border-top: 1px solid rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.th-input-row { display: flex; gap: 10px; align-items: flex-end; }
.th-textarea {
    flex: 1;
    background: var(--th-input-bg);
    border: 1px solid rgba(128,128,128,0.3);
    border-radius: 8px;
    padding: 10px;
    font-family: inherit;
    font-size: 1rem;
    resize: none;
    outline: none;
    height: 60px;
    color: var(--th-text);
}
.th-textarea:focus { border-color: var(--th-accent); }

.th-btn {
    padding: 10px 15px;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    font-weight: bold;
    transition: 0.2s;
    background: var(--th-accent);
    color: white;
    font-size: 0.9rem;
    white-space: nowrap;
}
.th-btn:active { transform: scale(0.95); }
.th-btn.secondary { background: rgba(128,128,128,0.2); color: var(--th-text); }
.th-loading {
    text-align: center;
    padding: 20px;
    color: var(--th-accent);
    font-style: italic;
    animation: th-pulse 1.5s infinite;
}
@keyframes th-pulse { 0% { opacity: 0.4; } 50% { opacity: 1; } 100% { opacity: 0.4; } }
#theater-history-panel {
    z-index: 2500;
    background: var(--th-bg);
    color: var(--th-text);
}
.period-theme {
    --p-bg: #fce4ec;
    --p-card: #fff0f5;
    --p-accent: #d81b60;
    --p-text: #880e4f;
}

#period-modal {
    background: #fdfbf7; 
}

.cycle-dashboard {
    background: linear-gradient(135deg, #fce4ec 0%, #f8bbd0 100%);
    border-radius: 16px;
    padding: 20px;
    color: var(--p-text);
    box-shadow: 0 4px 15px rgba(216, 27, 96, 0.15);
    margin-bottom: 20px;
    text-align: center;
    position: relative;
    overflow: hidden;
}

.cycle-status-text {
    font-size: 1.8rem;
    font-weight: bold;
    font-family: "Georgia", serif;
    margin: 10px 0;
}

.cycle-sub-text {
    font-size: 0.9rem;
    opacity: 0.8;
}

.period-toggle-btn {
    background: white;
    color: var(--p-accent);
    border: 1px solid var(--p-accent);
    padding: 8px 20px;
    border-radius: 20px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    margin-top: 10px;
}
.period-toggle-btn.active {
    background: var(--p-accent);
    color: white;
    box-shadow: 0 0 10px rgba(216, 27, 96, 0.4);
}

.ai-care-card {
    background: white;
    border-left: 4px solid var(--p-accent);
    padding: 15px;
    margin-bottom: 15px;
    border-radius: 4px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}

.recipe-box {
    background: #fff;
    border: 1px dashed #aaa;
    padding: 15px;
    margin-top: 10px;
    font-family: "Courier New", monospace;
    font-size: 0.85rem;
}

.history-log-item {
    display: flex;
    justify-content: space-between;
    padding: 10px;
    border-bottom: 1px solid #eee;
    font-size: 0.9rem;
    color: #555;
}
.cycle-dashboard {
    height: auto !important;
    min-height: 120px !important;
    overflow: visible !important;
    display: flex !important;
    flex-direction: column !important;
    justify-content: center !important;
    align-items: center !important;
    padding: 20px !important;
    background: linear-gradient(135deg, #fce4ec 0%, #f8bbd0 100%) !important;
    color: #880e4f !important;
}

.cycle-status-text {
    display: block !important;
    color: #880e4f !important;
    opacity: 1 !important;
}

.period-toggle-btn {
    display: inline-block !important;
    opacity: 1 !important;
    z-index: 10 !important;
    cursor: pointer !important;
}
#forum-modal {
    background: #f2f3f5; 
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
}
.forum-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 100%;
}
.forum-scroll-area {
    flex: 1;
    overflow-y: auto;
    padding-bottom: 20px;
}
.forum-thread-header {
    background: #fff;
    padding: 20px 15px;
    margin-bottom: 10px;
    border-bottom: 1px solid #e1e1e1;
}
.forum-title-text {
    font-size: 1.3rem;
    font-weight: bold;
    color: #333;
    margin-bottom: 10px;
    line-height: 1.4;
}
.forum-post-row {
    background: #fff;
    padding: 15px;
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    gap: 12px;
    align-items: flex-start;
}
.forum-avatar {
    width: 40px;
    height: 40px;
    border-radius: 4px; 
    background-color: #ddd;
    background-size: cover;
    background-position: center;
    flex-shrink: 0;
}
.forum-content-col {
    flex: 1;
}
.forum-user-line {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
}
.forum-username {
    font-size: 0.9rem;
    color: #666;
    font-weight: bold;
}
.forum-lz-tag {
    background: #fffbf0;
    color: #ff9c00;
    border: 1px solid #ff9c00;
    font-size: 0.6rem;
    padding: 0 4px;
    border-radius: 2px;
    margin-left: 5px;
}
.forum-floor-num {
    font-size: 0.8rem;
    color: #999;
}
.forum-text-body {
    font-size: 1rem;
    color: #111;
    line-height: 1.6;
    word-break: break-word;
    white-space: pre-wrap;
}
.forum-action-bar {
    margin-top: 10px;
    display: flex;
    gap: 20px;
    font-size: 1.2rem;
    color: #999;
}
.forum-icon-btn { cursor: pointer; display: flex; align-items: center; gap: 4px; font-size: 0.8rem;}
.forum-footer-bar {
    background: #fff;
    padding: 10px 15px;
    padding-bottom: max(15px, env(safe-area-inset-bottom));
    border-top: 1px solid #ddd;
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.forum-input-settings {
    display: flex;
    gap: 10px;
    overflow-x: auto;
    padding-bottom: 5px;
    font-size: 0.8rem;
}
.fridge-body {
    height: 90%; 
    width: 95%; 
    max-width: 480px;
    margin: auto;
    display: flex; 
    flex-direction: column;
    position: relative;
    overflow: hidden;
    background-color: #f8f9fa;
    background-image: radial-gradient(circle at 50% 30%, #ffffff 0%, #e3f2fd 80%);
    border: 12px solid #cfd8dc;
    border-radius: 36px;
    box-shadow: 
        inset 0 0 60px rgba(0,0,0,0.15), 
        0 20px 50px rgba(0,0,0,0.3);     
}
.fridge-body::after {
    content: "";
    position: absolute; top: 0; left: 10%; right: 10%; height: 60px;
    background: radial-gradient(ellipse at center, rgba(255,255,255,0.9) 0%, transparent 70%);
    opacity: 0.8;
    pointer-events: none;
    z-index: 1;
}
.fridge-shelf {
    position: relative; 
    z-index: 5;
    padding: 5px 15px;
    display: flex; 
    align-items: flex-end; 
    gap: 8px;
    width: 100%;
    background: linear-gradient(to right, rgba(255,255,255,0.1), rgba(255,255,255,0.4), rgba(255,255,255,0.1));
    border-bottom: 6px solid rgba(220, 240, 255, 0.6); 
    box-shadow: 0 8px 10px -5px rgba(0,0,0,0.1); 
}
.shelf-label {
    position: absolute; right: 10px; bottom: 8px;
    font-size: 0.6rem; color: #b0bec5; font-weight: 800; text-transform: uppercase;
    letter-spacing: 1px; pointer-events: none; z-index: 2;
}
.shelf-1 {
    height: 20%;
    align-items: flex-end;
    justify-content: space-around;
    padding-bottom: 5px;
}
.condiment-jar {
    display: flex; flex-direction: column; align-items: center;
    transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    cursor: pointer; transform-origin: bottom center;
    position: relative; opacity: 0.5; filter: grayscale(0.5);
}
.condiment-jar.active {
    opacity: 1; filter: grayscale(0);
    transform: scale(1.15) translateY(-5px);
    z-index: 10;
}
.jar-cap {
    width: 24px; height: 10px;
    background: linear-gradient(to right, #78909c, #455a64);
    border-radius: 3px; box-shadow: 0 2px 3px rgba(0,0,0,0.2);
}
.jar-body {
    width: 30px; height: 45px;
    background: rgba(255,255,255,0.2);
    border: 1px solid rgba(255,255,255,0.6);
    border-radius: 6px 6px 8px 8px;
    position: relative; overflow: hidden;
    box-shadow: inset 2px 0 5px rgba(255,255,255,0.4);
}
.jar-liquid {
    position: absolute; bottom: 0; left: 0; width: 100%; height: 60%;
    transition: background 0.3s;
    border-top: 1px solid rgba(255,255,255,0.5);
}
.jar-name {
    font-size: 0.6rem; margin-top: 2px; color: #546e7a; font-weight: bold;
    text-shadow: 0 1px 0 rgba(255,255,255,0.8);
}
.jar-type-耗油 .jar-liquid { background: #4e342e; } 
.jar-type-生抽 .jar-liquid { background: #212121; } 
.jar-type-盐 .jar-liquid { background: #f5f5f5; height: 80%; background-image: radial-gradient(#ccc 1px, transparent 1px); background-size:3px 3px;}
.jar-type-糖 .jar-liquid { background: #fff9c4; height: 75%; opacity: 0.9; }
.jar-type-醋 .jar-liquid { background: #3e2723; height: 65%; }
.jar-type-料酒 .jar-liquid { background: #ffb74d; opacity: 0.8; }
.jar-type-油 .jar-liquid { background: #ffeb3b; opacity: 0.8; }
.shelf-2 {
    height: 18%;
    justify-content: space-evenly;
}
.staple-item {
    background: #fff;
    border: 1px solid #eceff1;
    border-radius: 10px;
    padding: 5px 12px;
    text-align: center;
    box-shadow: 0 4px 6px rgba(0,0,0,0.05);
    transition: 0.2s; cursor: pointer;
    font-size: 0.85rem; color: #455a64;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    min-width: 60px;
}
.staple-item.active {
    background: #fff8e1; border-color: #ffecb3;
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(255, 193, 7, 0.2);
    color: #f57f17; font-weight: bold;
}
.staple-count { font-size: 0.7rem; color: #aaa; margin-top: 2px; }
.staple-item.active .staple-count { color: #f9a825; }
.shelf-3, .shelf-4 {
    height: 22%;
    padding: 0; 
    border-bottom: none; 
    background: none; 
    box-shadow: none;
    display: flex;
    justify-content: center;
    align-items: center;
    perspective: 800px; 
}
.crisper-drawer {
    width: 92%; height: 90%;
    background: rgba(255, 255, 255, 0.25);
    border: 2px solid rgba(255, 255, 255, 0.6);
    border-radius: 0 0 16px 16px;
    border-top: 4px solid rgba(255,255,255,0.8); 
    
    backdrop-filter: blur(4px);
    box-shadow: 
        inset 0 10px 20px rgba(255,255,255,0.4),
        0 5px 15px rgba(0,0,0,0.05);
        
    display: flex; flex-wrap: wrap; 
    align-content: flex-start; gap: 8px;
    padding: 12px;
    overflow-y: auto;
    position: relative;
    transition: transform 0.2s;
}
.drawer-handle-label {
    position: absolute; top: -14px; left: 50%; transform: translateX(-50%);
    background: rgba(255,255,255,0.9);
    padding: 2px 10px; border-radius: 10px 10px 0 0;
    font-size: 0.65rem; color: #78909c; font-weight: bold; text-transform: uppercase;
    box-shadow: 0 -2px 5px rgba(0,0,0,0.05);
}
.ing-tag {
    padding: 4px 10px; border-radius: 6px; font-size: 0.8rem; 
    cursor: pointer; font-weight: 500;
    display: flex; align-items: center; gap: 4px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    transition: transform 0.1s;
}
.ing-tag:active { transform: scale(0.95); }
.ing-tag.veg { background: #e8f5e9; color: #2e7d32; border: 1px solid #c8e6c9; }
.ing-tag.meat { background: #ffebee; color: #c62828; border: 1px solid #ffcdd2; }
.add-ing-btn {
    width: 28px; height: 28px; border-radius: 50%;
    background: rgba(255,255,255,0.5); 
    border: 1px dashed #90a4ae; color: #78909c;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; font-size: 1.2rem; transition: 0.2s;
}
.add-ing-btn:hover { background: #fff; border-color: #29b6f6; color: #29b6f6; }
.shelf-5 {
    flex: 1; 
    background: linear-gradient(to bottom, #cfd8dc, #b0bec5); 
    border-top: 1px solid #fff;
    border-bottom: none;
    box-shadow: inset 0 5px 10px rgba(0,0,0,0.1);
    
    display: flex; justify-content: center; align-items: center;
    padding: 0;
}
.smart-screen {
    width: 60%; height: 70%;
    background: #000;
    border-radius: 12px;
    border: 2px solid #546e7a;
    box-shadow: 0 0 15px rgba(0, 255, 255, 0.1);
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    color: #4fc3f7; cursor: pointer;
    overflow: hidden; position: relative;
    transition: all 0.2s;
}
.smart-screen:active { transform: scale(0.96); border-color: #29b6f6; }
.smart-screen-icon { font-size: 1.8rem; margin-bottom: 5px; }
.smart-screen-text { font-size: 0.75rem; letter-spacing: 1px; font-family: sans-serif;}
.smart-screen::before {
    content: ""; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
    background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
    transform: rotate(45deg);
    animation: screenShine 5s infinite;
}
@keyframes screenShine { 0% { left: -100%; } 20% { left: 100%; } 100% { left: 100%; } }

#call-overlay {
    border-radius: 24px; 
    background: #0f172a; 
}
.recipe-note-card {
    background: #fff9c4;
    color: #333;
    font-family: "Comic Sans MS", cursive, sans-serif;
    transform: rotate(-1deg);
    box-shadow: 3px 3px 10px rgba(0,0,0,0.3);
    border-top: 8px solid rgba(255,255,0,0.3); 
}
.fridge-history-panel {
    position: absolute; right: 0; top: 0; height: 100%; width: 260px;
    background: #fdfbf7;
    border-left: 1px solid #ddd;
    box-shadow: -5px 0 20px rgba(0,0,0,0.1);
    z-index: 20;
    transform: translateX(100%);
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    padding: 20px; overflow-y: auto;
}
.fridge-history-panel.open { transform: translateX(0); }
#fridge-modal {
    background: #f2f4f6 !important; 
    align-items: flex-end;
    padding: 0 !important;
}
.fridge-app-container {
    width: 100%; height: 100%;
    background: #f2f4f6;
    display: flex; flex-direction: column;
    position: relative;
    overflow: hidden;
    font-family: -apple-system, BlinkMacSystemFont, sans-serif;
}
        .fridge-header-clean {
            height: 90px;
            background: #fff;
            border-bottom: 1px solid #e0e0e0;
            display: flex; 
            align-items: flex-end;
            justify-content: space-between;
            padding: 0 15px;
            padding-bottom: 10px;
            flex-shrink: 0;
        }
.fh-btn { border:none; background:none; font-size:1rem; color:#333; cursor:pointer; font-weight: 500;}
.fh-title { font-weight: bold; font-size: 1.1rem; color:#333; }
.fh-icon { font-size: 1.5rem; color:#333; cursor:pointer; transform: rotate(-30deg); }
.fridge-scroll-body {
    flex: 1;
    overflow-y: auto;
    padding: 15px;
    padding-bottom: 120px;
}

.section-title {
    font-size: 0.85rem; color: #8898aa; margin: 20px 0 10px 5px; font-weight: bold;
}
.condiments-grid {
    display: flex; gap: 15px; overflow-x: auto; padding: 15px 10px;
    background: #fff; border-radius: 12px; margin-bottom: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.02);
}
.flat-bottle {
    display: flex; flex-direction: column; align-items: center; gap: 6px;
    opacity: 0.3; transition: 0.2s; min-width: 50px; cursor: pointer; filter: grayscale(100%);
}
.flat-bottle.active { opacity: 1; transform: scale(1.05); filter: grayscale(0%); }
.bottle-shape {
    width: 32px; height: 50px;
    border-radius: 6px;
    position: relative;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.bottle-shape::before {
    content: ""; position: absolute; top: -5px; left: 50%; transform: translateX(-50%);
    width: 14px; height: 5px; border-radius: 2px;
}
.b-oil .bottle-shape { background: #fdd835; } 
.b-oil .bottle-shape::before { background: #e53935; } 

.b-dark .bottle-shape { background: #5d4037; } 
.b-dark .bottle-shape::before { background: #d84315; }

.b-black .bottle-shape { background: #212121; } 
.b-black .bottle-shape::before { background: #ef5350; }

.b-white .bottle-shape { background: #fff; border:1px solid #ddd;} 
.b-white .bottle-shape::before { background: #bdbdbd; width:28px; height: 3px; top: 2px;}

.b-wine .bottle-shape { background: #ffca28; } 
.b-wine .bottle-shape::before { background: #d84315; }

.bottle-name { font-size: 0.7rem; color: #555; }
.staples-row {
    display: flex; justify-content: space-around;
    background: #fff; padding: 20px; border-radius: 12px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.02);
}
.staple-icon-btn {
    position: relative; display: flex; flex-direction: column; align-items: center;
    opacity: 0.4; transition: 0.2s; cursor: pointer;
}
.staple-icon-btn.active { opacity: 1; }
.staple-img { font-size: 1.8rem; margin-bottom: 5px; }
.staple-badge {
    position: absolute; top: -5px; right: -8px;
    background: #ff3b30; color: white; font-size: 0.6rem;
    padding: 2px 6px; border-radius: 10px; font-weight: bold; min-width: 18px; text-align: center;
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
}
.staple-label { font-size: 0.8rem; color: #333; }
.tags-container {
    display: flex; flex-wrap: wrap; gap: 10px;
    padding: 5px;
}
.ing-tag-pill {
    background: #fff;
    padding: 8px 15px;
    border-radius: 20px;
    font-size: 0.9rem; color: #333;
    display: flex; align-items: center; gap: 8px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05); border: 1px solid #e0e0e0;
}
.ing-tag-pill .count { 
    color: #888; font-size: 0.9rem; background: #f0f0f0; 
    padding: 0 6px; border-radius: 4px;
}
.ing-tag-pill .del-x { color: #ff3b30; margin-left: 2px; cursor: pointer; font-weight: bold; opacity: 0.6;}

.add-circle-btn {
    width: 38px; height: 38px; border-radius: 50%;
    border: 1px dashed #bbb; color: #bbb;
    display: flex; align-items: center; justify-content: center;
    font-size: 1.4rem; background: transparent; cursor: pointer;
}
.fridge-footer-fixed {
    position: absolute; bottom: 30px; left: 20px; right: 20px;
    z-index: 10;
}
.big-call-btn {
    width: 100%; height: 56px;
    background: #00e0ff; /* 亮青蓝 */
    background: linear-gradient(to right, #00c6ff, #0072ff);
    color: white; border: none; border-radius: 28px;
    font-size: 1.1rem; font-weight: bold;
    display: flex; align-items: center; justify-content: center; gap: 10px;
    box-shadow: 0 10px 20px rgba(0, 114, 255, 0.3);
    transition: transform 0.1s; cursor: pointer;
}
.big-call-btn:active { transform: scale(0.98); }
#wechat-call-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: #000;
    z-index: 9999;
    display: none; flex-direction: column; align-items: center;
    color: white;
    padding-top: 10vh;
}
.wx-minimize { position: absolute; top: 50px; left: 20px; opacity: 0.7; font-size: 1.5rem; cursor: pointer;}
.wx-avatar {
    width: 110px; height: 110px; border-radius: 12px;
    background-size: cover; background-position: center;
    margin-bottom: 25px; 
    background-color: #333; border: 1px solid #444;
}
.wx-name { font-size: 1.8rem; font-weight: 500; margin-bottom: 10px; }
.wx-status { font-size: 1rem; opacity: 0.6; margin-bottom: 30px; font-weight: 300;}

.wx-subtitle-box {
    width: 85%; max-height: 250px; overflow-y: auto;
    text-align: center; color: rgba(255,255,255,0.9);
    font-size: 1.1rem; line-height: 1.6;
    padding: 10px; 
    background: rgba(255,255,255,0.05);
    border-radius: 16px;
    backdrop-filter: blur(10px);
    margin-bottom: 20px;
}

.wx-footer-btns {
    margin-top: auto; margin-bottom: 60px;
    display: flex; justify-content: space-around; width: 100%; padding: 0 30px;
}
.wx-btn-col { display: flex; flex-direction: column; align-items: center; gap: 12px; cursor: pointer;}
.wx-round-btn {
    width: 72px; height: 72px; border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-size: 2rem; color: white;
    transition: 0.2s;
}
.wx-round-btn:active { filter: brightness(0.8); }
.wx-btn-hangup { background: #ff3b30; }
.wx-btn-normal { background: rgba(255,255,255,0.15); backdrop-filter: blur(5px);}
.wx-btn-label { font-size: 0.8rem; opacity: 0.7; }
#fridge-history-panel {
    position: absolute;
    top: 50px; 
    right: 0;
    bottom: 0; 
    width: 280px;
    background: #fdfbf7; 
    border-left: 1px solid #e0e0e0;
    box-shadow: -5px 0 20px rgba(0,0,0,0.1);
    z-index: 2000; 
    transform: translateX(100%); 
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    padding: 20px;
    overflow-y: auto;
}
#fridge-history-panel.open {
    transform: translateX(0); 
}
.sticky-paper {
    background: linear-gradient(135deg, #fff9c4 0%, #fff59d 100%); 
    padding: 15px;
    margin-bottom: 20px;
    box-shadow: 2px 4px 8px rgba(0,0,0,0.15);
    font-family: "Comic Sans MS", cursive, sans-serif; 
    color: #5d4037;
    position: relative;
    transform: rotate(-1deg); 
    transition: transform 0.2s;
    border-radius: 2px;
}
.sticky-paper:nth-child(even) {
    transform: rotate(1deg);
    background: linear-gradient(135deg, #e1f5fe 0%, #b3e5fc 100%); 
}
.sticky-paper:hover {
    transform: scale(1.02) rotate(0deg); 
    z-index: 10;
    box-shadow: 5px 10px 15px rgba(0,0,0,0.2);
}
.sticky-paper::before {
    content: "";
    position: absolute;
    top: -10px;
    left: 50%;
    transform: translateX(-50%);
    width: 60px;
    height: 20px;
    background: rgba(255, 255, 255, 0.4);
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    transform: translateX(-50%) rotate(-2deg);
}
#sticky-note-modal {
    display: none; 
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.6);
    z-index: 3000;
}
.big-sticky-note {
    width: 80%;
    max-width: 400px;
    min-height: 400px;
    background: #fff9c4;
    padding: 30px;
    box-shadow: 10px 10px 30px rgba(0,0,0,0.3);
    font-family: "Comic Sans MS", cursive, sans-serif;
    position: relative;
    display: flex;
    flex-direction: column;
}
.note-pin {
    position: absolute; top: -15px; left: 50%; transform: translateX(-50%);
    font-size: 2rem; color: #d32f2f; text-shadow: 2px 2px 2px rgba(0,0,0,0.3);
}
#note-detail-content {
    white-space: pre-wrap;      
    line-height: 1.6; 
    font-size: 0.95rem; 
    color: #3e2723; 
    flex: 1;         
    overflow-y: auto;           
    max-height: 55vh;           
    padding-right: 5px;         
    margin-bottom: 10px;
    background-image: repeating-linear-gradient(transparent, transparent 27px, #d7ccc8 28px);
    background-attachment: local;
}
.fridge-item-large {
    grid-column: span 1; 
    grid-row: span 2;    
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #fff9c4 0%, #fff59d 100%); 
    border-radius: 24px; 
    border: 4px solid #fff; 
    box-shadow: 
        inset 5px 5px 15px rgba(255,255,255,0.8), 
        inset -5px -5px 10px rgba(210, 180, 140, 0.2), 
        0 8px 15px rgba(0,0,0,0.1);             
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    cursor: pointer;
    transition: transform 0.2s;
    padding: 10px; 
}
.fridge-item-large::before {
    content: "";
    position: absolute;
    top: 35%; 
    left: 10px;
    right: 10px;
    height: 2px;
    background: rgba(0,0,0,0.05);
    border-bottom: 1px solid rgba(255,255,255,0.5);
}
.fridge-handle {
    position: absolute;
    left: 12px;
    top: 40%; 
    width: 8px;
    height: 60px;
    background: linear-gradient(to right, #e0e0e0, #ffffff, #bdbdbd);
    border-radius: 6px;
    box-shadow: 1px 1px 3px rgba(0,0,0,0.15);
}
.fridge-sticker {
    font-size: 2.2rem;
    filter: drop-shadow(0 2px 3px rgba(0,0,0,0.1));
    transform: rotate(8deg);
    margin-top: -20px; 
    margin-left: 15px; 
}
#fridge-modal {
    background: #fffbe7 !important; 
}
.fridge-header-clean {
    background: rgba(255,255,255,0.6) !important;
    backdrop-filter: blur(10px);
    border-bottom: 1px dashed #e6dca0 !important;
}
.fridge-app-container {
    background: #fffbe7 !important;
}
.condiments-grid, .staples-row, .tags-container, .ing-tag-pill {
    border: 1px solid #fff !important;
    background: rgba(255,255,255,0.7) !important;
    box-shadow: 0 4px 10px rgba(230, 210, 160, 0.2) !important;
}
#pickup-modal {
    background: #f0f2f5; 
    display: none;
    flex-direction: column;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
}

.pickup-header {
    background: #fff;
    border-bottom: 1px solid #dcdcdc;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 15px;
    padding-top: max(10px, env(safe-area-inset-top));
    flex-shrink: 0;
    z-index: 10;
}
#pickup-chat-area {
    flex: 1;
    overflow-y: auto;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    background: #aebfd0;
}
.pup-row {
    display: flex;
    gap: 10px;
    max-width: 100%;
}
.pup-row.left { justify-content: flex-start; }
.pup-row.right { justify-content: flex-end; }
.pup-avatar {
    width: 40px; height: 40px;
    border-radius: 6px;
    background-color: #ccc;
    background-size: cover;
    background-position: center;
    flex-shrink: 0;
}
.pup-bubble {
    max-width: 70%;
    padding: 10px 14px;
    border-radius: 6px;
    font-size: 1rem;
    line-height: 1.5;
    position: relative;
    word-wrap: break-word;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
.pup-row.right .pup-bubble {
    background: #ffe033; 
    color: #000;
}
.pup-row.right .pup-bubble::after {
    content: ""; position: absolute; right: -6px; top: 14px;
    border-top: 6px solid transparent; border-bottom: 6px solid transparent;
    border-left: 6px solid #ffe033;
}

.pup-row.left .pup-bubble {
    background: #fff;
    color: #000;
}
.pup-row.left .pup-bubble::before {
    content: ""; position: absolute; left: -6px; top: 14px;
    border-top: 6px solid transparent; border-bottom: 6px solid transparent;
    border-right: 6px solid #fff;
}
.pickup-footer {
    background: #f7f7f7;
    border-top: 1px solid #dcdcdc;
    padding: 10px;
    padding-bottom: max(15px, env(safe-area-inset-bottom));
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.pickup-input-group {
    display: flex;
    gap: 10px;
}

.pup-textarea {
    flex: 1;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 8px;
    font-size: 0.95rem;
    resize: none;
    height: 60px;
    outline: none;
}
#pickup-history-panel {
    z-index: 2100;
    background: #fff;
}
.memo-widget-wide {
    grid-column: span 2; 
    grid-row: span 1;    
    width: 100%;
    height: 100%;
    min-height: 110px;
    background: linear-gradient(135deg, #fff9c4 0%, #fff176 100%); 
    border-radius: 12px;
    padding: 12px;
    box-shadow: 2px 4px 8px rgba(0,0,0,0.1);
    position: relative;
    overflow: hidden;
    cursor: pointer;
    transition: transform 0.2s;
    display: flex;
    flex-direction: column;
}
.memo-widget-wide:active { transform: scale(0.98); }
.memo-widget-wide::before {
    content: ""; position: absolute; top: 0; right: 0;
    border-width: 0 15px 15px 0;
    border-style: solid;
    border-color: rgba(0,0,0,0.1) #fff rgba(0,0,0,0.1) rgba(0,0,0,0.1); 
    box-shadow: -1px 1px 1px rgba(0,0,0,0.1);
}
.memo-preview-text {
    font-family: "Comic Sans MS", cursive, sans-serif;
    color: #5d4037;
    font-size: 0.85rem;
    line-height: 1.4;
    white-space: pre-wrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 4; 
    -webkit-box-orient: vertical;
}
.album-shelf-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 20px;
    padding: 20px;
}
.album-cover-item {
    aspect-ratio: 3/4;
    background: #d7ccc8; 
    background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.1'/%3E%3C/svg%3E");
    border-radius: 4px 10px 10px 4px;
    box-shadow: 
        inset 5px 0 10px rgba(0,0,0,0.1), 
        3px 5px 10px rgba(0,0,0,0.2);
    position: relative;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transition: transform 0.2s;
    border-left: 6px solid #8d6e63; 
    overflow: hidden;
}
.album-cover-item:active { transform: scale(0.96); }
.album-cover-text {
    font-family: "Courier New", monospace;
    font-weight: bold;
    color: #3e2723;
    background: rgba(255,255,255,0.6);
    padding: 5px 10px;
    transform: rotate(-2deg);
    box-shadow: 1px 1px 3px rgba(0,0,0,0.1);
    max-width: 90%;
    text-align: center;
}
.album-photo-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 5px;
    padding: 10px;
}
.photo-thumb {
    aspect-ratio: 1;
    background-color: #eee;
    background-size: cover;
    background-position: center;
    border: 2px solid #fff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    cursor: pointer;
}
#photo-viewer-modal {
    background: rgba(0,0,0,0.85);
    backdrop-filter: blur(5px);
    display: none;
    align-items: center;
    justify-content: center;
    perspective: 1000px; 
}
.held-photo-card {
    background: #fff;
    padding: 15px 15px 50px 15px; 
    box-shadow: 0 20px 50px rgba(0,0,0,0.5);
    transform: rotate(5deg) translateY(100vh); 
    transition: transform 0.6s cubic-bezier(0.19, 1, 0.22, 1);
    max-width: 80%;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
}

.held-photo-card.slide-in {
    transform: rotate(-2deg) translateY(0); 
}
.held-photo-img {
    max-width: 100%;
    max-height: 45vh;
    object-fit: contain;
    background: #eee;
}
.ann-card {
    height: 140px;
    width: 100%;
    border-radius: 12px;
    background-size: cover;
    background-position: center;
    background-color: #eee;
    position: relative;
    overflow: hidden;
    color: white;
    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    padding: 15px;
    text-shadow: 0 2px 4px rgba(0,0,0,0.6);
    transition: transform 0.2s;
}
.ann-card:active { transform: scale(0.98); }
.ann-card::before {
    content: ""; position: absolute; inset: 0;
    background: linear-gradient(to bottom, rgba(0,0,0,0.1), rgba(0,0,0,0.6));
    z-index: 1;
}
.ann-content { position: relative; z-index: 2; }
.ann-days { font-size: 2.5rem; font-weight: bold; line-height: 1; }
.ann-label { font-size: 0.9rem; opacity: 0.9; }
.ann-date-text { font-size: 0.8rem; opacity: 0.8; font-family: monospace; }
.ann-del-btn {
    position: absolute; top: 10px; right: 10px; z-index: 3;
    background: rgba(0,0,0,0.4); border-radius: 50%; width: 24px; height: 24px;
    display: flex; align-items: center; justify-content: center;
    font-size: 1rem; cursor: pointer; color: #fff;
}
.dream-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.9rem;
    color: #333;
}
.dream-table th, .dream-table td {
    border: 1px solid #e1bee7;
    padding: 8px;
    text-align: left;
}
.dream-table th {
    background-color: #f3e5f5;
    color: #4a148c;
    font-weight: bold;
    width: 35%; 
}
.dream-table td {
    background-color: #fff;
}
#dream-card-table-desk {
    width: 100%; height: 100%;
    position: relative;
    overflow-y: auto; 
    overflow-x: hidden;
    background: radial-gradient(circle at center, #4a148c 0%, #1a0528 100%);
    box-shadow: inset 0 0 100px rgba(0,0,0,0.8);
    padding-bottom: 100px; 
}
#dream-card-area {
    width: 100%; height: 100%;
    position: relative;
    transform-style: preserve-3d;
    perspective: 1000px;
}
.hp-app-icon {
    width: 55px; height: 55px;
    border-radius: 12px;
    display: flex; justify-content: center; align-items: center;
    font-size: 1.8rem;
    color: white;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    transition: transform 0.1s;
}
.hp-app-icon:active { transform: scale(0.9); }
.hp-icon-label {
    font-size: 0.7rem; color: white; text-align: center; margin-top: 5px; text-shadow: 0 1px 2px black;
}
.hp-wechat-row {
    display: flex; gap: 10px; background: white; padding: 10px; border-bottom: 1px solid #eee; align-items: center; cursor: pointer;
}
.hp-wechat-avatar {
    width: 40px; height: 40px; border-radius: 4px; background: #ddd; background-size: cover;
}
.hp-chat-bubble {
    padding: 8px 12px; border-radius: 4px; max-width: 80%; margin-bottom: 10px; font-size: 0.95rem;
}
.hp-chat-bubble.me { background: #95ec69; align-self: flex-end; margin-left: auto; }
.hp-chat-bubble.other { background: white; align-self: flex-start; }
.hp-xhs-card {
    background: white; border-radius: 8px; overflow: hidden; margin-bottom: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}
.hp-xhs-img { height: 120px; background: #eee; width: 100%; object-fit: cover; }
.hp-taobao-item {
    display: flex; gap: 10px; background: white; margin-bottom: 10px; padding: 10px; border-radius: 8px;
}
.hp-memo-item {
    background: #fff9c4; padding: 15px; margin-bottom: 10px; border-radius: 5px; font-family: "Comic Sans MS", cursive; border-left: 4px solid #fbc02d;
}
@keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }
.study-task-card {
    background: #fff;
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 12px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.03);
    border: 1px solid #eceff1;
    transition: all 0.2s;
    cursor: pointer;
    position: relative;
    overflow: hidden;
}

.study-task-card:active { transform: scale(0.98); }
.study-task-card.completed {
    background: #f1f8e9; 
    border-color: #c5e1a5;
}

.study-task-header {
    display: flex; 
    align-items: center; 
    justify-content: space-between;
}

.study-day-tag {
    background: #eceff1;
    color: #546e7a;
    font-size: 0.7rem;
    padding: 2px 8px;
    border-radius: 4px;
    font-weight: bold;
}
.study-task-card.completed .study-day-tag {
    background: #c8e6c9;
    color: #2e7d32;
}

.study-task-content {
    margin-top: 8px;
    font-size: 1rem;
    color: #333;
    line-height: 1.5;
}
.study-task-card.completed .study-task-content {
    text-decoration: line-through;
    color: #888;
}
.study-quote-box {
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px dashed #a5d6a7;
    color: #2e7d32;
    font-size: 0.9rem;
    font-family: "KaiTi", "STKaiti", serif; 
    display: none; 
    animation: fadeIn 0.5s;
}
.study-task-card.completed .study-quote-box {
    display: block;
}

.check-icon {
    width: 20px; height: 20px;
    border: 2px solid #cfd8dc;
    border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    color: transparent;
}
.study-task-card.completed .check-icon {
    background: #66bb6a;
    border-color: #66bb6a;
    color: white;
}
.theme-app-item {
    display: flex; flex-direction: column; align-items: center; gap: 5px;
    padding: 10px; background: #fff; border-radius: 8px; border: 1px solid #eee; cursor: pointer;
}
.theme-icon-preview {
    width: 40px; height: 40px; border-radius: 8px; background: #eee; background-size: cover; background-position: center;
}
.stamp-item {
    width: 100%; aspect-ratio: 1; background: #fff; border: 1px dashed #ccc; 
    background-size: contain; background-repeat: no-repeat; background-position: center;
    position: relative;
}
.stamp-del {
    position: absolute; top: -5px; right: -5px; width: 18px; height: 18px; 
    background: red; color: white; border-radius: 50%; font-size: 10px; 
    display: flex; align-items: center; justify-content: center; cursor: pointer;
}
.reply-stamp-gift {
    position: absolute;
    width: 130px; 
    height: 130px;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
    mix-blend-mode: normal; 
    filter: drop-shadow(0 4px 6px rgba(0,0,0,0.15));   
    cursor: pointer;
    z-index: 20;    
    transition: transform 0.1s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.reply-stamp-gift:active {
    transform: translateX(-50%) scale(0.92) !important;
    filter: brightness(0.9);
}
.custom-font-applied { font-family: inherit !important; }
#theme-modal .modal-body {
    display: flex;
    flex-direction: column;
    padding: 0;
    background: #f2f4f6;
}
#theme-modal .modal-body > div:first-child {
    flex-shrink: 0; 
    padding: 15px 15px 5px 15px;
    background: #fff;
    box-shadow: 0 2px 10px rgba(0,0,0,0.03);
    z-index: 10;
}
.theme-tab-content {
    flex: 1;
    overflow-y: auto;
    padding: 20px 15px;
    padding-bottom: 100px; 
}
#app-icon-list {
    padding-top: 5px; 
}
.font-setting-item {
    background: #fff;
    padding: 15px;
    border-radius: 12px;
    margin-bottom: 10px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.02);
    border: 1px solid #eee;
}
.font-setting-item label {
    font-weight: bold;
    color: #555;
    margin-bottom: 8px;
    display: block;
}
.game-console-widget {
    grid-column: span 4;
    grid-row: span 2;  
    width: 100%;
    height: 100%;
    min-height: 180px;
    background: #2d3436; 
    border-radius: 20px;
    position: relative;
    box-shadow: 0 10px 20px rgba(0,0,0,0.4), inset 0 -5px 10px rgba(0,0,0,0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    border: 4px solid #444;
}
.gc-dpad {
    position: absolute; left: 15px; top: 50%; transform: translateY(-50%);
    width: 60px; height: 60px;
    background: radial-gradient(#444, #222);
    clip-path: polygon(33% 0, 66% 0, 66% 33%, 100% 33%, 100% 66%, 66% 66%, 66% 100%, 33% 100%, 33% 66%, 0 66%, 0 33%, 33% 33%);
    box-shadow: inset 2px 2px 5px rgba(255,255,255,0.1);
}
.gc-btns {
    position: absolute; right: 15px; top: 50%; transform: translateY(-50%);
    width: 60px; height: 60px;
    display: grid; grid-template-columns: 1fr 1fr; gap: 5px;
}
.gc-btn {
    width: 25px; height: 25px; border-radius: 50%;
    background: #e74c3c; box-shadow: 0 3px 0 #c0392b;
}
.gc-btn:nth-child(2) { margin-top: 10px; background: #f1c40f; box-shadow: 0 3px 0 #f39c12; }
.gc-screen-area {
    width: 60%; height: 80%;
    background: #000;
    border-radius: 4px;
    border: 4px solid #111;
    overflow: hidden;
    position: relative;
    display: flex; align-items: center; justify-content: center;
}
.gc-screen-img {
    width: 100%; height: 100%; object-fit: cover; opacity: 0.8;
}
.gc-scanline {
    position: absolute; inset: 0;
    background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.3) 3px);
    pointer-events: none;
}
#game-modal {
    background: #000;
    perspective: 1000px;
}
.game-interface {
    width: 100%; height: 100%;
    background-size: cover; background-position: center;
    position: relative;
    overflow: hidden;
    font-family: "Noto Serif SC", serif;
}
.game-stats-panel {
    position: absolute; top: 70px; left: 10px;
    background: rgba(0,0,0,0.6);
    padding: 8px; border-radius: 8px; border: 2px solid #fff;
    display: flex; gap: 10px; align-items: center;
    z-index: 50;
    backdrop-filter: blur(4px);
}
.game-avatar {
    width: 50px; height: 50px; border-radius: 4px;
    background: #ccc; background-size: cover; border: 1px solid #fff;
}
.game-bars { display: flex; flex-direction: column; gap: 5px; width: 120px; }
.g-bar-row { display: flex; align-items: center; gap: 5px; font-size: 0.7rem; color: white; }
.g-bar-bg { flex: 1; height: 6px; background: #333; border-radius: 3px; overflow: hidden; border: 1px solid #666; }
.g-bar-fill { height: 100%; transition: width 0.5s; }
.g-val { width: 25px; text-align: right; }
.half-body {
    position: absolute; bottom: 0;
    height: 70%; 
    width: auto; max-width: 60%;
    object-fit: contain;
    transition: opacity 0.3s, transform 0.3s;
    filter: drop-shadow(0 0 10px rgba(0,0,0,0.5));
    z-index: 10;
}
.hb-char { left: -50px; transform: translateX(0); }
.hb-user { right: -50px; transform: translateX(0); }
.hb-hidden { opacity: 0; transform: translateY(20px); pointer-events: none; }
.rpg-dialog-box {
    position: absolute; bottom: 20px; left: 20px; right: 20px;
    min-height: 120px;
    background: rgba(0, 0, 0, 0.85);
    border: 3px solid #fff;
    border-radius: 8px;
    padding: 15px;
    z-index: 100; 
    color: #fff;
    box-shadow: 0 5px 20px rgba(0,0,0,0.8);
    display: flex; flex-direction: column;
}
.rpg-name {
    color: #f1c40f; font-weight: bold; font-size: 1.1rem; margin-bottom: 5px;
    text-shadow: 1px 1px 0 #000;
}
.rpg-text {
    font-size: 1rem; line-height: 1.5; text-align: justify; flex: 1;
}
.rpg-cursor {
    display: inline-block; width: 8px; height: 15px; background: #fff;
    animation: blink 1s infinite; vertical-align: middle;
}
@keyframes blink { 50% { opacity: 0; } }
.game-input-overlay {
    position: absolute; bottom: 0; left: 0; width: 100%;
    background: rgba(0,0,0,0.9); padding: 15px;
    z-index: 200; display: none; 
    flex-direction: column; gap: 10px;
}
.game-input-row { display: flex; gap: 10px; }
.game-input {
    flex: 1; background: #222; border: 1px solid #555; color: white;
    padding: 10px; border-radius: 4px; outline: none;
}
.game-history-btn {
    position: absolute; top: 70px; right: 10px;
    background: rgba(255,255,255,0.2); border: 1px solid #fff;
    color: #fff; padding: 5px 10px; border-radius: 4px;
    z-index: 60; cursor: pointer; font-size: 0.8rem;
}
.card-meaning-display {
    font-size: 0.7rem; color: #aaa; margin-top: 5px; font-style: italic; border-top: 1px dashed #555; padding-top: 3px;
}
#game-card-table-desk {
    width: 100%; 
    height: 100%;
    background: radial-gradient(circle at center, #2d3436 0%, #000000 100%);
    position: relative;
    overflow-y: auto; 
    overflow-x: hidden;
    box-shadow: inset 0 0 100px rgba(0,0,0,0.8);
    padding-bottom: 100px;
}
#game-card-area {
    width: 100%; 
    height: 100%;
    position: relative;
    transform-style: preserve-3d;
    perspective: 1000px;
}
.sys-toast-container {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%) translateY(-100px); 
    z-index: 10000;
    display: flex;
    flex-direction: column;
    gap: 10px;
    transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    pointer-events: none; 
}
.sys-toast-container.show {
    transform: translateX(-50%) translateY(0);
}

.sys-toast-card {
    background: rgba(255, 255, 255, 0.85);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid rgba(255, 255, 255, 0.6);
    box-shadow: 0 10px 30px rgba(0,0,0,0.15);
    border-radius: 20px;
    padding: 12px 20px;
    display: flex;
    align-items: center;
    gap: 12px;
    min-width: 300px;
    max-width: 90vw;
    pointer-events: auto;
    cursor: pointer;
    animation: toastPop 0.4s forwards;
}

@keyframes toastPop {
    0% { opacity: 0; transform: scale(0.9); }
    100% { opacity: 1; transform: scale(1); }
}

.toast-icon { font-size: 1.5rem; }
.toast-body { flex: 1; display: flex; flex-direction: column; }
.toast-title { font-size: 0.85rem; font-weight: bold; color: #333; }
.toast-msg { font-size: 0.75rem; color: #666; margin-top: 2px; }
.bottle-shape {
    width: 32px !important;
    height: 50px !important;
    background-color: #e0e0e0;
    border: 1px solid rgba(0,0,0,0.1);
}
.b-oil .bottle-shape { background-color: #fdd835 !important; }
.b-dark .bottle-shape { background-color: #5d4037 !important; }
.b-black .bottle-shape { background-color: #212121 !important; }
.b-white .bottle-shape { background-color: #ffffff !important; }
.b-wine .bottle-shape { background-color: #ffca28 !important; }
    </style>
</head>
<body>
<div id="camera-modal" class="modal-overlay" style="padding:0;">
    <div id="camera-ui">
        <div style="padding:10px; display:flex; justify-content:space-between; color:white; background:#111; align-items:center;">
            <span>复古暗房</span>
            <div id="sticker-ops" style="display:none; gap:10px;">
                <button class="m-btn small" onclick="controlSticker('scale', 1.1)">➕</button>
                <button class="m-btn small" onclick="controlSticker('scale', 0.9)">➖</button>
                <button class="m-btn small" style="background:red; color:white;" onclick="controlSticker('del')">🗑️</button>
            </div>
            <button onclick="closeCamera()" style="background:none;border:none;color:white;font-size:1.2rem;">×</button>
        </div>
        <div id="canvas-area">
            <canvas id="editor-canvas"></canvas>
        </div>
        <div class="cam-tools">
            <button class="m-btn small" onclick="document.getElementById('upload-bg').click()">📷 底图</button>
            <button class="m-btn small" onclick="document.getElementById('upload-sticker').click()">😊 贴纸</button>
            <select id="frame-select" class="m-btn small" onchange="handleFrameChange(this.value)" style="background:#ddd; color:#333; max-width: 100px;">
                <option value="black" selected>⬛ 默认黑</option>
                <option value="polaroid">⬜ 拍立得</option>
                <option value="custom">🖼️ 自定义</option>
                <option value="none">🚫 无框</option>
            </select>

            <button class="m-btn primary small" onclick="saveCanvasPhoto()">💾 保存</button>
        </div>
    </div>
    <input type="file" id="upload-bg" accept="image/*" style="display:none" onchange="handleBgUpload(this)">
    <input type="file" id="upload-sticker" accept="image/*" style="display:none" onchange="handleCamStickerUpload(this)">
    <input type="file" id="upload-frame-custom" accept="image/*" style="display:none" onchange="handleCustomFrameUpload(this)">
</div>
    <div id="screen">
        <div id="pages-wrapper">
            <!-- Page 1 -->
            <div class="page" id="page1">
                <div class="header-info">
                    <div class="time-widget" id="clock">12:00</div>
                    <div class="date-widget" id="date">JAN 24</div>
                </div>
                <div class="tv-container">
                    <div class="tv-case">
                        <div class="add-btn-trigger" onclick="document.getElementById('tv-file-input').click()"></div>
                        <div class="tv-bezel-wrapper">
                            <div class="tv-screen-frame">
                                <div class="tv-screen">
                                    <div class="crt-scanlines"></div>
                                    <span class="tv-placeholder">无信号<br>点击换图</span>
                                    <img id="tv-content" class="tv-content" src="" style="display:none;">
                                </div>
                            </div>
                        </div>
                        <div class="tv-control-panel">
                            <div class="tv-logo-badge">Zenith</div>
                            <div class="tv-knobs">
                                <div class="knob" style="transform: rotate(45deg);"></div>
                                <div class="knob" style="transform: rotate(-20deg);"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <input type="file" id="tv-file-input" accept="image/*">

                <div class="middle-grid">
                    <div class="left-apps-grid">
                        <div class="app-item" onclick="openSettings()"><div class="app-icon" style="background:#7d8c7c">⚙️</div><span class="app-name">设置</span></div>
                        <div class="app-item" onclick="openWorldBook()"><div class="app-icon" style="background:#d4a5a5">📖</div><span class="app-name">世界书</span></div>
                        <div class="app-item" onclick="openThesaurus()"><div class="app-icon" style="background:var(--morandi-green)">🧾</div><span class="app-name">词库</span></div>
                       <div class="app-item" onclick="openCamera()"><div class="app-icon" style="background:#5e6d79;">📷</div><span class="app-name">相机</span></div> 
                        <div class="app-item" onclick="openFileApp()"><div class="app-icon" style="background:#c9bba0">📂</div><span class="app-name">文件</span></div>
                       <div class="app-item" onclick="openFinanceApp()">
    <div class="app-icon" style="background:#6b705c">💰</div>
    <span class="app-name">记账</span>
</div>
                    </div>
<div class="newspaper-wrap" ondblclick="initCardTable()">
    <div class="news-header-section">
        <div class="news-brand">The Daily Post</div>
        <div class="news-meta-bar">
            <span>Morning Ed.</span>
            <span>Est. 1923</span>
            <span>Vol. 402</span>
        </div>
    </div>
    <div class="news-content">
        <div class="news-headline">MYSTIC ECHOES</div>
        <div class="news-img-halftone"></div>
        <div class="news-text-columns">
            <p>Strange energies detected in the ether today. Experts baffled by sudden surge.</p>
            <p>Cards reveal secrets hidden beneath the surface of reality.</p>
        </div>
    </div>
</div>
                </div>

<div class="weather-glass" onclick="initRealWeather()">
                    <div class="w-left">
                        <h2 id="real-temp">--°</h2>
                        <p id="real-desc">定位中...</p>
                    </div>
                    <div class="w-icon" id="real-icon">⌛</div>
                </div>
            </div>
            
            <div class="page" id="page2">
<div class="page-2-grid">
    <div class="fridge-item-large" onclick="openFridgeApp()" style="grid-row: span 2;">
        <div class="fridge-handle"></div>
        <div class="fridge-sticker"></div>
    </div>
<div class="app-item" onclick="openStudyApp()">
        <div class="app-icon" style="background:#546e7a; color:#fff; font-size:1.6rem; border:2px solid #cfd8dc; box-shadow:0 2px 5px rgba(0,0,0,0.2);">📅</div>
        <span class="app-name">学习计划</span>
    </div>
    <!-- 2. 小剧场 -->
    <div class="app-item" onclick="openTheaterApp()">
        <div class="app-icon" style="background:#8e44ad; color:#fff; font-size:1.8rem;">🎭</div>
        <span class="app-name">小剧场</span>
    </div>
    <div class="app-item" onclick="openPickupApp()">
        <div class="app-icon" style="background:#f1c40f; color:#fff; font-size:1.6rem; border:2px solid #000;">📱</div>
        <span class="app-name">捡手机</span>
    </div>
    <div class="app-item" onclick="openPeriodApp()">
        <div class="app-icon" style="background:#f48fb1; color:#fff; font-size:1.6rem;">🌺</div>
        <span class="app-name">经期</span>
    </div>
    <div class="app-item" onclick="openForumApp()">
        <div class="app-icon" style="background:#00d2d3; color:#fff; font-size:1.6rem;">💬</div>
        <span class="app-name">论坛体</span>
    </div>
    <div class="app-item" onclick="openAlbumApp()">
        <div class="app-icon" style="background:#8d6e63; color:#fff; font-size:1.6rem; border:1px solid #d7ccc8;">🖼️</div>
        <span class="app-name">相册</span>
    </div>
    <div class="app-item" onclick="openAnniversaryApp()">
        <div class="app-icon" style="background:#cba8a8; color:#fff; font-size:1.6rem; border:1px solid #e6dada;">📅</div>
        <span class="app-name">纪念日</span>
    </div>
    <!-- 修改：日记组件 (已修复) -->
<div id="diary-widget" class="memo-widget-wide" onclick="openDiaryApp()" style="grid-column: span 2; grid-row: span 2; background: linear-gradient(135deg, #fdfbf7 0%, #ebedee 100%); border: 1px solid #ccc;">
    <div style="font-size:0.7rem; color:#888; margin-bottom:4px; font-weight:bold; letter-spacing:1px;">DIARY</div>
    <div id="desktop-diary-preview" style="font-family: 'Georgia', serif; font-size: 0.75rem; color:#555; line-height:1.4; overflow:hidden; display:-webkit-box; -webkit-line-clamp: 5; -webkit-box-orient: vertical;">
        点击生成今日日记...
    </div>
    <!-- 装饰用的日记本绑带 -->
    <div style="position:absolute; right:20px; top:0; bottom:0; width:15px; background:rgba(0,0,0,0.05); border-left:1px dashed #aaa; border-right:1px dashed #aaa;"></div>
</div>
    <div class="app-item" onclick="openDreamApp()">
        <div class="app-icon" style="background: linear-gradient(135deg, #e0c3fc 0%, #8ec5fc 100%); color:#fff; font-size:1.6rem; border:1px solid #fff;">🦄</div>
        <span class="app-name">梦</span>
    </div>
    <div class="app-item" onclick="openHisPhoneApp()">
        <div class="app-icon" style="background: #2d3436; color: #fff; font-size: 1.6rem; border: 1px solid #636e72; box-shadow: 0 0 10px rgba(0,0,0,0.5);">📱</div>
        <span class="app-name">ta的手机</span>
    </div>
    <div class="app-item" onclick="openThemeApp()">
        <div class="app-icon" style="background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 99%); color:#fff; font-size:1.6rem; border:1px solid #fff;">🎨</div>
        <span class="app-name">美化</span>
    </div>
<div class="game-console-widget" onclick="openGameApp()">
    <div class="gc-dpad"></div>
    <div class="gc-screen-area">
        <div class="gc-scanline"></div>
        <img id="widget-game-bg" class="gc-screen-img" src="" style="display:none"> 
        <div class="tv-placeholder" style="color:#fff; text-shadow:0 0 5px #0f0;">PRESS START</div>
    </div>
    <div class="gc-btns"><div class="gc-btn"></div><div class="gc-btn"></div></div>
</div>
</div>
    </div> 
            <!-- Page 3 -->

<div class="page" id="page3">
    <div class="page-2-grid">
        <!-- 原有的老福特 -->
        <div class="app-item" onclick="openLofterApp()">
            <div class="app-icon" style="background:#2c6e49; color:#fff; font-size:1.6rem; font-family:serif; font-weight:bold;">Lf</div>
            <span class="app-name">老福特</span>
        </div>
        
        <!-- 🔥 新增：关于痛苦 APP -->
        <div class="app-item" onclick="openPainApp()">
            <div class="app-icon" style="background:#636e72; color:#fff; font-size:1.6rem; border:1px solid #b2bec3;">💊</div>
            <span class="app-name">关于痛苦</span>
        </div>
        <!-- 新增：宠物日记 APP -->
        <div class="app-item" onclick="openPetDiaryApp()">
            <div class="app-icon" style="background:#ff9f43; color:#fff; font-size:1.6rem; border:2px solid #fff; box-shadow: 0 4px 10px rgba(255, 159, 67, 0.4);">🐾</div>
            <span class="app-name">宠物日记</span>
        </div>

<div class="app-item" onclick="openGashaponApp()">
    <div class="app-icon" style="background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%); color:#fff; font-size:1.6rem; border:2px solid #fff; box-shadow: 0 4px 10px rgba(255, 154, 158, 0.5);">🍬</div>
    <span class="app-name">平行扭蛋</span>
</div>
<div class="app-item" onclick="openShadowApp()">
    <div class="app-icon" style="background:#2d3436; color:#d63031; font-size:1.6rem; border:2px solid #636e72; box-shadow: 0 0 10px rgba(0,0,0,0.8);">😈</div>
    <span class="app-name">阴暗面</span>
</div>
<div class="app-item" onclick="openSummaryApp()">
    <div class="app-icon" style="background:#607d8b; color:#fff; font-size:1.6rem; border:2px solid #fff; box-shadow: 0 4px 10px rgba(96, 125, 139, 0.4);">📝</div>
    <span class="app-name">学习总结</span>
</div>

<!-- === 新增：RPG 像素生活组件 === -->
<div class="game-console-widget" onclick="openRpgApp()" style="grid-column: span 4; grid-row: span 2; background: #2d3436; border:4px solid #57606f;">
    <div class="gc-dpad" style="left:10px; width:50px; height:50px;"></div>
    <div class="gc-screen-area" style="width: 65%; height: 85%; border: 2px solid #111;">
        <!-- 这里放你提供的显示屏背景图 -->
        <img src="https://i.postimg.cc/ZqXkMnTj/IMG_1126.png" style="width:100%; height:100%; object-fit:cover;">
        <div style="position:absolute; bottom:10px; left:0; width:100%; text-align:center; color:#0f0; font-family:'Courier New'; font-weight:bold; font-size:0.8rem; text-shadow:0 0 2px #000; animation: blink 1s infinite;">CLICK START</div>
    </div>
    <div class="gc-btns" style="right:10px; width:50px; height:50px;">
        <div class="gc-btn" style="background:#ff7675;"></div>
        <div class="gc-btn" style="background:#74b9ff;"></div>
    </div>
</div>
    </div>
</div>
<!-- Page 4: 宠物陪伴系统 -->
<div class="page" id="page4" style="background:none; overflow:hidden; position:relative;">
    <!-- 动态背景层 -->
    <div id="pet-bg-layer" style="position:absolute; inset:0; z-index:0; background-size:cover; background-position:center;"></div>
    
    <!-- 装饰物层 -->
    <div id="pet-decor-layer" style="position:absolute; inset:0; z-index:1; pointer-events:none;"></div>

    <!-- 宠物层 (会在JS中动态控制位置) -->
    <div id="pet-sprite" onclick="interactWithPet()" style="position:absolute; bottom:30%; left:50%; width:120px; height:120px; z-index:10; transition: transform 0.5s, left 2s linear; cursor:pointer; background-size:contain; background-repeat:no-repeat; background-position:center;"></div>

    <!-- 离家出走时的提示 -->
    <div id="pet-runaway-msg" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:20; background:rgba(0,0,0,0.8); color:white; padding:20px; border-radius:10px; text-align:center;">
        <h3>😿 宠物离家出走了...</h3>
        <p>心情值归零，它伤心地离开了。</p>
        <button class="m-btn primary" onclick="retrievePet()">支付 15 积分找回</button>
    </div>

    <!-- UI 图标 -->
    <!-- 右上角：设置 -->
    <img src="https://i.postimg.cc/QxrKcChy/%E6%9C%AA%E5%91%BD%E5%90%8D%E4%BD%9C%E5%93%81.png" onclick="openPetSettings()" style="position:absolute; top:calc(20px + env(safe-area-inset-top)); right:20px; width:40px; height:40px; z-index:100; cursor:pointer;">
    
    <!-- 左下角：商店 -->
    <img src="https://i.postimg.cc/nct9qrp2/%E6%9C%AA%E5%91%BD%E5%90%8D%E4%BD%9C%E5%93%81.png" onclick="openPetShop()" style="position:absolute; bottom:30px; left:20px; width:50px; height:50px; z-index:100; cursor:pointer;">
    
    <!-- 右下角：背包 -->
    <img src="https://i.postimg.cc/9Fdp3sJ8/wei-ming-ming-zuo-pin.png" onclick="openPetBag()" style="position:absolute; bottom:30px; right:20px; width:50px; height:50px; z-index:100; cursor:pointer;">
</div>
</div>
        </div>
        
        <div class="dock-bar">
    <div class="app-item" onclick="openFan()" style="margin-bottom:0">
        <div class="app-icon" style="background:#000; border:2px solid #333; box-shadow:0 0 5px #0f0;">📟</div>
    </div>
    <div class="app-item" onclick="openChatApp()" style="margin-bottom:0">
        <div class="app-icon" style="background:#06c755; box-shadow:none; font-size: 1.4rem;">💬</div>
    </div>
    <div class="app-item" onclick="openTarotApp()" style="margin-bottom:0">
        <div class="app-icon" style="background:#2c3e50; color:#a29bfe; box-shadow:none; border:1px solid rgba(255,255,255,0.3);">🔮</div>
    </div>

    <!-- 👇 修改点：给信件加上 app-item 外壳 👇 -->
    <div class="app-item" onclick="openLetterApp()" style="margin-bottom:0">
        <div class="app-icon" style="background:#fdf6e3; color:#555; border:1px solid #ccc; box-shadow:none;">✉️</div>
        </div>
    </div>
<div id="settings-modal" class="modal-overlay">
    <div class="modal-header"><span>API 配置中心</span><button class="close-btn" onclick="closeSettings()">×</button></div>
    <div class="modal-body">
        <div class="morandi-card">
            <h3>连接配置</h3>
<div class="morandi-card" style="border-left: 4px solid #06c755;">
    <h3>🔔 通知权限</h3>
    <p style="font-size:0.8rem; color:#666; margin-bottom:10px;">
        允许发送系统通知，以便在退出 App 后接收消息和生成结果。
        <br>(iOS需添加到主屏幕才能生效)
    </p>
    <button class="m-btn primary" onclick="NotificationManager.requestPermission()" style="background:#06c755;">开启系统通知权限</button>
</div>
<div class="morandi-card" style="border:1px solid #7d8c7c;">
    <h3 style="color:#2c3e50;">💾 全局数据备份</h3>
    <p style="font-size:0.8rem; color:#666; margin-bottom:10px;">
        备份所有文字数据（世界书、聊天记录、纪念日、所有App记录）。<br>
        <span style="color:#d81b60;">注意：不包含文件的数据。</span>
    </p>
    <div style="display:flex; gap:10px;">
        <button class="m-btn secondary" onclick="exportFullBackup()">📤 导出备份 (.json)</button>
        <button class="m-btn secondary" onclick="document.getElementById('restore-file-input').click()">📥 导入恢复</button>
        <input type="file" id="restore-file-input" accept=".json" style="display:none" onchange="importFullRestore(this)">
    </div>
</div>
            <div class="input-group"><label>API Address</label><input type="text" id="api-url" placeholder="https://api.openai.com/v1" oninput="autoSaveApiSettings()"></div>
           <div class="input-group"><label>API Key</label><input type="password" id="api-key" placeholder="sk-..." oninput="autoSaveApiSettings()"></div>
            
            <div class="input-group"><label>模型</label><select id="model-select" onchange="autoSaveApiSettings()"><option value="" disabled selected>请拉取...</option></select></div>
            <div class="input-group">
                <label style="display:flex; justify-content:space-between;"><span>温度: <span id="temp-display">0.7</span></span></label>
                <input type="range" id="api-temp" min="0" max="2" step="0.1" value="0.7" oninput="document.getElementById('temp-display').innerText = this.value; autoSaveApiSettings()">
            </div>
            
            <div class="action-row" style="display:flex; gap:10px; margin-top:10px;">
                <button class="m-btn secondary" onclick="fetchModels()">🔄 拉取</button>
                <button class="m-btn primary" onclick="saveCurrentProfile()">💾 另存为方案</button>
            </div>
        </div>
        <div class="morandi-card"><h3>已保存方案</h3><div id="profile-list"></div></div>
    </div>
</div>
    <div id="fan-modal" class="modal-overlay">
        <button class="close-btn" style="position:absolute; top:50px; right:20px; color:#fff;" onclick="closeFan()">×</button>
        <div class="elec-screen-container">
            <div class="elec-screen">
                <div class="scanline-anim"></div>
                <div class="elec-text" id="fan-display-text"></div>
            </div>
            <div class="elec-deco-bar">
                <div class="deco-dot active"></div>
                <div style="color:#555; font-size:0.5rem; letter-spacing:2px;">SYS.OP.READY</div>
                <div class="deco-dot"></div>
            </div>
        </div>
    </div>
    <div id="file-modal" class="modal-overlay">
        <div class="modal-header"><span>文件管理</span><button class="close-btn" onclick="document.getElementById('file-modal').style.display='none'">×</button></div>
        <div class="modal-body">
            <div class="morandi-card">
                <h3>📁 通用导入</h3>
                <p style="font-size:0.8rem; color:#888;">从手机文件导入图片或文档</p>
                <input type="file" id="file-generic-input" class="hidden-file-input">
                <button class="m-btn secondary" onclick="document.getElementById('file-generic-input').click()">选择文件...</button>
            </div>

            <div class="morandi-card">
                <h3>🔮 塔罗牌库 (0-77)</h3>
                <p style="font-size:0.8rem; color:#888;">请选择78张JPEG图片 (文件名需包含数字0-77)</p>
                <input type="file" id="file-tarot-input" class="hidden-file-input" multiple accept="image/jpeg, image/jpg">
                <button class="m-btn primary" onclick="document.getElementById('file-tarot-input').click()">批量上传塔罗牌</button>
                <div id="tarot-status" style="margin-top:10px; font-size:0.8rem; color:#666;"></div>
            </div>

            <div class="morandi-card">
                <h3>⚜️ 雷诺曼牌库 (1-36)</h3>
                <p style="font-size:0.8rem; color:#888;">请选择36张JPEG图片 (文件名需包含数字1-36)</p>
                <input type="file" id="file-lenormand-input" class="hidden-file-input" multiple accept="image/jpeg, image/jpg">
                <button class="m-btn primary" onclick="document.getElementById('file-lenormand-input').click()">批量上传雷诺曼</button>
                <div id="lenormand-status" style="margin-top:10px; font-size:0.8rem; color:#666;"></div>
            </div>
        </div>
    </div>
    <div id="chat-modal" class="modal-overlay" style="display:none;">
        <div class="chat-header">
            <button class="m-btn small" onclick="closeChatApp()">🔙</button>
            <div class="chat-header-center">
                <input type="text" id="chat-title-input" class="chat-title-input" value="私密聊天" onblur="saveLineTitle()">
                <div class="chat-status-toggle" id="chat-status-toggle" onclick="toggleOnlineStatus()">
                    <div class="status-dot"></div>
                    <span id="chat-status-text">休息</span>
                </div>
            </div>
            <button class="m-btn small" onclick="toggleChatSettings()">⚙️</button>
        </div>
        <div class="chat-body" id="chat-history"></div>
        <div id="sticker-modal" style="display:none;">
            <div class="sticker-grid" id="sticker-grid-container"></div>
            <div class="sticker-toolbar">
                <input type="file" id="sticker-upload-input" multiple accept="image/*" style="display:none" onchange="handleStickerUpload(this)">
                <div style="display:flex; gap:10px">
                    <button class="m-btn small" onclick="document.getElementById('sticker-upload-input').click()">➕ 从相册导入</button>
                    <button class="m-btn small" id="toggle-del-btn" onclick="toggleStickerDeleteMode()" style="background:#e8d7d7; color:red;">🗑️ 删除模式</button>
                </div>
                <button class="m-btn small" onclick="document.getElementById('sticker-modal').style.display='none'">🔽</button>
            </div>
        </div>
        <div class="chat-footer" id="chat-footer-bar">
            <div id="normal-footer-content" style="width:100%; display:flex; flex-direction:column;">
                
                <div id="quote-preview-bar" class="quote-preview-bar">
                    <div style="display:flex; flex-direction:column; overflow:hidden;">
                        <span style="font-size:0.7rem; color:#06c755; font-weight:bold;">回复：</span>
                        <span id="quote-content-text" class="quote-text-preview"></span>
                    </div>
                    <div class="quote-close-btn" onclick="cancelQuote()">×</div>
                </div>
                <div style="display:flex; align-items:center; gap:8px; width:100%;">
                    <input type="file" id="chat-img-input" style="display:none" accept="image/*" onchange="handleChatImageUpload(this)">
                    <button class="chat-func-btn" onclick="document.getElementById('chat-img-input').click()">ෆ</button>
                    <button class="chat-func-btn" onclick="toggleStickers()">•ᴗ•</button>
                    <input type="text" id="chat-input-text" placeholder="Aa" onkeydown="if(event.key==='Enter') sendUserMessage()">
                    <button class="chat-send-btn" onclick="sendUserMessage()">♡</button>
                </div>
            </div>
            <div id="delete-footer-content" class="delete-toolbar">
                <button class="m-btn small" onclick="quitDeleteMode()" style="background:#ccc;">取消</button>
                <span id="delete-count-text">已选 0 条</span>
                <button class="m-btn small" onclick="confirmDeleteMessages()" style="background:#ff4444; color:white;">删除</button>
            </div>
        </div>
        <div class="chat-settings-panel" id="chat-settings">
            <h3>聊天设置</h3>
            <div style="display:flex; gap:10px; margin-bottom:15px">
                <button class="m-btn small" onclick="toggleChatSettings()" style="background:#e8d7d7;">关闭面板</button>
                <button class="m-btn small" onclick="clearChatHistory()" style="background:#d4a5a5; color:white;">清空记录</button>
            </div>
             <div class="input-group">
                <label>聊天背景图</label>
                <input type="text" id="set-chat-bg" placeholder="输入链接..." onblur="saveChatSettings()">
                <input type="file" onchange="handleFileToInput(this, 'bg')">
            </div>
            <h4 style="margin-top:15px">👋 拍一拍配置</h4>
            <div class="input-group">
                <label>拍一拍状态库</label>
                <textarea id="set-nudge-list" class="editor-textarea" style="height:80px" placeholder="一行一个" onblur="saveChatSettings()"></textarea>
            </div>
            <h4 style="margin-top:15px">🎭 头像设置</h4>
            <div class="input-group"><label>我的头像</label><input type="file" onchange="handleFileToInput(this, 'myAvatar')"></div>
            <div class="input-group"><label>我的头像框 (URL)</label><input type="text" id="set-my-frame" onblur="saveChatSettings()"></div>
            <div class="input-group"><label>对方头像</label><input type="file" onchange="handleFileToInput(this, 'botAvatar')"></div>
            <div class="input-group"><label>对方头像框 (URL)</label><input type="text" id="set-bot-frame" onblur="saveChatSettings()"></div>
            <h4 style="margin-top:15px">💬 气泡样式 (支持 CSS)</h4>
            <div class="input-group"><label>我的气泡 CSS (支持 } .class::before { )</label><textarea id="set-my-css" class="editor-textarea" style="height:80px" onblur="saveChatSettings()"></textarea></div>
            <div class="input-group"><label>对方气泡 CSS (支持 } .class::before { )</label><textarea id="set-bot-css" class="editor-textarea" style="height:80px" onblur="saveChatSettings()"></textarea></div>
            <h4 style="margin-top:15px">⏱️ 回复逻辑</h4>
            <div class="range-group"><label>延迟(秒)</label><input type="number" id="set-delay-min" onchange="saveChatSettings()"> - <input type="number" id="set-delay-max" onchange="saveChatSettings()"></div>
            <div class="range-group"><label>条数</label><input type="number" id="set-count-min" onchange="saveChatSettings()"> - <input type="number" id="set-count-max" onchange="saveChatSettings()"></div>
            <div class="range-group"><label>被动间隔(分)</label><input type="number" id="set-passive-min" onchange="saveChatSettings()"> - <input type="number" id="set-passive-max" onchange="saveChatSettings()"></div>
        </div>
    </div>
    <div id="thesaurus-modal" class="modal-overlay receipt-modal">
        <div class="modal-header" style="background:transparent; color:#555; box-shadow:none;">
            <span>&nbsp;</span><button class="close-btn" onclick="closeThesaurus()">×</button>
        </div>
        <div class="modal-body" style="padding: 0 20px 20px 20px;">
            <div class="receipt-card">
                <div class="receipt-header">
                    <div class="receipt-title">WORD BANK</div>
                    <div class="receipt-meta" id="receipt-date">DATE: 2026-01-24</div>
                </div>
                <div class="receipt-tabs">
                    <div class="r-tab active" onclick="switchThesaurusTab('reply')" id="tab-reply">回复</div>
                    <div class="r-tab" onclick="switchThesaurusTab('note')" id="tab-note">纸条</div>
                    <div class="r-tab" onclick="switchThesaurusTab('expense')" id="tab-expense">支出</div>
                    <div class="r-tab" onclick="switchThesaurusTab('income')" id="tab-income">收入</div>
                </div>
                <div class="receipt-body" id="thesaurus-list"></div>
                <div style="padding:15px; border-top:2px dashed #ccc; display:flex; gap:10px; background:#fcfcfc;">
                    <button class="m-btn small" onclick="addWord()" style="background:#555; color:#fff;">+ 行</button>
                    <button class="m-btn small" onclick="exportWords()" style="background:#ccc;">导出</button>
                    <button class="m-btn small" onclick="importWords()" style="background:#ccc;">导入</button>
                </div>
                <input type="file" id="txt-import-input" class="hidden-file-input" accept=".txt">
            </div>
        </div>
    </div>
    <div id="wb-modal" class="modal-overlay">
        <div class="modal-header"><span>世界书</span><button class="close-btn" onclick="closeWorldBook()">×</button></div>
        <div class="modal-body" style="padding: 10px; position: relative;">
            <div id="wb-container">
                <div class="wb-sidebar" id="wb-sidebar"></div>
                <div class="wb-main">
                    <div class="wb-toolbar">
                        <input type="file" id="any-import-input" class="hidden-file-input" accept=".json,.txt">
                        <button class="m-btn small" style="background:#9fb1bc;" onclick="importAny()">📂 导入</button>
                        <button class="m-btn small" style="background:#8fbbbd;" onclick="exportCategory()">💾 导出TXT</button>
                        <button class="m-btn small" onclick="addEntry()">+ 新增</button>
                    </div>
                    <div class="wb-list" id="wb-list"></div>
                </div>
                <div id="wb-editor-overlay">
                    <div class="editor-header">
                        <button class="m-btn small" style="background:#e8d7d7; color:#7a6363" onclick="closeEntryEditor()">取消</button>
                        <span style="font-weight:bold; color:#6b5858">编辑</span>
                        <button class="m-btn small" onclick="saveEntryEditor()">保存</button>
                    </div>
                    <div class="editor-body">
                        <div class="input-group"><label>标题</label><input type="text" id="edit-title"></div>
                        <div class="input-group" style="flex:1; display:flex; flex-direction:column;"><label>内容</label><textarea id="edit-content" class="editor-textarea"></textarea></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
<div id="letter-app-modal" class="modal-overlay">
    <div id="letter-list-view" style="width:100%; height:100%; display:flex; flex-direction:column; background:#f5f5f5;">
        <div class="modal-header" style="background:#e0dcd0; color:#5e4b4b;">
            <span>📬 信箱</span>
            <div style="display:flex; gap:15px;">
                <button class="m-btn small" onclick="createNewLetter()" style="background:#fff;">✏️ 写信</button>
                <button class="close-btn" onclick="closeLetterApp()">×</button>
            </div>
        </div>
        <div id="letter-history-list" style="padding:20px; overflow-y:auto; flex:1;">
        </div>
    </div>
    <div id="letter-write-view" style="display:none; width:100%; height:100%; flex-direction:column; background:#e0e0e0;">
        <div style="padding:10px; display:flex; justify-content:space-between; background:#d4c4a8; align-items:center; flex-shrink:0;">
            <button class="m-btn small" onclick="backToLetterList()" style="background:#fff;">🔙 返回</button>
            <div style="font-size:0.9rem; font-weight:bold; color:#5e4b4b;">Date: <span id="letter-date"></span></div>
            <button class="m-btn small" id="btn-del-letter" onclick="deleteCurrentLetter()" style="background:transparent; color:red; border:none;">🗑️</button>
        </div>
<div class="letter-write-container">
    <div class="paper-sheet sheet-user">
        <div style="font-size:0.8rem; color:#999; margin-bottom:5px; text-align:right;">From: Me</div>
        <textarea id="letter-content" class="letter-textarea-clean" placeholder="在此写下你的信件..." oninput="handleLetterInput(this)"></textarea>
    </div>
    <div id="letter-action-bar" style="text-align:center;">
        <button id="btn-send-letter" class="m-btn primary" onclick="generateReplyLetter(false)" style="width:100%; font-family:sans-serif; background:#5e6d79;">📮 寄出 (投掷占星骰)</button>
    </div>
    <div id="reply-sheet" class="paper-sheet sheet-reply" style="display:none;">
        <div id="dice-visual-container" class="dice-visual-row">            
        </div>        
        <div style="font-size:0.8rem; color:#999; margin-bottom:10px;">Reply:</div>
        <div id="reply-content-display" style="white-space: pre-wrap; flex:1;"></div>
<div style="margin-top:20px; padding-top:10px; border-top:1px solid rgba(0,0,0,0.1); display:flex; gap:10px;">
   <button id="btn-footer-gift" class="m-btn small" onclick="openGiftModal()" style="background:#d4a5a5; color:white; flex:1;">🎁 查看随信礼物</button>
    <button id="btn-footer-regen" class="m-btn small" onclick="generateReplyLetter(true)" style="background:#ccc; color:#555;">🔄 重写内容(不改骰子)</button>
</div>    </div>
    <div style="height:50px;"></div>
</div>
    </div>
</div>
<div id="gift-modal" class="modal-overlay" style="background:rgba(0,0,0,0.7);">
    <button class="close-btn" onclick="document.getElementById('gift-modal').style.display='none'" style="position:absolute; top:20px; right:20px; color:#fff; z-index:100;">×</button>
    
    <div class="receipt-gift-wrapper">
        <div class="gift-invoice-head">
            <div class="gift-invoice-title">GIFT INVOICE</div>
            <div class="gift-invoice-meta">ORDER #<span id="gift-id">0000</span></div>
            <div class="gift-invoice-meta" id="gift-date-str">J** **, *0**</div>
        </div>

        <div class="gift-item-row">
            <span>ITEM:</span>
            <span>Mystery Gift</span>
        </div>

        <div style="border-bottom:2px solid #333; margin-bottom:10px;"></div>

        <div class="gift-desc-block" id="gift-content-text">
            Wait for data...
        </div>

               <div class="gift-item-row" style="margin-top:15px;">
            <span>TOTAL:</span>
            <span id="gift-price-display">$♾️ (LOVE)</span>
        </div>

        <div class="gift-reason-block">
            <strong>ASTRO LOG:</strong><br>
            <span id="gift-reason-text">...</span>
        </div>

        <div style="text-align:center; margin-top:20px; font-size:0.6rem;">
            THANK YOU FOR YOUR PATIENCE
        </div>
        <div class="gift-barcode">||| || ||| | ||||</div>
    </div>
</div>
    <script>
        // === 全局变量 ===
        let chatDisplayLimit = 20; 
        let currentQuoteData = null; 
        let isDeleteMode = false; 
        let selectedDeleteIds = new Set(); 
        let longPressTimer = null; 
        
        let thesaurusCats = ['reply', 'note', 'expense', 'income'];
        let currentThesaurusTab = 'reply';
// === 牌名映射数据 ===
const TAROT_NAMES = {
    0: "愚人", 1: "魔术师", 2: "女祭司", 3: "皇后", 4: "皇帝", 5: "教皇", 6: "恋人", 7: "战车",
    8: "力量", 9: "隐士", 10: "命运之轮", 11: "正义", 12: "倒吊人", 13: "死神", 14: "节制", 15: "恶魔",
    16: "高塔", 17: "星星", 18: "月亮", 19: "太阳", 20: "审判", 21: "世界",
    // 权杖 (22-35)
    22: "权杖王牌", 23: "权杖二", 24: "权杖三", 25: "权杖四", 26: "权杖五", 27: "权杖六", 28: "权杖七",
    29: "权杖八", 30: "权杖九", 31: "权杖十", 32: "权杖侍从", 33: "权杖骑士", 34: "权杖王后", 35: "权杖国王",
    // 圣杯 (36-49)
    36: "圣杯王牌", 37: "圣杯二", 38: "圣杯三", 39: "圣杯四", 40: "圣杯五", 41: "圣杯六", 42: "圣杯七",
    43: "圣杯八", 44: "圣杯九", 45: "圣杯十", 46: "圣杯侍从", 47: "圣杯骑士", 48: "圣杯王后", 49: "圣杯国王",
    // 宝剑 (50-63)
    50: "宝剑王牌", 51: "宝剑二", 52: "宝剑三", 53: "宝剑四", 54: "宝剑五", 55: "宝剑六", 56: "宝剑七",
    57: "宝剑八", 58: "宝剑九", 59: "宝剑十", 60: "宝剑侍从", 61: "宝剑骑士", 62: "宝剑王后", 63: "宝剑国王",
    // 星币 (64-77)
    64: "星币王牌", 65: "星币二", 66: "星币三", 67: "星币四", 68: "星币五", 69: "星币六", 70: "星币七",
    71: "星币八", 72: "星币九", 73: "星币十", 74: "星币侍从", 75: "星币骑士", 76: "星币王后", 77: "星币国王"
};

const LENORMAND_NAMES = {
    1: "骑士", 2: "幸运草", 3: "船", 4: "房子", 5: "树", 6: "云", 7: "蛇", 8: "棺材", 9: "花束",
    10: "镰刀", 11: "鞭子", 12: "鸟", 13: "小孩", 14: "狐狸", 15: "熊", 16: "星星", 17: "鹳鸟", 18: "狗",
    19: "塔", 20: "花园", 21: "山", 22: "路", 23: "老鼠", 24: "心", 25: "戒指", 26: "书", 27: "信",
    28: "男人", 29: "女人", 30: "百合", 31: "太阳", 32: "月亮", 33: "钥匙", 34: "鱼", 35: "锚", 36: "十字架"
};
        // === 基础逻辑 ===
        function updateTime() {
            const now = new Date();
            const h = String(now.getHours()).padStart(2,'0');
            const m = String(now.getMinutes()).padStart(2,'0');
            document.getElementById('clock').innerText = `${h}:${m}`;
            const dateStr = now.toISOString().split('T')[0];
            if(document.getElementById('receipt-date')) document.getElementById('receipt-date').innerText = "DATE: " + dateStr;
        }
        setInterval(updateTime, 1000); updateTime();
const DB_NAME = "RetroOS_System_V7789";  
const DB_VERSION = 10; 
const idb = {
    db: null,
    init: function() {
        return new Promise((resolve, reject) => {
            const req = indexedDB.open(DB_NAME, DB_VERSION);
            
            req.onupgradeneeded = (e) => {
                console.log("正在更新数据库结构...");
                const db = e.target.result;
                if(!db.objectStoreNames.contains('tv')) db.createObjectStore('tv', { keyPath: 'id' });
                if(!db.objectStoreNames.contains('chat_history')) db.createObjectStore('chat_history', { keyPath: 'id', autoIncrement: true });
                if(!db.objectStoreNames.contains('pickup_data')) db.createObjectStore('pickup_data', { keyPath: 'id' });
                if(!db.objectStoreNames.contains('chat_stickers')) db.createObjectStore('chat_stickers', { keyPath: 'id', autoIncrement: true });
                if(!db.objectStoreNames.contains('settings_heavy')) db.createObjectStore('settings_heavy', { keyPath: 'key' });           
                if(!db.objectStoreNames.contains('album_data')) db.createObjectStore('album_data', { keyPath: 'id' });
                if(!db.objectStoreNames.contains('anniversary_data')) db.createObjectStore('anniversary_data', { keyPath: 'id' });
                if(!db.objectStoreNames.contains('tarot_deck')) db.createObjectStore('tarot_deck', { keyPath: 'id' });
                if(!db.objectStoreNames.contains('lenormand_deck')) db.createObjectStore('lenormand_deck', { keyPath: 'id' });
                if(!db.objectStoreNames.contains('theater_data')) db.createObjectStore('theater_data', { keyPath: 'id' });
                if(!db.objectStoreNames.contains('forum_data')) db.createObjectStore('forum_data', { keyPath: 'id' });
if(!db.objectStoreNames.contains('universal_store')) db.createObjectStore('universal_store', { keyPath: 'id' });
            };

            req.onsuccess = (e) => { 
                this.db = e.target.result; 
                console.log("数据库连接成功！");
setTimeout(checkAnniversaries, 2000);
                resolve(this.db); 
            };
            
            req.onerror = (e) => {
                console.error("IndexedDB 错误:", e.target.error);
                resolve(null);
            };
        });
    },
    put: function(storeName, data) {
        return new Promise((resolve) => {
            try {
                const tx = this.db.transaction([storeName], "readwrite");
                tx.objectStore(storeName).put(data);
                tx.oncomplete = () => resolve();
            } catch (err) { console.error(err); resolve(); }
        });
    },
    get: function(storeName, key) {
        return new Promise((resolve) => {
            try {
                const tx = this.db.transaction([storeName], "readonly");
                const req = tx.objectStore(storeName).get(key);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => resolve(null);
            } catch (err) { resolve(null); }
        });
    },
    getAll: function(storeName) {
        return new Promise((resolve) => {
            try {
                const tx = this.db.transaction([storeName], "readonly");
                const req = tx.objectStore(storeName).getAll();
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => resolve([]);
            } catch (err) { resolve([]); }
        });
    },
    delete: function(storeName, key) {
        return new Promise((resolve) => {
            try {
                const tx = this.db.transaction([storeName], "readwrite");
                tx.objectStore(storeName).delete(key);
                tx.oncomplete = () => resolve();
            } catch (err) { resolve(); }
        });
    },
    clear: function(storeName) {
        return new Promise((resolve) => {
            try {
                const tx = this.db.transaction([storeName], "readwrite");
                tx.objectStore(storeName).clear();
                tx.oncomplete = () => resolve();
            } catch (err) { resolve(); }
        });
    }
};

        function loadTVContent() {
            idb.get('tv', 'currentImage').then(res => {
                if (res && res.blob) {
                    const url = (typeof res.blob === 'string') ? res.blob : URL.createObjectURL(res.blob);
                    document.getElementById('tv-content').src = url;
                    document.getElementById('tv-content').style.display = 'block';
                    document.querySelector('.tv-placeholder').style.display = 'none';
                }
            });
        }
        document.getElementById('tv-file-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if(file) {
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const base64 = evt.target.result;
                    document.getElementById('tv-content').src = base64;
                    document.getElementById('tv-content').style.display = 'block';
                    document.querySelector('.tv-placeholder').style.display = 'none';
                    idb.put('tv', { id: "currentImage", blob: base64 });
                };
                reader.readAsDataURL(file);
            }
        });
        let typeWriterTimeout = null; 
        function openFan() {
            const modal = document.getElementById('fan-modal');
            const textEl = document.getElementById('fan-display-text');
            textEl.innerHTML = '';
            
            if(typeWriterTimeout) clearTimeout(typeWriterTimeout);
            
            const data = getThesaurusData()['note'] || [];
            let fullText = data.length > 0 ? data[Math.floor(Math.random() * data.length)] : "NO SIGNAL...\n\nSYSTEM STANDBY";
            
            modal.style.display = 'flex';
            
            setTimeout(() => {
                let charIndex = 0;
                function typeChar() {
                    if (charIndex < fullText.length) {
                        textEl.innerHTML += fullText.charAt(charIndex);
                        charIndex++;
                        typeWriterTimeout = setTimeout(typeChar, 30); 
                    }
                }
                typeChar();
            }, 500);
        }
        function closeFan() {
            document.getElementById('fan-modal').style.display = 'none';
            if(typeWriterTimeout) clearTimeout(typeWriterTimeout);
        }
        function openFileApp() { 
            document.getElementById('file-modal').style.display = 'flex'; 
            checkDeckStatus(); // 打开时立即检查保存状态
        }        document.getElementById('file-generic-input').addEventListener('change', function(e){
            if(e.target.files.length > 0) {
                alert("文件已选择，系统已接收 (通用文件不做特殊入库处理)");
            }
        });        document.getElementById('file-tarot-input').addEventListener('change', async function(e){
            const files = Array.from(e.target.files);
            let count = 0;
            const statusDiv = document.getElementById('tarot-status');
            statusDiv.innerText = "正在处理...";
            
            for(let file of files) {
                const match = file.name.match(/^(\d+)\.(jpg|jpeg)$/i);
                if(match) {
                    const id = parseInt(match[1]);
                    if(id >= 0 && id <= 77) {
                        const reader = new FileReader();
                        await new Promise(resolve => {
                            reader.onload = (evt) => {
                                idb.put('tarot_deck', { id: id, data: evt.target.result }).then(resolve);
                            };
                            reader.readAsDataURL(file);
                        });
                        count++;
                    }
                }
            }
            statusDiv.innerText = `成功导入 ${count} 张塔罗牌`;
            if(count > 0) {
                alert(`✅ 成功导入 ${count} 张塔罗牌！`);
            } else {
                alert("❌ 未找到符合规范的图片 (0-77.jpg)");
            }
        });        document.getElementById('file-lenormand-input').addEventListener('change', async function(e){
            const files = Array.from(e.target.files);
            let count = 0;
            const statusDiv = document.getElementById('lenormand-status');
            if(statusDiv) statusDiv.innerText = "正在处理...";
            
            for(let file of files) {
                const match = file.name.match(/^(\d+)\.(jpg|jpeg)$/i);
                if(match) {
                    const id = parseInt(match[1]);
                    if(id >= 1 && id <= 36) {
                        const reader = new FileReader();
                        await new Promise(resolve => {
                            reader.onload = (evt) => {
                                idb.put('lenormand_deck', { id: id, data: evt.target.result }).then(resolve);
                            };
                            reader.readAsDataURL(file);
                        });
                        count++;
                    }
                }
            }
            if(count > 0) {
                alert(`✅ 成功导入 ${count} 张雷诺曼牌！`);
            } else {
                alert("❌ 未找到符合规范的图片 (1-36.jpg)");
            }
        });
        async function checkDeckStatus() {
            try {
                const tarotList = await idb.getAll('tarot_deck');
                const tCount = tarotList ? tarotList.length : 0;
                const tEl = document.getElementById('tarot-status');
                if(tCount > 0) {
                    tEl.innerHTML = `<span style="color:#4caf50; font-weight:bold;">✅ 系统档案中已永久保存: ${tCount} 张</span>`;
                    if(tCount < 78) tEl.innerHTML += ` <span style="color:#ff9800; font-size:0.7rem">(还差 ${78-tCount} 张)</span>`;
                } else {
                    tEl.innerText = "当前档案为空，请上传 0-77.jpg";
                }
            } catch(e) { console.log(e); }
            try {
                const lenList = await idb.getAll('lenormand_deck');
                const lCount = lenList ? lenList.length : 0;
                const lEl = document.getElementById('lenormand-status');
                if(lCount > 0) {
                    lEl.innerHTML = `<span style="color:#4caf50; font-weight:bold;">✅ 系统档案中已永久保存: ${lCount} 张</span>`;
                    if(lCount < 36) lEl.innerHTML += ` <span style="color:#ff9800; font-size:0.7rem">(还差 ${36-lCount} 张)</span>`;
                } else {
                    lEl.innerText = "当前档案为空，请上传 1-36.jpg";
                }
            } catch(e) { console.log(e); }
        }
async function openChatApp() {
    document.getElementById('chat-modal').style.display = 'flex';
    loadSettingsToUI();
    
    
    await applyChatSettings(); 
    
    chatDisplayLimit = 20; 
    renderChatHistory();
}
        function closeChatApp() { document.getElementById('chat-modal').style.display = 'none'; }
        function toggleChatSettings() { document.getElementById('chat-settings').classList.toggle('open'); }

        function getChatSettings() {
            const def = {
                myFrame: '', botFrame: '',
                myCss: '', botCss: '', delayMin: 1, delayMax: 5, countMin: 1, countMax: 3,
                passiveMin: 1, passiveMax: 60, title: "私密聊天", isOnline: false,
                nudgeList: "发呆\n睡觉\n数钱\n干饭\n摸鱼"
            };
            try { return { ...def, ...JSON.parse(localStorage.getItem('chat_settings') || '{}') }; } 
            catch { return def; }
        }

        function saveChatSettings(extraData = {}) {
            let s = getChatSettings();
            const uiData = {
                myFrame: document.getElementById('set-my-frame').value,
                botFrame: document.getElementById('set-bot-frame').value,
                myCss: document.getElementById('set-my-css').value,
                botCss: document.getElementById('set-bot-css').value,
                delayMin: parseInt(document.getElementById('set-delay-min').value) || 1,
                delayMax: parseInt(document.getElementById('set-delay-max').value) || 5,
                countMin: parseInt(document.getElementById('set-count-min').value) || 1,
                countMax: parseInt(document.getElementById('set-count-max').value) || 3,
                passiveMin: parseInt(document.getElementById('set-passive-min').value) || 1,
                passiveMax: parseInt(document.getElementById('set-passive-max').value) || 60,
                title: document.getElementById('chat-title-input').value,
                nudgeList: document.getElementById('set-nudge-list').value
            };
            s = { ...s, ...uiData, ...extraData };
            localStorage.setItem('chat_settings', JSON.stringify(s));
            applyChatSettings(); 
        }

        async function loadHeavyResources() {
            const bgItem = await idb.get('settings_heavy', 'bg');
            const myAvatarItem = await idb.get('settings_heavy', 'myAvatar');
            const botAvatarItem = await idb.get('settings_heavy', 'botAvatar');
            return {
                bg: bgItem ? bgItem.data : '',
                myAvatar: myAvatarItem ? myAvatarItem.data : '',
                botAvatar: botAvatarItem ? botAvatarItem.data : ''
            };
        }
        async function applyChatSettings() {
            const s = getChatSettings();
            const heavy = await loadHeavyResources();
            const chatModal = document.getElementById('chat-modal');
            if(heavy.bg) chatModal.style.backgroundImage = `url(${heavy.bg})`;
            else chatModal.style.backgroundImage = 'none';

            document.getElementById('chat-title-input').value = s.title;
            updateStatusUI(s.isOnline);
            window.currentAvatars = { my: heavy.myAvatar, bot: heavy.botAvatar };

            let styleTag = document.getElementById('dynamic-chat-style');
            if (!styleTag) {
                styleTag = document.createElement('style');
                styleTag.id = 'dynamic-chat-style';
                document.head.appendChild(styleTag);
            }
            
            styleTag.innerHTML = `
                .msg-row.me .msg-bubble { ${s.myCss} }
                .msg-row.other .msg-bubble { ${s.botCss} }
            `;
        }

        function loadSettingsToUI() {
            const s = getChatSettings();
            document.getElementById('set-my-frame').value = s.myFrame || '';
            document.getElementById('set-bot-frame').value = s.botFrame || '';
            document.getElementById('set-my-css').value = s.myCss || '';
            document.getElementById('set-bot-css').value = s.botCss || '';
            document.getElementById('set-delay-min').value = s.delayMin;
            document.getElementById('set-delay-max').value = s.delayMax;
            document.getElementById('set-count-min').value = s.countMin;
            document.getElementById('set-count-max').value = s.countMax;
            document.getElementById('set-passive-min').value = s.passiveMin;
            document.getElementById('set-passive-max').value = s.passiveMax;
            document.getElementById('set-nudge-list').value = s.nudgeList || "";
            document.getElementById('set-chat-bg').value = ""; 
        }

        function handleFileToInput(inputEl, type) {
            const file = inputEl.files[0];
            if(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    idb.put('settings_heavy', { key: type, data: e.target.result }).then(() => {
                        applyChatSettings(); 
                        alert("保存成功！");
                    });
                };
                reader.readAsDataURL(file);
            }
        }
        
        function saveLineTitle() { saveChatSettings(); }

        let passiveTimer = null;
        function updateStatusUI(isOnline) {
            const toggle = document.getElementById('chat-status-toggle');
            const text = document.getElementById('chat-status-text');
            if(isOnline) {
                toggle.classList.add('status-online');
                text.innerText = "在线";
            } else {
                toggle.classList.remove('status-online');
                text.innerText = "休息";
            }
        }
        function toggleOnlineStatus() {
            const s = getChatSettings();
            const newState = !s.isOnline;
            saveChatSettings({ isOnline: newState });
            updateStatusUI(newState);
            handlePassiveLoop(newState);
        }
        function handlePassiveLoop(isOnline) {
            if(passiveTimer) clearTimeout(passiveTimer);
            if(!isOnline) return;

            const s = getChatSettings();
            const minMs = s.passiveMin * 60 * 1000;
            const maxMs = s.passiveMax * 60 * 1000;
            const delay = Math.random() * (maxMs - minMs) + minMs;
            
            passiveTimer = setTimeout(() => {
                if(getChatSettings().isOnline) {
                    triggerBotReply();
                    handlePassiveLoop(true);
                }
            }, delay);
        }
        async function clearChatHistory() { 
            if(confirm('确定清空聊天记录？')) {
                await idb.clear('chat_history');
                document.getElementById('chat-history').innerHTML = ''; 
            }
        }
        function renderChatHistory() {
    return new Promise((resolve) => {
        const history = document.getElementById('chat-history');
        const tx = idb.db.transaction(['chat_history'], 'readonly');
        const store = tx.objectStore('chat_history');
        const keysReq = store.getAllKeys();

        keysReq.onsuccess = () => {
            const allKeys = keysReq.result;
            const total = allKeys.length;
            const startIndex = Math.max(0, total - chatDisplayLimit);
            const keysToLoad = allKeys.slice(startIndex); 
            if (keysToLoad.length === 0) {
                history.innerHTML = '<div class="load-more-container"><button class="load-more-btn" onclick="loadMoreMessages()">暂无更多历史</button></div>';
                resolve();
                return;
            }

            const promises = keysToLoad.map(key => idb.get('chat_history', key));
            
            Promise.all(promises).then(msgs => {
                
                history.innerHTML = '';
                const loadBtnDiv = document.createElement('div');
                loadBtnDiv.className = 'load-more-container';
                loadBtnDiv.innerHTML = `<button class="load-more-btn" onclick="loadMoreMessages()">点击加载更多历史</button>`;
                history.appendChild(loadBtnDiv);
                const fragment = document.createDocumentFragment();
                msgs.forEach(msg => { 
                    if(msg) {
                        const el = createMessageElement(msg, true); 
                        fragment.appendChild(el);
                    }
                });
                
                history.appendChild(fragment);

                if(isDeleteMode) {
                    history.classList.add('delete-mode');
                }

                resolve(); 
            });
        };
    });
}

        function loadMoreMessages() {
            chatDisplayLimit += 20;
            renderChatHistory(); 
        }

        function triggerQuote(text, isMe) {
            if(isDeleteMode) return; 
            const s = getChatSettings();
            const userName = isMe ? "我" : (s.title || "对方");
            
            currentQuoteData = { text: text, user: userName };

            const bar = document.getElementById('quote-preview-bar');
            const content = document.getElementById('quote-content-text');
            
            let previewText = text;
            if(text.startsWith('data:image') || text.startsWith('blob:')) previewText = '[图片]';
            
            content.innerText = previewText;
            bar.style.display = 'flex';
        }

        function cancelQuote() {
            currentQuoteData = null; 
            document.getElementById('quote-preview-bar').style.display = 'none'; 
        }

        function appendMessage(content, isMe, type = 'text', quote = null) {
            const msgObj = { text: content, isMe: isMe, type: type, quote: quote, timestamp: Date.now() };
            const tx = idb.db.transaction(['chat_history'], "readwrite");
            const req = tx.objectStore('chat_history').add(msgObj);
            
            req.onsuccess = (e) => {
                msgObj.id = e.target.result; 
                createMessageElement(msgObj); 
                const history = document.getElementById('chat-history');
                history.scrollTop = history.scrollHeight;
            };
        }
function createMessageElement(msg, returnElementOnly = false) {
    const s = getChatSettings();
    const history = document.getElementById('chat-history'); 
    const avatars = window.currentAvatars || { my: '', bot: '' };
    const isMe = msg.isMe;

    const row = document.createElement('div');
    row.className = `msg-row ${isMe ? 'me' : 'other'}`;
    if(msg.type === 'system') {
        row.className = 'msg-row system';
        row.innerHTML = `<div class="msg-system-text">${msg.text}</div>`;
        if(returnElementOnly) return row;
        history.appendChild(row);
        return;
    }row.addEventListener('touchstart', () => handleLongPressStart(msg.id), {passive: true});
    row.addEventListener('touchend', handleLongPressEnd);
    row.addEventListener('mousedown', () => handleLongPressStart(msg.id));
    row.addEventListener('mouseup', handleLongPressEnd);
    row.addEventListener('mousemove', handleLongPressEnd);

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.className = 'msg-checkbox';
    if(selectedDeleteIds.has(msg.id)) checkbox.checked = true;
    checkbox.onclick = (e) => toggleSelectMessage(e, msg.id);

    const avatarUrl = isMe ? avatars.my : avatars.bot;
    const frameUrl = isMe ? s.myFrame : s.botFrame;
    let avatarHtml = `<div class="msg-avatar" style="background-image:url(${avatarUrl || ''})" ondblclick="handleNudge(${isMe})">`;
    if(frameUrl) avatarHtml += `<img class="avatar-frame" src="${frameUrl}">`;
    avatarHtml += `</div>`;
    const now = new Date(msg.timestamp || Date.now());
    const h = String(now.getHours()).padStart(2,'0');
    const m = String(now.getMinutes()).padStart(2,'0');
    const timeStr = `${h}:${m}`;
    let bubbleContent = '';
    if(msg.quote) {
        let qText = msg.quote.text;
        if(qText.startsWith('data:image')) qText = '[图片]';
        bubbleContent += `<div class="msg-quote-block"><span class="msg-quote-user">${msg.quote.user}:</span><span>${qText}</span></div>`;
    }
    if(msg.type === 'image') {
        bubbleContent += `<img src="${msg.text}" class="msg-image">`;
    } else {
        bubbleContent += `<span>${msg.text}</span>`;
    }
    bubbleContent += `<span class="msg-time">${timeStr}</span>`;

    const bubbleHtml = `<div class="msg-bubble" ondblclick="triggerQuote('${msg.text ? msg.text.replace(/'/g, "\\'") : ''}', ${isMe})">${bubbleContent}</div>`;

    if (isMe) {
        row.innerHTML = bubbleHtml + avatarHtml;
        row.prepend(checkbox);
    } else {
        row.innerHTML = avatarHtml + bubbleHtml;
        row.prepend(checkbox);
    }

    if(returnElementOnly) return row;
    history.appendChild(row);
}
async function openChatApp() {

    loadSettingsToUI();
    await applyChatSettings(); 
    
    chatDisplayLimit = 20; 

    await renderChatHistory();
    const modal = document.getElementById('chat-modal');
    modal.style.display = 'flex';
    const history = document.getElementById('chat-history');
    requestAnimationFrame(() => {
        history.scrollTop = history.scrollHeight;
    });
}

        function handleNudge(isMeClicked) {
            const s = getChatSettings();
            const targetName = isMeClicked ? "自己" : (s.title || "对方");
            const states = s.nudgeList.split('\n').map(l=>l.trim()).filter(l=>l);
            const randomState = states.length > 0 ? states[Math.floor(Math.random() * states.length)] : "发呆";
            appendMessage(`你拍了拍 ${targetName} ${targetName}正在${randomState}`, false, 'system');
        }

        function sendUserMessage() {
            const input = document.getElementById('chat-input-text');
            const text = input.value.trim();
            if(!text) return;
            appendMessage(text, true, 'text', currentQuoteData); 
            input.value = '';
            cancelQuote(); 
            triggerBotReply(); 
        }

        function handleChatImageUpload(input) {
            const file = input.files[0];
            if(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    appendMessage(e.target.result, true, 'image');
                    triggerBotReply();
                };
                reader.readAsDataURL(file);
            }
            input.value = ''; 
        }
        let isStickerDeleteMode = false;
        async function getStickers() { 
            const list = await idb.getAll('chat_stickers');
            return list.map(item => item.data); 
        }
        
        async function toggleStickers() {
            const modal = document.getElementById('sticker-modal');
            if(modal.style.display === 'none') {
                modal.style.display = 'flex';
                await renderStickers();
            } else {
                modal.style.display = 'none';
                isStickerDeleteMode = false; 
            }
        }
        
        async function renderStickers() {
            const grid = document.getElementById('sticker-grid-container');
            const btn = document.getElementById('toggle-del-btn');
            grid.innerHTML = '';
            
            if(isStickerDeleteMode) {
                grid.classList.add('delete-mode');
                btn.style.background = '#ffcccc'; btn.innerText = "完成删除";
            } else {
                grid.classList.remove('delete-mode');
                btn.style.background = '#e8d7d7'; btn.innerText = "🗑️ 删除模式";
            }

            const rawList = await idb.getAll('chat_stickers'); 
            rawList.forEach((item) => {
                const wrap = document.createElement('div');
                wrap.className = 'sticker-item-wrap';
                const img = document.createElement('img');
                img.src = item.data; img.className = 'sticker-img';
                const del = document.createElement('div');
                del.className = 'sticker-del-btn';
                del.innerText = '×';
                del.onclick = (e) => { e.stopPropagation(); deleteSticker(item.id); };

                img.onclick = () => {
                    if(isStickerDeleteMode) return; 
                    appendMessage(item.data, true, 'image');
                    document.getElementById('sticker-modal').style.display='none';
                    triggerBotReply();
                };
                wrap.appendChild(img);
                wrap.appendChild(del);
                grid.appendChild(wrap);
            });
        }

        async function handleStickerUpload(input) {
            const files = Array.from(input.files);
            if (!files.length) return;
            const uploadTasks = files.map(file => {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        idb.put('chat_stickers', { data: e.target.result }).then(() => resolve());
                    };
                    reader.readAsDataURL(file);
                });
            });
            await Promise.all(uploadTasks);
            await renderStickers();
            input.value = ''; 
        }

        function toggleStickerDeleteMode() { isStickerDeleteMode = !isStickerDeleteMode; renderStickers(); }
        async function deleteSticker(key) { await idb.delete('chat_stickers', key); renderStickers(); }
        async function triggerBotReply() {
            const s = getChatSettings();
            const delay = Math.floor(Math.random() * (s.delayMax - s.delayMin + 1) + s.delayMin) * 1000;
            
            setTimeout(async () => {
                let count = Math.floor(Math.random() * (s.countMax - s.countMin + 1) + s.countMin);
                if(count < 1) count = 1;
                
                const texts = getThesaurusData()['reply'] || [];
                const stickers = await getStickers();
                
                let botQuote = null;
                if (Math.random() < 0.2) {
                    const allMsgs = await idb.getAll('chat_history');
                    const validMsgs = allMsgs.filter(m => m.type !== 'system' && m.text);
                    if(validMsgs.length > 0) {
                        const randomIndex = Math.floor(Math.random() * validMsgs.length);
                        const targetMsg = validMsgs[randomIndex];
                        botQuote = {
                            text: targetMsg.text,
                            user: targetMsg.isMe ? "我" : (s.title || "对方")
                        };
                    }
                }
                
                if(texts.length === 0 && stickers.length === 0) {
                    appendMessage("[自动回复] 词库和表情包均为空", false);
                    return;
                }

                let sent = 0;
                const sendInterval = setInterval(() => {
                    if(sent >= count) { clearInterval(sendInterval); return; }
                    const thisQuote = (sent === 0) ? botQuote : null;
                    const useSticker = (stickers.length > 0) && (Math.random() < 0.3);
                    
                    if (useSticker) {
                        const randomSticker = stickers[Math.floor(Math.random() * stickers.length)];
                        appendMessage(randomSticker, false, 'image', thisQuote);
                        NotificationManager.send({
                            title: (getChatSettings().title || "对方") + " 发来一张图片",
                            body: "[图片] 点击查看",
                            icon: "🖼️",
                            onClick: () => openChatApp()
                        });

                    } else if (texts.length > 0) {
                        const randomText = texts[Math.floor(Math.random() * texts.length)];
                        appendMessage(randomText, false, 'text', thisQuote);
                        NotificationManager.send({
                            title: getChatSettings().title || "对方",
                            body: randomText, 
                            icon: "💬",
                            onClick: () => openChatApp()
                        });

                    } else {
                       
                         const randomSticker = stickers[Math.floor(Math.random() * stickers.length)];
                         appendMessage(randomSticker, false, 'image', thisQuote);
                         NotificationManager.send({
                            title: "新消息",
                            body: "收到一条新消息",
                            onClick: () => openChatApp()
                        });
                    }
                                        sent++;
                }, 1000); 
            }, delay); 
        } 
function getThesaurusData() { 
    // 从大内存读取，如果没有则返回默认结构
    return window.BIG_MEMORY.thesaurus_data || {reply:[], note:[], expense:[], income:[]}; 
}

function saveThesaurusData(data) { 
    // 更新内存
    window.BIG_MEMORY.thesaurus_data = data;
    // 存入无限数据库 (universal_store)
    if(typeof idb !== 'undefined') {
        idb.put('universal_store', { id: 'thesaurus_data', data: data });
    }
}
        function openThesaurus() { document.getElementById('thesaurus-modal').style.display = 'flex'; renderThesaurusList(); }
        function closeThesaurus() { document.getElementById('thesaurus-modal').style.display = 'none'; }
        function switchThesaurusTab(tab) { currentThesaurusTab = tab; thesaurusCats.forEach(t => document.getElementById(`tab-${t}`).classList.toggle('active', t===tab)); renderThesaurusList(); }
        function renderThesaurusList() {
            const listEl = document.getElementById('thesaurus-list'); listEl.innerHTML = '';
            (getThesaurusData()[currentThesaurusTab] || []).forEach((text, index) => {
                listEl.innerHTML += `<div class="word-item"><span class="word-text">${text}</span><span style="color:red;cursor:pointer" onclick="deleteWord(${index})">×</span></div>`;
            });
        }
        function addWord() { const val = prompt("输入内容:"); if(val) { const d = getThesaurusData(); d[currentThesaurusTab].push(val); saveThesaurusData(d); renderThesaurusList(); } }
        function deleteWord(idx) { if(confirm("删除?")) { const d = getThesaurusData(); d[currentThesaurusTab].splice(idx,1); saveThesaurusData(d); renderThesaurusList(); } }
        function exportWords() {
            const blob = new Blob([getThesaurusData()[currentThesaurusTab].join('\n')], {type: "text/plain;charset=utf-8"});
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `词库_${currentThesaurusTab}.txt`; document.body.appendChild(a); a.click(); document.body.removeChild(a);
        }
        function importWords() {
            const input = document.getElementById('txt-import-input');
            input.onchange = (e) => {
                const r = new FileReader();
                r.onload = (ev) => { 
                    const lines = ev.target.result.split(/\r?\n/).map(l=>l.trim()).filter(l=>l); 
                    const d = getThesaurusData(); 
                    if(!d[currentThesaurusTab]) d[currentThesaurusTab] = [];
                    d[currentThesaurusTab] = d[currentThesaurusTab].concat(lines); 
                    saveThesaurusData(d); renderThesaurusList(); 
                };
                r.readAsText(e.target.files[0]);
            }; input.click();
        }
const wbCategories = ["1.全局", "2.小剧场", "3.塔罗牌", "4.雷诺曼", "5.传讯", "6.报纸", "7.论坛体", "8.捡手机文学", "9.冰箱", "10.假如你是ta的梦角", "11.捡到ta的手机", "12.学习计划", "13.信件", "14.日记", "15.六爻", "16.梅花", "17.老福特", "18.宠物"];
        let currentCategory = wbCategories[0]; let editingIndex = -1;
        function getWBData() { 
    return window.BIG_MEMORY.world_book || {}; 
}

function saveWBData(data) { 
    window.BIG_MEMORY.world_book = data;
    if(typeof idb !== 'undefined') {
        idb.put('universal_store', { id: 'world_book', data: data });
    }
}
function getWBData() { 
    return window.BIG_MEMORY.world_book || {}; 
}

function saveWBData(data) { 
    window.BIG_MEMORY.world_book = data;
    if(typeof idb !== 'undefined') {
        idb.put('universal_store', { id: 'world_book', data: data });
    }
}
           function openWorldBook() {
            document.getElementById('wb-modal').style.display = 'flex';
            const sb = document.getElementById('wb-sidebar'); sb.innerHTML = '';
            wbCategories.forEach(cat => {
                const el = document.createElement('div'); el.className = `wb-category ${cat === currentCategory ? 'active' : ''}`;
                el.innerText = cat; el.onclick = () => { currentCategory = cat; openWorldBook(); }; sb.appendChild(el);
            });
            renderWBCategory(currentCategory);
        }
        function closeWorldBook() { document.getElementById('wb-modal').style.display = 'none'; }
        function renderWBCategory(cat) {
            const list = document.getElementById('wb-list'); list.innerHTML = '';
            (getWBData()[cat] || []).forEach((entry, index) => {
                const div = document.createElement('div'); div.className = 'wb-entry';
                div.onclick = (e) => { if(e.target.type!=='checkbox' && !e.target.innerText.includes('×')) openEntryEditor(index); };
                div.innerHTML = `<input type="checkbox" class="wb-checkbox" ${entry.enabled!==false?'checked':''} onclick="toggleEntry('${cat}',${index})"><div class="wb-entry-info"><div style="font-weight:bold">${entry.title||'无标题'}</div><div style="font-size:0.8rem;color:#888;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${entry.content||''}</div></div><button style="border:none;background:none;color:#e5b9b9;font-size:1.2rem" onclick="deleteEntry('${cat}',${index})">×</button>`;
                list.appendChild(div);
            });
        }
        function addEntry() { const d = getWBData(); if(!d[currentCategory]) d[currentCategory]=[]; d[currentCategory].push({title:"新条目", content:"", enabled:true}); saveWBData(d); renderWBCategory(currentCategory); openEntryEditor(d[currentCategory].length-1); }
        function toggleEntry(c,i) { const d=getWBData(); if(d[c][i]) d[c][i].enabled=!d[c][i].enabled; saveWBData(d); }
        function deleteEntry(c,i) { if(confirm("删除?")){ const d=getWBData(); d[c].splice(i,1); saveWBData(d); renderWBCategory(c); } }
        function openEntryEditor(i) { editingIndex = i; const entry = getWBData()[currentCategory][i]; document.getElementById('edit-title').value = entry.title || ""; document.getElementById('edit-content').value = entry.content || ""; document.getElementById('wb-editor-overlay').style.display = 'flex'; }
        function closeEntryEditor() { document.getElementById('wb-editor-overlay').style.display = 'none'; editingIndex=-1; }
        function saveEntryEditor() { if(editingIndex===-1) return; const d = getWBData(); d[currentCategory][editingIndex].title = document.getElementById('edit-title').value; d[currentCategory][editingIndex].content = document.getElementById('edit-content').value; saveWBData(d); renderWBCategory(currentCategory); closeEntryEditor(); }
function exportCategory() {
    const btn = event.target; 
    let allData = {};
    if (window.BIG_MEMORY && window.BIG_MEMORY.world_book) {
        allData = window.BIG_MEMORY.world_book;
    } else {
        allData = JSON.parse(localStorage.getItem('world_book_data') || '{}');
    }

    if (!currentCategory) currentCategory = "1.全局";
    const data = allData[currentCategory] || [];
    
    if (data.length === 0) {
        return alert(`❌ 分类【${currentCategory}】中没有数据。`);
    }

    let textContent = `=== RetroOS World Book: ${currentCategory} ===\n\n`;
    data.forEach((item, index) => {
        if (item) {
            const title = item.title || "无标题";
            const content = item.content || "";
            const status = item.enabled ? "" : "[已禁用]";
            textContent += `----------------------------------------\r\n`;
            textContent += `📝 #${index + 1} ${title} ${status}\r\n`;
            textContent += `----------------------------------------\r\n`;
            textContent += `${content.replace(/\n/g, '\r\n')}\r\n\r\n\r\n`;
        }
    });
    const blob = new Blob(['\uFEFF' + textContent], { type: "text/plain;charset=utf-8" });
    const fileName = `WorldBook_${currentCategory}_${Date.now()}.txt`;
    const file = new File([blob], fileName, { type: "text/plain" });
    if (navigator.canShare && navigator.canShare({ files: [file] })) {
        navigator.share({
            files: [file],
            title: '世界书导出',
            text: `分类：${currentCategory}`
        }).catch(e => console.log("分享取消"));
    } else {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        setTimeout(() => URL.revokeObjectURL(url), 1000);
    }
}

        function importAny() {
            const input = document.getElementById('any-import-input'); input.value='';
            input.onchange = (e) => {
                const file = e.target.files[0]; if(!file) return;
                const r = new FileReader();
                r.onload = (evt) => {
                    const res = evt.target.result; const d = getWBData(); if(!d[currentCategory]) d[currentCategory]=[];
                    if(file.name.endsWith('.txt')) d[currentCategory].push({title:file.name, content:res, enabled:true});
                    else try { 
                        const j = JSON.parse(res); 
                        const arr = Array.isArray(j) ? j : (j.entries || Object.values(j).filter(v=>typeof v==='object'));
                        const valid = arr.map(i=>({title:i.title||i.key||"导入", content:i.content||i.value||"", enabled:true})).filter(i=>i.content);
                        if(valid.length) d[currentCategory] = d[currentCategory].concat(valid);
                    } catch(e){ alert("解析失败"); }
                    saveWBData(d); renderWBCategory(currentCategory);
                }; r.readAsText(file);
            }; input.click();
        }
        let currentCity = "Unknown Location"; 
function initRealWeather() {
    document.getElementById('real-desc').innerText = "定位请求中...";

    const fetchWeather = async (lat, lon, cityName = "") => {
        try {
            const res = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true`);
            const data = await res.json();
            const w = data.current_weather;
            document.getElementById('real-temp').innerText = Math.round(w.temperature) + "°";
            
            const code = w.weathercode;
            let icon = "☁️";
            if (code === 0) icon = "☀️";
            else if (code <= 3) icon = "⛅";
            else if (code >= 45) icon = "🌫️";
            else if (code >= 51) icon = "🌧️";
            else if (code >= 95) icon = "⛈️";
            
            document.getElementById('real-icon').innerText = icon;
            document.getElementById('real-desc').innerText = cityName ? cityName : "已定位";
            window.currentCity = cityName || "本地";
        } catch (e) { 
            document.getElementById('real-desc').innerText = "数据错误";
            alert("获取天气数据失败，请检查网络");
        }
    };
    if (!navigator.geolocation) {
        alert("你的浏览器不支持定位功能");
        return;
    }navigator.geolocation.getCurrentPosition(
        (pos) => {
            const lat = pos.coords.latitude;
            const lon = pos.coords.longitude;
            fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`)
                .then(res => res.json())
                .then(data => {
                    const addr = data.address;
                    const city = addr.city || addr.town || addr.district || "本地";
                    fetchWeather(lat, lon, city);
                })
                .catch(() => {
                    fetchWeather(lat, lon, "已定位");
                });
        }, 
        (err) => {
            console.log(err);
            let errorMsg = "定位失败";
            if (err.code === 1) errorMsg = "你拒绝了定位权限，请在系统设置中允许 Safari 访问位置。";
            else if (err.code === 3) errorMsg = "定位超时，请重试。";
            
            alert("⚠️ " + errorMsg + "\n(你可以手动输入城市拼音)");
            const inputCity = prompt("手动输入城市拼音 (例如 Shanghai):", "Beijing");
            if(inputCity) {
                document.getElementById('real-desc').innerText = inputCity;
                document.getElementById('real-temp').innerText = "25°"; 
                window.currentCity = inputCity;
            } else {
                document.getElementById('real-desc').innerText = "点击设置";
            }
        },
        { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
    );
}
function openSettings() {
    const modal = document.getElementById('settings-modal');
    if(modal) modal.style.display = 'flex';
    try {
        const draft = JSON.parse(localStorage.getItem('api_settings_draft') || '{}');
        if(draft.url) document.getElementById('api-url').value = draft.url;
        if(draft.key) document.getElementById('api-key').value = draft.key;
        if(draft.temp) {
            document.getElementById('api-temp').value = draft.temp;
            document.getElementById('temp-display').innerText = draft.temp;
        }
        if(draft.model) {
             const sel = document.getElementById('model-select');
             
             if (sel.options.length <= 1) {
                 const opt = document.createElement('option');
                 opt.value = draft.model;
                 opt.innerText = draft.model;
                 opt.selected = true;
                 sel.appendChild(opt);
             }
             sel.value = draft.model;
        }
    } catch(e) { console.log("设置草稿加载失败", e); }
    if(typeof renderProfiles === 'function') {
        renderProfiles();
    }
}

function closeSettings() {
    document.getElementById('settings-modal').style.display = 'none';
}
function autoSaveApiSettings() {
    const data = {
        url: document.getElementById('api-url').value,
        key: document.getElementById('api-key').value,
        model: document.getElementById('model-select').value,
        temp: document.getElementById('api-temp').value
    };
    localStorage.setItem('api_settings_draft', JSON.stringify(data));
}
function getProfiles() {
    try {
        const raw = localStorage.getItem('api_profiles');
        if (!raw) return [];
        
        const data = JSON.parse(raw);
        if (Array.isArray(data)) {
            
            const validData = data.filter(item => item && typeof item === 'object' && item.name);
                        
            if (validData.length !== data.length) {
                console.log("检测到并清理了损坏的配置数据");
                saveProfiles(validData);
            }
            return validData;
        }               
        if (typeof data === 'object' && data !== null) {
            const fixed = [data];
            saveProfiles(fixed);
            return fixed;
        }
        
        return []; 
    } catch (e) {
        console.error("读取配置出错，已重置", e);
        return [];
    }
}
function saveProfiles(data) {
    try {
        localStorage.setItem('api_profiles', JSON.stringify(data));
    } catch (e) {
        alert("❌ 保存失败：存储空间不足或被禁用");
    }
}
function renderProfiles() {
    const list = document.getElementById('profile-list');
    if (!list) return;
    
    list.innerHTML = '';
    const profiles = getProfiles(); 

    if (profiles.length === 0) {
        list.innerHTML = '<div style="text-align:center;color:#999;font-size:0.8rem;padding:15px;">暂无保存的方案<br>请在上方配置后点击"另存为"</div>';
        return;
    }

    profiles.forEach((p, index) => {
        if (!p || !p.name) return; // 二次保险

        const div = document.createElement('div');
        div.className = 'profile-item';
        // 强制样式确保显示正常
        div.style.cssText = "display:flex; justify-content:space-between; align-items:center; padding:12px; border-bottom:1px solid #eee; background:#fff; margin-bottom:8px; border-radius:8px; box-shadow: 0 1px 3px rgba(0,0,0,0.05);";
        
        div.innerHTML = `
            <div onclick="loadProfile(${index})" style="cursor:pointer; flex:1; display:flex; flex-direction:column;">
                <span style="font-weight:bold; color:#333; font-size:0.95rem;">${p.name}</span>
                <span style="font-size:0.75rem; color:#999;">${p.model || 'Default'} · temp:${p.temp || 0.7}</span>
            </div>
            <div onclick="deleteProfile(${index})" style="color:#ff4444; cursor:pointer; padding:5px 10px; font-size:1.2rem; display:flex; align-items:center;">×</div>
        `;
        list.appendChild(div);
    });
}
function saveCurrentProfile() {
    const url = document.getElementById('api-url').value.trim();
    const key = document.getElementById('api-key').value.trim();
    const model = document.getElementById('model-select').value;
    const temp = document.getElementById('api-temp').value;

    if(!url || !key) return alert("❌ 请先填写 API 地址和 Key");
    const timeStr = new Date().toTimeString().split(' ')[0]; // HH:MM:SS
    const defaultName = "配置 " + timeStr;
    
    let name = prompt("给方案起个名字:", defaultName);
    if (!name) return; 
    name = name.trim();

    const profiles = getProfiles();
    
    const idx = profiles.findIndex(p => p.name === name);
    
    if (idx !== -1) {
        if(!confirm(`方案【${name}】已存在，要覆盖它吗？`)) return;
        profiles[idx] = { name, url, key, model, temp };
    } else {
        profiles.push({ name, url, key, model, temp });
    }
    
    saveProfiles(profiles);
    renderProfiles(); 
    const btn = document.querySelector('button[onclick="saveCurrentProfile()"]');
    if(btn) {
        const oldText = btn.innerText;
        btn.innerText = "✅ 已保存";
        setTimeout(() => btn.innerText = oldText, 1500);
    }
}
function deleteProfile(i) {
    if(!confirm("确定删除这个方案吗？")) return;
    const p = getProfiles();
    p.splice(i, 1);
    saveProfiles(p);
    renderProfiles();
}
function loadProfile(i) {
    const profiles = getProfiles();
    if (!profiles[i]) return;
    
    const p = profiles[i];
    document.getElementById('api-url').value = p.url || '';
    document.getElementById('api-key').value = p.key || '';
    document.getElementById('api-temp').value = p.temp || 0.7;
    document.getElementById('temp-display').innerText = p.temp || 0.7;
    
    autoSaveApiSettings();
    
    const sel = document.getElementById('model-select');
    if(p.model) {
        let exists = false;
        for(let k=0; k<sel.options.length; k++) {
            if(sel.options[k].value === p.model) { exists = true; break; }
        }
        if(!exists) {
            const opt = document.createElement('option');
            opt.value = p.model;
            opt.innerText = p.model;
            sel.appendChild(opt);
        }
        sel.value = p.model;
    }
    
    alert(`⚡ 已应用方案：${p.name}`);
}  
        async function fetchModels() {
            try {
                const url = document.getElementById('api-url').value; const key = document.getElementById('api-key').value;
                const res = await fetch(`${url.replace(/\/$/, "")}/models`, { headers: { 'Authorization': `Bearer ${key}` } });
                const data = await res.json();
                const models = (data.data || data).map(i => i.id || i);
                const sel = document.getElementById('model-select'); sel.innerHTML = '';
                models.forEach(m => sel.innerHTML += `<option value="${m}">${m}</option>`);
                alert(`加载 ${models.length} 个模型`);
            } catch(e) { alert("获取失败"); }
        }
        function handleLongPressStart(id) {
            if(longPressTimer) clearTimeout(longPressTimer);
            longPressTimer = setTimeout(() => { enterDeleteMode(id); }, 800); 
        }
        function handleLongPressEnd() { if(longPressTimer) clearTimeout(longPressTimer); }

        function enterDeleteMode(initialId) {
            if(isDeleteMode) return; 
            isDeleteMode = true;
            selectedDeleteIds.clear();
            if(initialId) selectedDeleteIds.add(initialId); 
            
            document.getElementById('normal-footer-content').style.display = 'none';
            document.getElementById('delete-footer-content').style.display = 'flex';
            document.getElementById('chat-history').classList.add('delete-mode');
            renderChatHistory();
            updateDeleteCount();
        }

        function quitDeleteMode() {
            isDeleteMode = false;
            selectedDeleteIds.clear();
            document.getElementById('normal-footer-content').style.display = 'flex';
            document.getElementById('delete-footer-content').style.display = 'none';
            document.getElementById('chat-history').classList.remove('delete-mode');
            renderChatHistory(); 
        }

        function toggleSelectMessage(e, id) {
            if(e.target.checked) selectedDeleteIds.add(id);
            else selectedDeleteIds.delete(id);
            updateDeleteCount();
        }

        function updateDeleteCount() { document.getElementById('delete-count-text').innerText = `已选 ${selectedDeleteIds.size} 条`; }

        async function confirmDeleteMessages() {
            if(selectedDeleteIds.size === 0) return;
            if(!confirm(`确定删除选中的 ${selectedDeleteIds.size} 条消息吗？`)) return;
            const tx = idb.db.transaction(['chat_history'], "readwrite");
            const store = tx.objectStore('chat_history');
            selectedDeleteIds.forEach(id => { store.delete(id); });
            tx.oncomplete = () => { quitDeleteMode(); };
        }
function openNewspaper() {
    const modal = document.getElementById('newspaper-modal');
    const now = new Date();
    document.getElementById('news-date-display').innerText = `DATE: ${now.getFullYear()}-${now.getMonth()+1}-${now.getDate()}`;
    const texts = getThesaurusData()['note'] || ["没有什么新鲜事发生。", "天气不错，适合写代码。"];
    const randomText = texts[Math.floor(Math.random() * texts.length)] || "Loading...";
    
    document.getElementById('news-full-text').innerHTML = `
        <span style="font-size:2rem; float:left; line-height:0.8; padding-right:5px; font-weight:bold;">T</span>
        oday's Report:<br><br>${randomText}<br><br>
        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
    `;
    const tvImg = document.getElementById('tv-content').src;
    const newsImg = document.getElementById('news-full-img');
    if(tvImg && tvImg.length > 100) {
        newsImg.src = tvImg;
        newsImg.style.display = 'block';
    }
    
    modal.style.display = 'flex';
}

let canvas, ctx;
let editorState = {
    bgImage: null,      
    frameImage: null,  
    frameMode: 'black', // 模式: black, polaroid, custom, none
    stickers: [],       
    selectedSticker: -1 
};
let touchState = {
    isDragging: false,
    isPinching: false,
    startX: 0,
    startY: 0,
    startDist: 0,
    startAngle: 0,
    initialScale: 1,
    initialRotation: 0
};
function initCamera() {
    canvas = document.getElementById('editor-canvas');
    ctx = canvas.getContext('2d');
    canvas.width = 1080;
    canvas.height = 1080;
canvas.addEventListener('mousedown', handleInputStart);
    canvas.addEventListener('mousemove', handleInputMove);
    canvas.addEventListener('mouseup', handleInputEnd);
    canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
    canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
    canvas.addEventListener('touchend', handleInputEnd);
    
    document.getElementById('frame-select').value = 'black';
    editorState.frameMode = 'black';

    drawCanvas(); 
}
function drawCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (editorState.bgImage) {
        drawImageCover(ctx, editorState.bgImage, canvas.width, canvas.height);
    } else {
        ctx.fillStyle = "#1a1a1a";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#666";
        ctx.font = "40px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("点击 [底图] 上传照片", canvas.width/2, canvas.height/2);
    }
    editorState.stickers.forEach((s, index) => {
        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.rotate(s.rotation * Math.PI / 180); 
        ctx.scale(s.scale, s.scale);
        ctx.drawImage(s.img, -s.img.width/2, -s.img.height/2);
        if (index === editorState.selectedSticker) {
            ctx.strokeStyle = "rgba(255, 0, 0, 0.8)";
            ctx.lineWidth = 5 / s.scale; 
            ctx.setLineDash([15, 10]);
            ctx.strokeRect(-s.img.width/2, -s.img.height/2, s.img.width, s.img.height);
 
            ctx.fillStyle = "red";
            ctx.beginPath();
            ctx.arc(0, 0, 5/s.scale, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.restore();
    });
    drawFrameLayer();
    document.getElementById('sticker-ops').style.display = (editorState.selectedSticker !== -1) ? 'flex' : 'none';
}
function drawFrameLayer() {
    const mode = editorState.frameMode;
    const w = canvas.width;
    const h = canvas.height;

    if (mode === 'none') return;

    if (mode === 'black') {
        const border = 60;
        ctx.lineWidth = border;
        ctx.strokeStyle = "#000000";
        ctx.strokeRect(0, 0, w, h);
    } 
    else if (mode === 'polaroid') {
        const pad = 50;
        const bottom = 220;
        ctx.fillStyle = "#fff";
        ctx.fillRect(0, 0, w, pad); // Top
        ctx.fillRect(0, 0, pad, h); // Left
        ctx.fillRect(w - pad, 0, pad, h); // Right
        ctx.fillRect(0, h - bottom, w, bottom); // Bottom
        ctx.fillStyle = "#333";
        ctx.font = "40px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText("Retro OS", w/2, h - 90);
    } 
    else if (mode === 'custom' && editorState.frameImage) {
ctx.drawImage(editorState.frameImage, 0, 0, w, h);
    }
}
function getDist(t1, t2) {
    return Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
}
function getAngle(t1, t2) {
    return Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX) * 180 / Math.PI;
}

function handleTouchStart(e) {
    e.preventDefault();
    if (e.touches.length === 2 && editorState.selectedSticker !== -1) {
        touchState.isPinching = true;
        touchState.startDist = getDist(e.touches[0], e.touches[1]);
        touchState.startAngle = getAngle(e.touches[0], e.touches[1]);
        
        const s = editorState.stickers[editorState.selectedSticker];
        touchState.initialScale = s.scale;
        touchState.initialRotation = s.rotation;
    } else if (e.touches.length === 1) {
        checkSelection(e.touches[0]);
        if (editorState.selectedSticker !== -1) {
            touchState.isDragging = true;
            const pos = getPos(e.touches[0]);
            touchState.startX = pos.x;
            touchState.startY = pos.y;
        }
    }
    drawCanvas();
}

function handleTouchMove(e) {
    e.preventDefault();
    const s = editorState.stickers[editorState.selectedSticker];
    if (!s) return;

    if (touchState.isPinching && e.touches.length === 2) {
        const currentDist = getDist(e.touches[0], e.touches[1]);
        const currentAngle = getAngle(e.touches[0], e.touches[1]);
        const scaleFactor = currentDist / touchState.startDist;
        s.scale = touchState.initialScale * scaleFactor;
        const rotationDiff = currentAngle - touchState.startAngle;
        s.rotation = touchState.initialRotation + rotationDiff;

        drawCanvas();
    } else if (touchState.isDragging && e.touches.length === 1) {
        const pos = getPos(e.touches[0]);
        s.x += pos.x - touchState.startX;
        s.y += pos.y - touchState.startY;
        touchState.startX = pos.x;
        touchState.startY = pos.y;
        drawCanvas();
    }
}
function handleInputStart(e) {
    checkSelection(e);
    if (editorState.selectedSticker !== -1) {
        touchState.isDragging = true;
        const pos = getPos(e);
        touchState.startX = pos.x;
        touchState.startY = pos.y;
        drawCanvas();
    }
}
function handleInputMove(e) {
    if (!touchState.isDragging || editorState.selectedSticker === -1) return;
    const pos = getPos(e);
    const s = editorState.stickers[editorState.selectedSticker];
    s.x += pos.x - touchState.startX;
    s.y += pos.y - touchState.startY;
    touchState.startX = pos.x;
    touchState.startY = pos.y;
    drawCanvas();
}
function handleInputEnd(e) {
    touchState.isDragging = false;
    touchState.isPinching = false;
}
function checkSelection(inputObj) {
    const pos = getPos(inputObj);
    for (let i = editorState.stickers.length - 1; i >= 0; i--) {
        const s = editorState.stickers[i];
        const hitRadius = (Math.max(s.img.width, s.img.height) * s.scale) / 2;
        if (Math.abs(pos.x - s.x) < hitRadius && Math.abs(pos.y - s.y) < hitRadius) {
            editorState.selectedSticker = i;
            return;
        }
    }
    editorState.selectedSticker = -1;
}

function getPos(evt) {
    const rect = canvas.getBoundingClientRect();
    return {
        x: (evt.clientX - rect.left) * (canvas.width / rect.width),
        y: (evt.clientY - rect.top) * (canvas.height / rect.height)
    };
}
function handleFrameChange(mode) {
    if (mode === 'custom') {
        document.getElementById('upload-frame-custom').click();
    } else {
        editorState.frameMode = mode;
        drawCanvas();
    }
}
function handleCustomFrameUpload(input) {
    const file = input.files[0];
    if (!file) { document.getElementById('frame-select').value = 'none'; return; }
    const reader = new FileReader();
    reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
            editorState.frameImage = img;
            editorState.frameMode = 'custom';
            drawCanvas();
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
    input.value = '';
}
function controlSticker(action, val) {
    const idx = editorState.selectedSticker;
    if (idx === -1) return;
    if (action === 'del') {
        editorState.stickers.splice(idx, 1);
        editorState.selectedSticker = -1;
    } else if (action === 'scale') {
        editorState.stickers[idx].scale *= val;
    }
    drawCanvas();
}
function handleBgUpload(input) {
    const file = input.files[0]; if(!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        const img = new Image();
        img.onload = () => { editorState.bgImage = img; drawCanvas(); };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
    input.value = '';
}
function handleCamStickerUpload(input) {
    const file = input.files[0]; if(!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
            editorState.stickers.push({
                img: img,
                x: canvas.width/2,
                y: canvas.height/2,
                scale: 0.5,
                rotation: 0
            });
            editorState.selectedSticker = editorState.stickers.length - 1;
            drawCanvas();
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
    input.value = '';
}
function drawImageCover(ctx, img, w, h) {
    let ratio = Math.max(w / img.width, h / img.height);
    let cx = (w - img.width * ratio) / 2;
    let cy = (h - img.height * ratio) / 2;
    ctx.drawImage(img, 0, 0, img.width, img.height, cx, cy, img.width * ratio, img.height * ratio);
}
function saveCanvasPhoto() {
   
    const oldSelection = editorState.selectedSticker;
    editorState.selectedSticker = -1;
    drawCanvas();
    canvas.toBlob(async (blob) => {
        editorState.selectedSticker = oldSelection;
        drawCanvas();

        if (!blob) return alert("生成图片失败");
        const filename = `RetroCam_${Date.now()}.png`;
        const file = new File([blob], filename, { type: "image/png" });
        if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
            try {
                await navigator.share({
                    files: [file],
                    title: 'Retro OS Photo',
                    text: 'My retro photo created with Retro OS.'
                });
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error("分享失败", error);
                    fallbackSave(blob); 
                }
            }
        } else {
            
            fallbackSave(blob);
        }
    }, 'image/png');
}
function fallbackSave(blob) {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.download = `Retro_${Date.now()}.png`;
    link.href = url;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    
    if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
        alert("如果没有自动保存，请尝试长按图片并选择“存储到照片”。(建议使用 Safari 浏览器的分享按钮)");
    }
}
function getPeriodData() {
    return window.BIG_MEMORY.period || { records: [], isBleeding: false, lastAnalysis: null };
}

function savePeriodData(data) {
    window.BIG_MEMORY.period = data;
    if(typeof idb !== 'undefined') {
        idb.put('universal_store', { id: 'period', data: data });
    }
}
function openPeriodApp() {
    document.getElementById('period-modal').style.display = 'flex';
    renderPeriodUI(); 
}
function renderPeriodUI() {
    const data = getPeriodData();
    let statusText = "等待记录..."; 
    let predictText = "请在下方记录开始时间";
    const sortedRecords = (data.records || []).sort((a, b) => new Date(b.start) - new Date(a.start));
    const listEl = document.getElementById('p-history-list');
    
    if (listEl) {
        listEl.innerHTML = ''; 
        if (sortedRecords.length === 0) {
            listEl.innerHTML = '<div style="text-align:center; color:#999; padding:10px;">暂无记录</div>';
        } else {
            sortedRecords.forEach((rec, index) => {
                const div = document.createElement('div');
                div.className = 'history-log-item';
                const endStr = rec.end ? rec.end : '进行中...';
                let duration = '';
                if(rec.end) {
                    const startD = new Date(rec.start);
                    const endD = new Date(rec.end);
                    const diff = (endD - startD) / (1000 * 60 * 60 * 24) + 1;
                    duration = ` (${Math.floor(diff)}天)`;
                }
                
                div.innerHTML = `<span>${rec.start} 至 ${endStr} ${duration}</span><span style="color:red; cursor:pointer;" onclick="deletePeriodRecord(${index})">×</span>`;
                listEl.appendChild(div);
            });
        }
    }
    const btn = document.getElementById('p-toggle-btn');
    if(btn) {
        if (data.isBleeding) {
            btn.classList.add('active');
            btn.innerHTML = "🔴 经期中 (点击结束)";
        } else {
            btn.classList.remove('active');
            btn.innerHTML = "⚪ 未在经期 (点击开始)";
        }
    }
    if (sortedRecords.length > 0) {
        const lastStart = new Date(sortedRecords[0].start);
        const today = new Date();
        const diffDays = Math.floor((today - lastStart) / (1000 * 60 * 60 * 24)) + 1;

        if (data.isBleeding) {
            statusText = `经期第 ${diffDays} 天`;
            predictText = "请注意保暖，多喝热水";
        } else {
            let phase = "";
            let emoji = "";
            
            if (diffDays <= 7) { 
                phase = "经期/恢复期"; emoji = "💧";
            } else if (diffDays <= 13) { 
                phase = "卵泡期 (元气满满)"; emoji = "✨";
            } else if (diffDays <= 16) { 
                phase = "排卵期 (易孕)"; emoji = "🥚";
            } else if (diffDays <= 28) { 
                phase = "黄体期 (情绪波动)"; emoji = "🌙";
            } else { 
                phase = "周期延后"; emoji = "⚠️";
            }

            statusText = `${emoji} ${phase}`;
            predictText = `周期第 ${diffDays} 天`;
            const nextDate = new Date(lastStart);
            nextDate.setDate(lastStart.getDate() + 28); 
            const daysToNext = Math.ceil((nextDate - today) / (1000 * 60 * 60 * 24));
            
            if(daysToNext > 0) predictText += ` | 还有 ${daysToNext} 天`;
            else predictText += ` | 已延期 ${Math.abs(daysToNext)} 天`;
        }
    }
    const lastAI = data.lastAnalysis;
    const aiSection = document.getElementById('p-ai-section');
    
    if (sortedRecords.length > 0 && lastAI) {
        
        if(!data.isBleeding && lastAI.phase) {
            statusText = lastAI.phase;
        }
        if(lastAI.next_prediction) {
            predictText = lastAI.next_prediction;
        }
        if(aiSection) {
            aiSection.style.display = 'block';
            document.getElementById('p-care-msg').innerText = lastAI.care_message || "暂无信息";
            document.getElementById('p-recipe-title').innerText = lastAI.recipe_name || "推荐食谱";
            document.getElementById('p-recipe-content').innerText = lastAI.recipe_steps || "暂无详情";
        }
    } else {
        if(aiSection) aiSection.style.display = 'none';
    }
    const statusEl = document.getElementById('p-status-display');
    const predEl = document.getElementById('p-prediction-display');
    if (statusEl) statusEl.innerText = statusText;
    if (predEl) predEl.innerText = predictText;
}
function addPeriodRecord() {
    const start = document.getElementById('p-start-date').value;
    const end = document.getElementById('p-end-date').value;
    
    if (!start) return alert("请至少选择开始时间");
    
    const data = getPeriodData();
    data.records.push({ start, end }); 
    if (end) {
        data.isBleeding = false;
    } else {
        data.isBleeding = true; 
    }
    
    savePeriodData(data);
    renderPeriodUI();
    // 自动触发AI分析
    if(confirm("记录成功！是否让 AI 根据当前状态分析身体并推荐食谱？")) {
        analyzeCycleWithAI();
    }
}
function deletePeriodRecord(index) {
    if(!confirm("删除这条记录？")) return;
    const data = getPeriodData();
    data.records.sort((a, b) => new Date(b.start) - new Date(a.start));
    data.records.splice(index, 1);
    data.lastAnalysis = null; 
    
    savePeriodData(data);
    renderPeriodUI();
}
function togglePeriodStatus() {
    const data = getPeriodData();
    
    data.isBleeding = !data.isBleeding;
    if (data.isBleeding) {
        const today = new Date().toISOString().split('T')[0];
        const hasTodayRecord = data.records.some(r => r.start === today);
        
        if (!hasTodayRecord) {
            data.records.unshift({ start: today, end: "" });
            if(document.getElementById('p-start-date')) {
                document.getElementById('p-start-date').value = today;
            }
        }
    } 
    else {
        const today = new Date().toISOString().split('T')[0];
        if (data.records.length > 0) {
            data.records.sort((a, b) => new Date(b.start) - new Date(a.start));
            if (!data.records[0].end) {
                data.records[0].end = today;
            }
        }
    }

    savePeriodData(data);
    renderPeriodUI(); 
}
async function analyzeCycleWithAI() {
    const aiSection = document.getElementById('p-ai-section');
    aiSection.style.display = 'block';
    document.getElementById('p-care-msg').innerHTML = "<span class='skeleton-text'>正在接受短信中...</span>";
    document.getElementById('p-recipe-content').innerHTML = "Loading...";
    const data = getPeriodData();
    const isBleeding = data.isBleeding;
    const today = new Date().toISOString().split('T')[0];
    const history = data.records
        .sort((a, b) => new Date(b.start) - new Date(a.start))
        .slice(0, 3)
        .map(r => `开始:${r.start}, 结束:${r.end || '未结束'}`)
        .join("; ");
    let apiKey = "";
    let apiUrl = "";
    let model = "";
    try {
        const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}');
        apiKey = s.key; apiUrl = s.url; model = s.model;
    } catch(e) {}
    if (!apiKey) apiKey = document.getElementById('api-key').value;
    if (!apiUrl) apiUrl = document.getElementById('api-url').value;
    if (!model) model = document.getElementById('model-select').value;

    if(!apiKey) return alert("请先在桌面【设置】中配置 API Key！");
    if (apiUrl && apiUrl.endsWith('/')) apiUrl = apiUrl.slice(0, -1);
    if (!apiUrl) apiUrl = "https://api.openai.com/v1"; 
    const wb = getWBData();
    const globalContext = (wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    const prompt = `
你是一位贴心的健康管家，同时你必须**严格扮演世界书中的角色**。

【世界书/角色设定】：
${globalContext}

【用户身体数据】：
- 今天日期：${today}
- 当前是否经期中：${isBleeding ? "是 (Bleeding)" : "否"}
- 历史记录：${history}

【任务要求】：
1. **分析状态**：判断用户处于什么阶段（如：卵泡期/黄体期 Day X）。
2. **预测时间**：根据历史推算下次月经大概日期。
3. **爱人传来的信息**：用角色语气写一段安慰或提醒。
4. **食谱推荐**：推荐一道适合当前身体的食谱。

【输出格式】：
严格 JSON 格式，不要 Markdown：
{
  "phase": "当前的身体阶段（如：黄体期 Day 22）",
  "next_prediction": "简短的下次经期预测（如：预计 02-15 左右到来）",
  "care_message": "角色对用户说的话...",
  "recipe_name": "菜名",
  "recipe_steps": "简要做法..."
}
`;
    try {
        const res = await fetch(`${apiUrl}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model || "gpt-3.5-turbo",
                messages: [
                    { role: "system", content: "You are a helpful assistant." },
                    { role: "user", content: prompt }
                ],
                temperature: 0.7
            })
        });

        const json = await res.json();
        let raw = json.choices[0].message.content;
        raw = raw.replace(/```json/g, "").replace(/```/g, "").trim();
        const result = JSON.parse(raw);

        const currentData = getPeriodData();
        currentData.lastAnalysis = result; 
        savePeriodData(currentData);

        renderPeriodUI();

    } catch(e) {
        console.error(e);
        document.getElementById('p-care-msg').innerText = "分析失败，请检查网络或 API 设置。";
        document.getElementById('p-recipe-content').innerText = "";
    }
}  
window.closeCamera = function() { document.getElementById('camera-modal').style.display = 'none'; };
window.openCamera = function() { 
    document.getElementById('camera-modal').style.display = 'flex'; 
    setTimeout(initCamera, 100); 
};


let activeDeck = []; 
let flippedCards = []; 

function initCardTable() {
    const table = document.getElementById('card-table-modal');
    const area = document.getElementById('card-area');
    area.innerHTML = ''; 
    activeDeck = [];
    flippedCards = [];
    document.getElementById('flipped-count').innerText = '0';
    let fullDeck = [];
    for(let i=0; i<=77; i++) {
        fullDeck.push({ type: 'tarot', id: i, isReversed: Math.random() < 0.3 }); 
    }
    // 添加雷诺曼 (1-36)
    for(let i=1; i<=36; i++) {
        fullDeck.push({ type: 'lenormand', id: i, isReversed: false }); 
    }
    fullDeck.sort(() => Math.random() - 0.5);
    
    activeDeck = fullDeck; 
    const deskW = window.innerWidth;
    const cardWidth = 60;  
    const cardHeight = 90; 
    const gapX = 10;       
    const gapY = 15;       
    let columns = Math.floor((deskW - 20) / (cardWidth + gapX));
    if (columns < 4) columns = 4; 
    if (columns > 8) columns = 8; 
    const totalGridWidth = columns * cardWidth + (columns - 1) * gapX;
    const startX = Math.max(0, (deskW - totalGridWidth) / 2);
    const startY = 60; 
    
    activeDeck.forEach((card, index) => {
        const el = document.createElement('div');
        el.className = 'playing-card';
        const colIndex = index % columns;
        const rowIndex = Math.floor(index / columns);
        
        const leftPos = startX + colIndex * (cardWidth + gapX);
        const topPos = startY + rowIndex * (cardHeight + gapY);
        
        el.style.left = leftPos + 'px';
        el.style.top = topPos + 'px';
        el.style.transform = `rotate(${Math.random() * 4 - 2}deg)`; 
        el.onclick = () => flipCard(el, card, index);
        const front = document.createElement('div');
        front.className = 'playing-card-front';
        el.appendChild(front);
        
        area.appendChild(el);
    });

    const totalRows = Math.ceil(activeDeck.length / columns);
    const totalHeight = startY + totalRows * (cardHeight + gapY) + 100;
    area.style.height = totalHeight + 'px';

    table.style.display = 'flex';
}
function closeCardTable() {
    document.getElementById('card-table-modal').style.display = 'none';
}
async function flipCard(el, cardData, index) {
    if(el.classList.contains('flipped')) {
        el.classList.remove('flipped');
        flippedCards = flippedCards.filter(c => !(c.type === cardData.type && c.id === cardData.id));
        document.getElementById('flipped-count').innerText = flippedCards.length;

        setTimeout(() => {
            const frontEl = el.querySelector('.playing-card-front');
            frontEl.style.backgroundImage = ''; 
            frontEl.style.transform = ''; 
            frontEl.innerText = '';
        }, 300);
        return; 
    }
   el.classList.add('flipped');
    flippedCards.push(cardData);
    document.getElementById('flipped-count').innerText = flippedCards.length;
    const dbName = cardData.type === 'tarot' ? 'tarot_deck' : 'lenormand_deck';
    try {
        const item = await idb.get(dbName, cardData.id);
        if(item && item.data) {
            const frontEl = el.querySelector('.playing-card-front');
            frontEl.style.backgroundImage = `url(${item.data})`;
            if(cardData.type === 'tarot' && cardData.isReversed) {
                frontEl.style.transform = "rotateY(180deg) rotate(180deg)"; 
            }
        } else {
            el.querySelector('.playing-card-front').style.backgroundColor = '#fff';
            el.querySelector('.playing-card-front').innerText = `${cardData.type} #${cardData.id}`;
        }
    } catch(e) { console.error("Load card img failed", e); }
}
async function finishReadingAndGenerate() {
    if(flippedCards.length === 0) return alert("请至少翻开一张牌来感知能量！");
    
    closeCardTable();
    openNewspaperLoading(); 
   let apiKey = document.getElementById('api-key').value; 
    let apiUrl = document.getElementById('api-url').value;
    let model = document.getElementById('model-select').value;
    let temp = document.getElementById('api-temp').value;
    if (!apiKey) {
        try {
            const savedSettings = JSON.parse(localStorage.getItem('api_settings_draft') || '{}');
            apiKey = savedSettings.key;
            apiUrl = savedSettings.url;
            model = savedSettings.model;
            temp = savedSettings.temp;
        } catch(e) {}
    }

    if(!apiKey) {
        closeNewspaper();
        return alert("请先在桌面的 [设置] 中配置 API Key！");
    }
   
    let cardsDesc = flippedCards.map(c => {
        let name = "未知牌";
        let status = "";
        
        if (c.type === 'tarot') {
            name = TAROT_NAMES[c.id] || `塔罗#${c.id}`;
            status = c.isReversed ? " (逆位)" : " (正位)";
        } else if (c.type === 'lenormand') {
            name = LENORMAND_NAMES[c.id] || `雷诺曼#${c.id}`;
            status = ""; 
        }
        
        return `【${name}${status}】`;
    }).join(", ");
    const wb = getWBData();
    const globalContext = (wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    const newsContext = (wb['6.报纸'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n"); 
    let locationStr = `User's Real Location: ${currentCity}`; 
    let userPersona = (wb['1.全局'] || []).filter(i=>i.title.includes("人设") || i.title.includes("User")).map(i=>i.content).join("\n");
    const dateStr = new Date().toLocaleDateString();
    
    const realTemp = document.getElementById('real-temp').innerText;
    const realWeather = document.getElementById('real-desc').innerText;
    const prompt = `
你是一个连接两个世界的在新闻社工作多年的时空观测者。你擅长占卜解牌从细微的事情发现真相，你需要生成两篇真实的新闻报道。

【输入信息】
1. **抽出的命运牌组**：${cardsDesc}
2. **梦角世界设定**：${globalContext}
3. **报纸特别设定**：${newsContext}
4. **现实世界坐标**：
   - 地点：${currentCity} (必须基于此真实地点)
   - 日期：${dateStr}
   - 天气：${realWeather}
   - 用户线索：${userPersona}

【任务要求】
请生成两篇新闻：

1. **左侧新闻（梦角/异世界）**：
   - 根据【牌组】推测该世界今日的“能量流动”或“突发事件”。
   - 必须符合世界观（World Book）必须符合牌意。
   - **不需要一定围绕主角**，可以是世界各地的奇闻、政治变动或魔法异象。
   - 必须结合【梦角世界设定】。
   - 牌意放在最下面，在新闻中部不放置牌名牌意。新闻中部不能放牌名字仿真实新闻。

2. **右侧新闻（现实世界 - ${currentCity}）**：
   - **严格基于用户所在的真实城市 [${currentCity}]**。
   - 扮演一个本地新闻聚合器。根据今天的日期和城市，生成 1-2 条**真实发生或极具当地特色**的社会/生活新闻。
   - 如果不知道确切的今日突发新闻，请生成符合该城市当季特点的真实感新闻（例如：当地交通状况、当季气候影响、本地热门活动）。
   - 风格：现代、客观、简报风格。

【输出格式】
严格 JSON 格式，不要 Markdown：
{
  "dream_world": {
    "headline": "异界标题",
    "content": "内容..."
  },
  "real_world": {
    "headline": "现实标题 (${currentCity})",
    "content": "内容..."
  }
}
`;
    // 调用 API
    try {
        const res = await fetch(`${apiUrl}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model || "gpt-3.5-turbo",
                messages: [{ role: "system", content: "You are a creative writer." }, { role: "user", content: prompt }],
                temperature: parseFloat(temp) || 0.7
            })
        });
        const json = await res.json();
        const content = json.choices[0].message.content;
        
        let cleanJson = content.replace(/```json/g, "").replace(/```/g, "").trim();
        const result = JSON.parse(cleanJson);
        
        renderNewspaperContent(result);

    } catch(e) {
        console.error(e);
        alert("生成失败，请检查 API 设置或网络。\n" + e.message);
        closeNewspaper();
    }
}
function openNewspaperLoading() {
    const modal = document.getElementById('newspaper-modal');
     const now = new Date();
    const dateStr = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
    document.getElementById('news-date-display').innerText = `DATE: ${dateStr}`;
    modal.style.display = 'flex';
    document.getElementById('dream-news-content').innerHTML = '<div class="skeleton-text">正在根据星象与牌意解析彼岸的能量流动...</div>';
    document.getElementById('real-news-content').innerHTML = '<div class="skeleton-text">正在检索你所在维度的今日头条...</div>';
    document.getElementById('news-cards-display').innerHTML = '';
}

function closeNewspaper() {
    document.getElementById('newspaper-modal').style.display = 'none';
}

async function renderNewspaperContent(data) {
    document.getElementById('dream-news-content').innerHTML = `
        <h4>${data.dream_world.headline}</h4>
        <p>${data.dream_world.content.replace(/\n/g, "<br>")}</p>
    `;
    
    document.getElementById('real-news-content').innerHTML = `
        <h4>${data.real_world.headline}</h4>
        <p>${data.real_world.content.replace(/\n/g, "<br>")}</p>
    `;
    const cardStrip = document.getElementById('news-cards-display');
    cardStrip.innerHTML = '';
    
    for(let card of flippedCards) {
        const div = document.createElement('div');
        div.className = 'mini-card-display';
        const dbName = card.type === 'tarot' ? 'tarot_deck' : 'lenormand_deck';
        const item = await idb.get(dbName, card.id);
        if(item && item.data) {
            div.style.backgroundImage = `url(${item.data})`;
            if(card.type==='tarot' && card.isReversed) div.style.transform = "rotate(180deg)";
        }
        cardStrip.appendChild(div);
    }
}
let currentFinanceView = new Date().toISOString().slice(0, 7);
function getFinanceData() {
    return window.BIG_MEMORY.finance || [];
}
function openFinanceApp() {
    currentFinanceView = new Date().toISOString().slice(0, 7);
    document.getElementById('finance-modal').style.display = 'flex';
    document.getElementById('history-selector').style.display = 'none';
    renderFinanceUI();
}
function toggleHistorySelector() {
    const el = document.getElementById('history-selector');
    el.style.display = (el.style.display === 'none') ? 'block' : 'none';
    document.getElementById('finance-month-picker').value = currentFinanceView;
}
function changeFinanceDate(val) {
    if(val) {
        currentFinanceView = val;
        renderFinanceUI();
        document.getElementById('history-selector').style.display = 'none';
    }
}
function navFinanceDate(delta) {
    let [year, month] = currentFinanceView.split('-').map(Number);
    month += delta;
    if (month > 12) { month = 1; year++; }
    else if (month < 1) { month = 12; year--; }
    
    currentFinanceView = `${year}-${String(month).padStart(2, '0')}`;
    renderFinanceUI();
}

// 新增记录：参数增加了 category (分类名)
function addFinanceRecord(category, type) {
    const amountIn = document.getElementById('finance-amount');
    const val = parseFloat(amountIn.value);
    
    if (!val || val <= 0) {
        // 如果没填金额就点分类，简单提示一下
        alert("请先输入金额，再点击分类按钮入账。");
        return;
    }

    // 1. 获取随机描述 (小字)
    const thesaurus = getThesaurusData(); 
    // 根据类型去词库找词：支出去 expense 找，收入去 income 找
    const dictKey = type === 'expense' ? 'expense' : 'income';
    const words = thesaurus[dictKey] || [];
    
    // 如果词库有词，随机取一条；如果没有，显示默认文案
    const randomDesc = words.length > 0 
        ? words[Math.floor(Math.random() * words.length)] 
        : (type === 'expense' ? '今日支出' : '今日入账');
    const record = {
        id: Date.now(),
        date: new Date().toISOString(), 
        category: category,    
        type: type,                     // expense / income
        amount: val,
        desc: randomDesc             
    };

    const data = getFinanceData();
    data.unshift(record);
    localStorage.setItem('finance_data', JSON.stringify(data));
    amountIn.value = '';

    currentFinanceView = new Date().toISOString().slice(0, 7);
    renderFinanceUI();
}
function renderFinanceUI() {
    const data = getFinanceData(); // 获取所有账单数据
    const listEl = document.getElementById('finance-list');
    const chartEl = document.getElementById('finance-chart-area');
    
    // --- 新增代码开始：计算总资产 ---
    let totalAsset = parseFloat(localStorage.getItem('finance_initial_funds') || '0'); // 获取初始资金
    data.forEach(item => {
        if (item.type === 'income') totalAsset += item.amount;
        else totalAsset -= item.amount;
    });
    const totalDisplay = document.getElementById('finance-total-display');
    if(totalDisplay) totalDisplay.innerText = totalAsset.toFixed(2);
    // --- 新增代码结束 ---

    listEl.innerHTML = '';
    chartEl.innerHTML = '';
    document.getElementById('finance-current-date-display').innerText = currentFinanceView;
    
    // 下面是原有的月度统计逻辑，保持不变
    const currentMonthData = data.filter(item => item.date.startsWith(currentFinanceView));
    let monthIn = 0;
    let monthOut = 0;
    const catStats = {}; 

    currentMonthData.forEach(item => {
        const isExpense = item.type === 'expense';
        if (isExpense) monthOut += item.amount;
        else monthIn += item.amount;
        const catKey = item.category;
        if (!catStats[catKey]) catStats[catKey] = { amount: 0, type: item.type };
        catStats[catKey].amount += item.amount;
 
        const dateObj = new Date(item.date);
        const dateStr = `${dateObj.getMonth()+1}-${dateObj.getDate()} ${String(dateObj.getHours()).padStart(2,'0')}:${String(dateObj.getMinutes()).padStart(2,'0')}`;
        const sign = isExpense ? '-' : '+';
        const color = isExpense ? '#a33' : '#366';
        
        const div = document.createElement('div');
        div.className = 'morandi-card';
        div.style.padding = '10px';
        div.style.display = 'flex';
        div.style.justifyContent = 'space-between';
        div.style.alignItems = 'center';
        div.innerHTML = `
            <div style="display:flex; flex-direction:column;">
                <span style="font-weight:bold; color:#444; font-size:1rem;">${item.category}</span>
                <span style="font-size:0.7rem; color:#999; margin-top:2px;">
                    ${item.desc} · ${dateStr}
                </span>
            </div>
            <div style="font-weight:bold; font-family:'Courier New'; color:${color}; font-size:1.1rem;">
                ${sign}${item.amount.toFixed(2)}
            </div>
            <div style="margin-left:10px; color:#ccc; cursor:pointer; font-size:1.2rem;" onclick="deleteFinance(${item.id})">×</div>
        `;
        listEl.appendChild(div);
    });

    if(currentMonthData.length === 0) {
        listEl.innerHTML = `<div style="text-align:center; color:#ccc; padding:20px;">本月暂无账单</div>`;
    }
    document.getElementById('finance-month-in').innerText = monthIn.toFixed(2);
    document.getElementById('finance-month-out').innerText = monthOut.toFixed(2);
    const balance = monthIn - monthOut;
    document.getElementById('finance-month-balance').innerText = balance.toFixed(2);
    
    // 图表逻辑保持不变...
    let sortable = [];
    for (let c in catStats) {
        sortable.push([c, catStats[c].amount, catStats[c].type]);
    }
    sortable.sort((a, b) => b[1] - a[1]);

    if (sortable.length > 0) {
        const maxVal = sortable[0][1];
        sortable.forEach(([cat, val, type]) => {
            const percent = (val / maxVal) * 100;
            const barColor = type === 'expense' ? '#e8d7d7' : '#d4e8d7'; 
            const fillSubColor = type === 'expense' ? '#d4a5a5' : '#97a89e';
            const row = document.createElement('div');
            row.className = 'chart-row';
            row.innerHTML = `
                <div class="chart-label">${cat}</div>
                <div class="chart-bar-bg" style="background:${barColor}">
                    <div class="chart-bar-fill" style="width:${percent}%; background:${fillSubColor};"></div>
                </div>
                <div class="chart-val">${val.toFixed(0)}</div>
            `;
            chartEl.appendChild(row);
        });
    } else {
        chartEl.innerHTML = `<div style="text-align:center; color:#aaa;">无数据可统计</div>`;
    }
}

// --- 新增：设置初始资金的函数，直接粘贴在 renderFinanceUI 下面即可 ---
window.setInitialFunds = function() {
    const cur = localStorage.getItem('finance_initial_funds') || '0';
    const val = prompt("请输入初始资金金额 (例如: 10000):", cur);
    if (val !== null) {
        localStorage.setItem('finance_initial_funds', parseFloat(val) || 0);
        renderFinanceUI(); // 刷新界面
    }
};
function deleteFinance(id) {
    if (confirm("确定删除这条账目？")) {
        let data = getFinanceData();
        data = data.filter(i => i.id !== id);
        localStorage.setItem('finance_data', JSON.stringify(data));
        renderFinanceUI();
    }
}

let tarotState = {
    mode: 'tarot', 
    deck: [],      
    picked: [],   
    lastResult: null,
    // 新增易学状态
    hexagram: [] // 存储六爻结果 [6,7,8,9, ...]
};

function openTarotApp() {
    document.getElementById('tarot-app-modal').style.display = 'flex';

    if (!tarotState.deck || tarotState.deck.length === 0) {
        initTarotDeckData();
        renderTarotCards();  
    } else {
        
        renderTarotCards();
    }
    if(document.getElementById('tarot-result-area').style.display === 'none') {
        document.getElementById('tarot-desk-area').style.display = 'flex';
    }

    loadTarotHistory(); 
}

function closeTarotApp() {
    document.getElementById('tarot-app-modal').style.display = 'none';
}
function switchTarotMode() {
    tarotState.mode = document.getElementById('divination-mode').value;
    tarotState.hexagram = []; // 重置卦象
    document.getElementById('hexagram-lines').innerHTML = '';
    
    const isWestern = (tarotState.mode === 'tarot' || tarotState.mode === 'lenormand');
    
    // 切换桌面显示
    document.getElementById('tarot-desk-area').style.display = isWestern ? 'flex' : 'none';
    document.getElementById('iching-desk-area').style.display = isWestern ? 'none' : 'flex';
    
    if(isWestern) {
        initTarotDeckData();
        renderTarotCards();
    } else {
        // 显示对应的易学UI
        document.getElementById('liuyao-ui').style.display = (tarotState.mode === 'liuyao') ? 'flex' : 'none';
        document.getElementById('meihua-ui').style.display = (tarotState.mode === 'meihua') ? 'flex' : 'none';
    }
}
// --- 新增：六爻掷币 ---
function tossLiuyaoCoins() {
    if(tarotState.hexagram.length >= 6) return alert("六爻已成，请点击查看结果！");
    
    const coins = document.querySelectorAll('.coin');
    coins.forEach(c => {
        c.classList.remove('animate');
        void c.offsetWidth; // 触发重绘
        c.classList.add('animate');
    });

    setTimeout(() => {
        // 模拟掷币：字=背=3，花=面=2。
        // 3个硬币和：6(老阴X), 7(少阳), 8(少阴), 9(老阳O)
        let total = 0;
        coins.forEach(c => {
            const val = Math.random() > 0.5 ? 3 : 2;
            total += val;
            c.innerText = val === 3 ? "字" : "花";
        });
        
        tarotState.hexagram.push(total);
        renderHexagramLine(total, tarotState.hexagram.length);
        
        if(tarotState.hexagram.length === 6) {
            setTimeout(finishIchingReading, 500);
        }
    }, 500);
}

// --- 新增：渲染单条爻线 ---
function renderHexagramLine(val, index) {
    const container = document.getElementById('hexagram-lines');
    const div = document.createElement('div');
    div.className = `iching-line ${val % 2 === 0 ? 'line-yin' : 'line-yang'}`;
    div.style.position = 'relative';
    
    // 6和9是动爻
    const isMoving = (val === 6 || val === 9);
    const color = isMoving ? '#d4af37' : '#e2c2b3'; // 动爻金色
    
    let html = '';
    if(val % 2 === 0) { // 阴
        html = `<div class="line-part" style="background:${color}"></div><div class="line-part" style="background:${color}"></div>`;
    } else { // 阳
        html = `<div class="line-part" style="background:${color}"></div>`;
    }
    
    div.innerHTML = `<span class="line-label">${index}爻</span>` + html + (isMoving ? `<span style="position:absolute; right:-20px; color:${color}">O</span>` : '');
    container.appendChild(div);
}

// --- 新增：梅花易数逻辑 ---
function useCurrentTimeForMeihua() {
    const now = new Date();
    const n1 = now.getFullYear() + now.getMonth() + 1 + now.getDate();
    const n2 = now.getFullYear() + now.getMonth() + 1 + now.getDate() + now.getHours();
    finishMeihua(n1, n2);
}

function finishMeihua(n1, n2) {
    if(!n1) n1 = parseInt(document.getElementById('meihua-n1').value);
    if(!n2) n2 = parseInt(document.getElementById('meihua-n2').value);
    if(!n1 || !n2) return alert("请输入数字或使用时间");
    
    // 模拟存入数据，交给AI算具体的卦名，这里只存原始数
    tarotState.hexagram = [`梅花数: 上${n1} 下${n2}`]; 
    finishIchingReading();
}

function finishIchingReading() {
    document.getElementById('iching-desk-area').style.display = 'none';
    document.getElementById('tarot-result-area').style.display = 'flex';
    
    // 清空卡牌显示，显示卦象文本
    const header = document.getElementById('selected-cards-header');
    header.innerHTML = `<div style="font-size:1.5rem; font-weight:bold; color:#2c3e50;">
        ${tarotState.mode === 'liuyao' ? '六爻已成' : '梅花已起'}
    </div>`;
}

function resetIching() {
    tarotState.hexagram = [];
    document.getElementById('hexagram-lines').innerHTML = '';
    document.querySelectorAll('.coin').forEach(c => c.innerText = '🪙');
    document.getElementById('meihua-n1').value = '';
    document.getElementById('meihua-n2').value = '';
}
function initTarotDeckData() {
    tarotState.deck = [];
    tarotState.picked = [];
    const count = (tarotState.mode === 'tarot') ? 78 : 36;
    
    for(let i = 0; i < count; i++) {
        const cardId = (tarotState.mode === 'tarot') ? i : (i + 1);
        tarotState.deck.push({ 
            id: cardId, 
            visualRot: 0 
        });
    }
    updatePickedUI();
}
function renderTarotCards() {
    const container = document.getElementById('tarot-card-spread');
    container.innerHTML = ''; 

    tarotState.deck.forEach((card) => {
        const el = document.createElement('div');
        el.className = 'tarot-card-item';
        if(card.visualRot) {
            el.style.transform = `rotate(${card.visualRot}deg)`;
        }
        const inner = document.createElement('div');
        inner.className = 'tarot-card-inner';
        const pickedData = tarotState.picked.find(p => p.id === card.id);
        const isPicked = !!pickedData;
        const back = document.createElement('div');
        back.className = 't-card-back';
        const front = document.createElement('div');
        front.className = 't-card-front';
        if(isPicked) {
            el.classList.add('picked');                                 if(pickedData.isReversed) {
                front.style.transform = "rotateY(180deg) rotate(180deg)";
            } else {
                front.style.transform = "rotateY(180deg)";
            }

            loadCardImage(card.id, front);
        }

        inner.appendChild(back);
        inner.appendChild(front);
        el.appendChild(inner);
       
        el.onclick = () => pickTarotCard(el, card.id, front);
        
        container.appendChild(el);
    });
    
    updatePickedUI();
}
async function pickTarotCard(el, id, frontEl) {
    const existingIndex = tarotState.picked.findIndex(c => c.id === id);

    if (existingIndex !== -1) {
        el.classList.remove('picked');
        tarotState.picked.splice(existingIndex, 1);
        setTimeout(() => {
            frontEl.style.backgroundImage = '';
            frontEl.innerText = '';
            frontEl.style.transform = ''; 
        }, 600);
    } else {
        el.classList.add('picked');
        const isReversed = (tarotState.mode === 'tarot') ? (Math.random() < 0.3) : false;
        
        tarotState.picked.push({ id: id, isReversed: isReversed });
      
        if(isReversed) {
            frontEl.style.transform = "rotateY(180deg) rotate(180deg)";
        } else {
            frontEl.style.transform = "rotateY(180deg)";
        }
        loadCardImage(id, frontEl);
    }
    
    updatePickedUI();
}
function updatePickedUI() {
    const count = tarotState.picked.length;
    const countEl = document.getElementById('tarot-picked-count');
    if(countEl) countEl.innerText = count;

    const btn = document.getElementById('btn-tarot-finish');
    if(btn) btn.style.display = count > 0 ? 'block' : 'none';
}
function confirmShuffle() {
    tarotState.picked = [];
    
    const container = document.getElementById('tarot-card-spread');
    container.style.opacity = '0.5';
    
    setTimeout(() => {
        for (let i = tarotState.deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [tarotState.deck[i], tarotState.deck[j]] = [tarotState.deck[j], tarotState.deck[i]];
        }
        
        tarotState.deck.forEach(card => card.visualRot = Math.random() * 6 - 3);

        renderTarotCards();
        
        container.style.opacity = '1';
        container.scrollTop = 0; 
        backToDesk();
        
        document.getElementById('divine-question').value = '';
        document.getElementById('output-content').innerHTML = '';
        document.getElementById('divination-output').style.display = 'none';

    }, 200);
}
async function finishTarotSelection() {
    document.getElementById('tarot-desk-area').style.display = 'none';
    document.getElementById('tarot-result-area').style.display = 'flex';
    
    const header = document.getElementById('selected-cards-header');
    header.innerHTML = ''; 
    for(let card of tarotState.picked) {
  
        const div = document.createElement('div');
        div.className = 'result-card-display';
        const imgDiv = document.createElement('div');
        imgDiv.className = 'result-card-img';
        let name = (tarotState.mode === 'tarot') ? 
                   (TAROT_NAMES[card.id] || `#${card.id}`) : 
                   (LENORMAND_NAMES[card.id] || `#${card.id}`);
        const dbName = (tarotState.mode === 'tarot') ? 'tarot_deck' : 'lenormand_deck';
        try {
            const item = await idb.get(dbName, card.id);
            if(item && item.data) {
                imgDiv.style.backgroundImage = `url(${item.data})`;
            } else {
                imgDiv.style.backgroundColor = '#ddd';
                imgDiv.innerText = card.id;
                imgDiv.style.display = 'flex';
                imgDiv.style.alignItems = 'center';
                imgDiv.style.justifyContent = 'center';
            }
        } catch(e) {}

        if(card.isReversed) {
            imgDiv.style.transform = "rotate(180deg)";

            imgDiv.innerHTML = `<div class="reverse-tag">逆位</div>`;
        }

        const tag = document.createElement('div');
        tag.className = 'result-card-tag';
        tag.innerText = name;
        div.appendChild(imgDiv);
        div.appendChild(tag);
        
        header.appendChild(div);
    }
}
function backToDesk() {
    document.getElementById('tarot-result-area').style.display = 'none';
    document.getElementById('tarot-desk-area').style.display = 'flex';
}
async function loadCardImage(id, el) {
    const dbName = (tarotState.mode === 'tarot') ? 'tarot_deck' : 'lenormand_deck';
    try {
        const item = await idb.get(dbName, id);
        if(item && item.data) {
            el.style.backgroundImage = `url(${item.data})`;
            el.innerText = '';
        } else {
            el.innerText = id;
        }
    } catch(e) {}
}
function toggleDivineInput(val) {
    document.getElementById('manual-divine-box').style.display = (val === 'manual') ? 'block' : 'none';
}
async function startDivination() {
    const question = document.getElementById('divine-question').value || "无具体问题";
    const targetName = document.getElementById('divine-target').value || "对方"; 
    const statusInfo = document.getElementById('divine-status').value || "未知"; 
    const method = document.getElementById('divine-method').value;

    // --- 1. 准备基础数据 ---
    // 易学数据处理
    const isEastern = (tarotState.mode === 'liuyao' || tarotState.mode === 'meihua');
    const hexData = tarotState.hexagram.join(",");
    
    // 西方卡牌数据处理
    const cardsText = tarotState.picked.map(c => {
        const name = (tarotState.mode === 'tarot') ? TAROT_NAMES[c.id] : LENORMAND_NAMES[c.id];
        const pos = c.isReversed ? "逆位" : "正位";
        return `${name}(${pos})`;
    }).join(", ");

    // --- 2. 准备世界书上下文 (保持原逻辑) ---
    const wbData = getWBData();
    let worldContext = "";
    if(document.getElementById('wb-ctx-global')?.checked) {
        worldContext += `\n【世界观全局设定】:\n${(wbData['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n")}\n`;
    }
    if(document.getElementById('wb-ctx-tarot')?.checked && tarotState.mode === 'tarot') {
        worldContext += `\n【塔罗特殊设定】:\n${(wbData['3.塔罗牌'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n")}\n`;
    }
    if(document.getElementById('wb-ctx-lenormand')?.checked && tarotState.mode === 'lenormand') {
        worldContext += `\n【雷诺曼特殊设定】:\n${(wbData['4.雷诺曼'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n")}\n`;
    }
    if(document.getElementById('wb-ctx-iching')?.checked && isEastern) {
        const ichingText = (wbData['15.六爻'] || []).concat(wbData['16.梅花'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
        if(ichingText) worldContext += `\n【易学设定】:\n${ichingText}\n`;
    }
    if(document.getElementById('wb-ctx-char')?.checked) {
        worldContext += `\n【相关信件/人设】:\n${(wbData['13.信件'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n")}\n`;
    }

    // --- 3. UI 准备 ---
    const outputDiv = document.getElementById('divination-output');
    outputDiv.style.display = 'block';
    const contentDiv = document.getElementById('output-content');
    contentDiv.innerHTML = '<div class="skeleton-text">正在连接潜意识能量场...</div>';
    
    requestAnimationFrame(() => {
        const area = document.getElementById('tarot-result-area');
        if(area) area.scrollTop = area.scrollHeight;
    });

    if(method === 'manual') {
        const manualText = document.getElementById('manual-interpretation').value;
        contentDiv.innerHTML = `<div class="divination-md">${manualText.replace(/\n/g, '<br>')}</div>`;
        // 保存逻辑
        tarotState.lastResult = {
            date: new Date().toISOString(),
            question, targetName, cardsText: isEastern ? `[易学] ${hexData}` : cardsText, rawText: manualText, picked: tarotState.picked 
        };
        return;
    }

    // --- 4. 生成 Prompt (核心修复部分) ---
    // 这里的文本完全还原了你文件里的内容，只是修复了 if/else 的逻辑漏洞
    
    let systemPrompt = "";
    let userPrompt = "";

    if(method === 'ai_dream') {
        // === 分支 A: 易学 (六爻/梅花) ===
        if (isEastern) {
            const isDream = true;
            const typeName = tarotState.mode === 'liuyao' ? '六爻（纳甲筮法）' : '梅花易数';
            
            // 原版易学提示词
            systemPrompt = `你是一位精通《易经》的${isDream ? '梦占师（东方术士）' : '国学大师'}。
${worldContext}

【起卦数据】
类型：${typeName}
数据：[${hexData}] 
(若是六爻：6=老阴,7=少阳,8=少阴,9=老阳，请自行排盘装卦；若是梅花，请根据数字起卦)。

【任务】
1. **排盘**：简要说明本卦、变卦（如有）及卦名。
2. **梦角感知 (核心)**：
   - 请将卦象的“象”与“数”转化为感性的能量场。
   - 这个卦象代表了目标人物(${targetName})对用户怎样的潜意识流动？
   - 结合东方美学，用唯美的语言描述这种状态（如“如山下有火，内热外冷”）。
3. **回应问题**：针对“${question}”给出明确指引。
4. **灵魂传讯**：
   - 结尾用“${targetName}在冥冥中对你说：...”写一句符合卦意的话。

请输出 Markdown 格式。`;

            userPrompt = `求测人：我\n所测之事：${question}\n目标：${targetName}\n现状：${statusInfo}\n原始数据：${hexData}`;
        }
        
        // === 分支 B: 塔罗牌 (修复：加了 else if，防止和上面的冲突) ===
        else if (tarotState.mode === 'tarot') {
            // 原版塔罗提示词
            systemPrompt = `你是一位高阶塔罗梦占师（灵性传讯师）。
你的能力是透过塔罗牌，连接提问者（用户）与目标人物（${targetName}）的潜意识能量场。

${worldContext}

【任务目标】
解析用户抽到的牌面，洞察${targetName}对用户的真实想法、未说出口的潜意识以及双方能量的流动。

【解读逻辑】
1. **不做角色扮演**：你不是${targetName}，你是能看穿他内心的传讯师。请用客观、灵性、富有同理心的口吻叙述。
2. **结合牌义与心理**：不要只背诵书本上的牌义。解释这张牌出现在这里，代表了${targetName}什么样的心理活动。
3. **能量状态**：分析他现在的状态（是焦虑、回避、渴望还是平静？）。

【输出格式】
请务必按照以下 Markdown 格式输出：

🔮 **能量现状**
(简述几张牌反映出他目前的整体能量状态)

💭 **潜意识深窥**
(深度挖掘：他表面没说，但潜意识里对你的真实看法。结合“${statusInfo}”进行分析)

💌 **灵魂传讯 (Message)**
(作为传讯师，请翻译一句他灵魂深处此刻最想对用户说的话。用“他对你说：...”的格式)

✨ **指引与建议**
(给用户的行动建议)`;

            userPrompt = `
            目标人物：${targetName}
            关系现状：${statusInfo}
            用户疑问：${question}
            抽到的牌：${cardsText}
            
            请开始解析。`;
        } 
        
        // === 分支 C: 雷诺曼 (修复：放在最后的 else) ===
        else {
            // 原版雷诺曼提示词
            systemPrompt = `你现在不是一个死板的解牌机器，而是一位能看穿灵魂的【梦境传讯者】。
你拥有关于雷诺曼（Lenormand）所有流派的庞大知识库，以及深厚的梦境心理学知识。

${worldContext}

【当前情境】
用户在梦占仪式中抽到了这组符号：【${cardsText}】。

【核心指令】
1. **不要**使用“这张牌代表...”这种教科书式的语言。
2. **调用你的大数据直觉**：请将这几张牌视为出现在${targetName}梦里的意象。
3. **梦占风格**：解读应该像解析一个梦。它是流动的、感性的、甚至带有一点朦胧的诗意。
4. **回应问题**：针对用户的问题“${question}”，用${targetName}的口吻给出回应。
5. **第三人称**：你不是${targetName}。但你要知晓表达出${targetName}渴望、犹豫、占有欲或回避等真实的人性。

【输出要求】
- 字数250字左右。
- 分析牌意，在最结尾用“他对你说：...”的格式生成一句他灵魂深处此刻最想对用户说的话。`;

            userPrompt = `
            目标：${targetName}
            现状：${statusInfo}
            问题：${question}
            符号：${cardsText}
            
            请开始梦境传讯。`;
        }
    } 
    // === 传统模式 (ai_trad) ===
    else {
        systemPrompt = `你是一位专业的占卜师。${worldContext}\n请根据牌面/卦象理性分析用户的问题。`;
        if (isEastern) {
             userPrompt = `数据：${hexData}\n问题：${question}\n请进行传统断卦分析。`;
        } else {
             userPrompt = `用户问题：${question}\n目标：${targetName}\n关系：${statusInfo}\n抽牌：${cardsText}\n请给出详细解读。`;
        }
    }

    // --- 5. API 调用 ---
    let apiKey = document.getElementById('api-key').value;
    let apiUrl = document.getElementById('api-url').value;
    let model = document.getElementById('model-select').value;
    
    // 尝试读取缓存
    if(!apiKey) {
        try {
            const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}');
            apiKey = s.key; apiUrl = s.url; model = s.model;
        } catch(e){}
    }
    if(!apiKey) {
        contentDiv.innerHTML = "❌ 请先配置 API Key";
        return alert("请先在桌面的 [设置] 中配置 API Key！");
    }

    try {
        const res = await fetch(`${apiUrl || "https://api.openai.com/v1"}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model || "gpt-3.5-turbo",
                messages: [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: userPrompt }
                ],
                temperature: 0.8
            })
        });
        const json = await res.json();
        const rawText = json.choices[0].message.content;
        
        // 格式化输出
        const htmlText = rawText
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/🔮/g, '<br><br>🔮')
            .replace(/💭/g, '<br><br>💭')
            .replace(/💌/g, '<br><br>💌')
            .replace(/✨/g, '<br><br>✨')
            .replace(/\n/g, '<br>');

        contentDiv.innerHTML = `<div class="divination-md">${htmlText}</div>`;
        
        // 保存结果
        tarotState.lastResult = {
            date: new Date().toISOString(),
            question, targetName, cardsText: isEastern ? `[易学] ${hexData}` : cardsText,
            rawText: rawText,
            picked: tarotState.picked 
        };

    } catch(e) {
        console.error(e);
        contentDiv.innerHTML = `<span style="color:red">连接中断: ${e.message}</span>`;
    }
}
function toggleTarotHistory() {
    const p = document.getElementById('tarot-history-panel');
    p.classList.toggle('open');
    if(p.classList.contains('open')) loadTarotHistory();
}

function loadTarotHistory() {
    const list = document.getElementById('tarot-history-list');
    list.innerHTML = '';
    const history = JSON.parse(localStorage.getItem('tarot_history') || '[]');
    
    if(history.length === 0) {
        list.innerHTML = "<div style='padding:10px; color:#999; text-align:center;'>暂无记录</div>";
        return;
    }

    history.forEach((h, i) => {
        const date = new Date(h.date).toLocaleDateString();
        const div = document.createElement('div');
        div.className = 'morandi-card';
        div.style.padding = '10px';
        div.innerHTML = `
            <div style="font-size:0.8rem; color:#888;">${date}</div>
            <div style="font-weight:bold; color:#2c3e50;">Q: ${h.question}</div>
            <div style="font-size:0.75rem; color:#666; margin:5px 0;">🎴 ${h.cardsText}</div>
            <div style="display:flex; justify-content:flex-end; gap:10px;">
                <button class="m-btn small" onclick="viewHistoryDetail(${i})">查看</button>
                <button class="m-btn small" style="color:red;" onclick="deleteTarotHistory(${i})">×</button>
            </div>
        `;
        list.appendChild(div);
    });
}
async function viewHistoryDetail(index) {
    const h = JSON.parse(localStorage.getItem('tarot_history'))[index];
    
    document.getElementById('tarot-desk-area').style.display = 'none';
    document.getElementById('tarot-result-area').style.display = 'flex';
    document.getElementById('divination-output').style.display = 'block';
    

    const htmlText = h.rawText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>');
    document.getElementById('output-content').innerHTML = `<div class="divination-md">${htmlText}</div>`;
    document.getElementById('divine-question').value = h.question;
    document.getElementById('divine-target').value = h.targetName || "";
    
    document.getElementById('tarot-history-panel').classList.remove('open');
}
function deleteTarotHistory(index) {
    if(!confirm("遗忘这段记忆？")) return;
    const history = JSON.parse(localStorage.getItem('tarot_history') || '[]');
    history.splice(index, 1);
    localStorage.setItem('tarot_history', JSON.stringify(history));
    loadTarotHistory();
}

let currentLetterId = null;
let currentGiftData = null; 
function getLetters() { return JSON.parse(localStorage.getItem('letter_history') || '[]'); }
function saveLetters(data) { localStorage.setItem('letter_history', JSON.stringify(data)); }
const ASTRO_SYMBOLS = {

    "太阳": "☉", "月亮": "☽", "水星": "☿", "金星": "♀", "火星": "♂",
    "木星": "♃", "土星": "♄", "天王": "♅", "海王": "♆", "冥王": "♇",
    "北交": "☊", "南交": "☋",
    "白羊": "♈", "金牛": "♉", "双子": "♊", "巨蟹": "♋", "狮子": "♌", "处女": "♍",
    "天秤": "♎", "天蝎": "♏", "射手": "♐", "摩羯": "♑", "水瓶": "♒", "双鱼": "♓",
    "1宫": "Ⅰ", "2宫": "Ⅱ", "3宫": "Ⅲ", "4宫": "Ⅳ", "5宫": "Ⅴ", "6宫": "Ⅵ",
    "7宫": "Ⅶ", "8宫": "Ⅷ", "9宫": "Ⅸ", "10宫": "Ⅹ", "11宫": "Ⅺ", "12宫": "Ⅻ"
};

function getAstroSymbol(text) {
    if(!text) return "?";
    const key = text.split(' ')[0]; 
    return ASTRO_SYMBOLS[key] || "?";
}
// === 1. 修复信件输入时狂跳通知 ===
function handleLetterInput(el) {
    el.style.height = 'auto'; 
    el.style.height = (el.scrollHeight + 5) + 'px'; 
    
    if (!currentLetterId) return;
    
    const content = el.value;
    const letters = window.getLetters(); // 使用无限存储的获取方式
    const idx = letters.findIndex(x => x.id === currentLetterId);
    
    if (idx !== -1) {
        letters[idx].content = content;
        window.saveLetters(letters); // 使用无限存储的保存方式
        
        // ❌ 【删除】原来这里有一段 NotificationManager.send 的代码，删掉它！
        // 因为用户正在打字，不应该发通知。
    }
}
async function renderVisualDice(diceData) {
    const container = document.getElementById('dice-visual-container');
    if(!container) return; 
    container.innerHTML = '';

    if (!diceData) return;
    const pSym = getAstroSymbol(diceData.planet);
    const sSym = getAstroSymbol(diceData.sign);
    const hSym = getAstroSymbol(diceData.house);

    const createDie = (sym, text) => {
        return `<div class="astro-cube">${sym}<span>${text.split(' ')[0]}</span></div>`;
    };

    container.innerHTML += createDie(pSym, diceData.planet);
    container.innerHTML += createDie(sSym, diceData.sign);
    container.innerHTML += createDie(hSym, diceData.house);

    const div = document.createElement('div');
    div.className = 'mini-tarot-vis';
    div.innerHTML = `
        <div style="font-size:1.5rem;">🎴</div>
        <span style="margin-top:2px;">${diceData.tarotName}</span>
    `;
    
    div.style.backgroundImage = 'none'; 
    div.style.backgroundColor = 'rgba(0,0,0,0.05)';
    div.style.display = 'flex';
    div.style.flexDirection = 'column';
    div.style.justifyContent = 'center';
    div.style.alignItems = 'center';
    
    container.appendChild(div);
}
function openLetterApp() {
    document.getElementById('letter-app-modal').style.display = 'flex';
    renderLetterList();
    backToLetterList(); 
}
function closeLetterApp() { document.getElementById('letter-app-modal').style.display = 'none'; }

function renderLetterList() {
    const listEl = document.getElementById('letter-history-list');
    listEl.innerHTML = '';
    const letters = getLetters();
    letters.sort((a,b) => b.timestamp - a.timestamp);

    letters.forEach(l => {
        const div = document.createElement('div');
        div.className = 'letter-item';
        const dateStr = new Date(l.timestamp).toLocaleDateString();
        const preview = l.content.substring(0, 15) + (l.content.length>15 ? '...' : '');
        div.innerHTML = `
            <div>
                <span style="font-weight:bold;">${dateStr}</span>
                <span style="color:#888; margin-left:10px; font-size:1rem;">${preview || "新信件"}</span>
            </div>
            <div style="font-size:1rem;">${l.hasReply ? '📥 已回复' : '📝 草稿'}</div>
        `;
        div.onclick = () => openLetterDetail(l.id);
        listEl.appendChild(div);
    });
}
function createNewLetter() {
    currentLetterId = Date.now();
    const l = { id: currentLetterId, timestamp: Date.now(), content: "", hasReply: false, giftData: null };
    const letters = getLetters();
    letters.push(l);
    saveLetters(letters);
    openLetterDetail(currentLetterId);
}
function openLetterDetail(id) {
    currentLetterId = id;
    const letters = getLetters();
    const l = letters.find(x => x.id === id);
    if (!l) return;
    document.getElementById('letter-list-view').style.display = 'none';
    document.getElementById('letter-write-view').style.display = 'flex';
    document.getElementById('letter-date').innerText = new Date(l.timestamp).toLocaleDateString();
    const textArea = document.getElementById('letter-content');
    textArea.value = l.content;
    const replySheet = document.getElementById('reply-sheet');
    const sendBtn = document.getElementById('btn-send-letter');
    const footerGiftBtn = document.getElementById('btn-footer-gift');
    const footerRegenBtn = document.getElementById('btn-footer-regen');

    if (l.hasReply && l.diceResult) {
        
        replySheet.style.display = 'flex'; 
        replySheet.style.position = 'relative'; 
        sendBtn.style.display = 'none';    
        
        renderVisualDice(l.diceResult);
        document.getElementById('reply-content-display').innerText = l.replyContent || "内容加载错误";
        currentGiftData = l.giftData; 
        const oldStamp = document.getElementById('dynamic-stamp-entry');
        if (oldStamp) oldStamp.remove();

        (async () => {
            let stampsRes = await idb.get('settings_heavy', 'reply_stamps');
            
            if (stampsRes && stampsRes.data && stampsRes.data.length > 0) {
                if(footerGiftBtn) footerGiftBtn.style.display = 'none';
                
                const stampList = stampsRes.data;

                if (!l.stampData) { 
                    const randIdx = Math.floor(Math.random() * stampList.length);
                    l.stampData = { 
                        url: stampList[randIdx], 
                        angle: Math.random() * 40 - 20, 
                       
                        opacity: 0.4 + Math.random() * 0.4, 
                        top: 50 + Math.random() * 20, 
                        left: 40 + Math.random() * 30 
                    };
                    
                    const allLetters = getLetters();
                    const targetData = allLetters.find(x => x.id === currentLetterId);
                    if(targetData) { 
                        targetData.stampData = l.stampData; 
                        saveLetters(allLetters); 
                    }
                }
                const stampDiv = document.createElement('div');
                stampDiv.id = 'dynamic-stamp-entry'; 
                stampDiv.className = 'reply-stamp-gift'; 
                
                stampDiv.style.backgroundImage = `url(${l.stampData.url})`;
                stampDiv.style.transform = `translateX(-50%) rotate(${l.stampData.angle}deg)`;
                stampDiv.style.opacity = l.stampData.opacity;
                stampDiv.style.top = l.stampData.top + '%';
                stampDiv.style.left = l.stampData.left + '%';
                stampDiv.onclick = (e) => {
                    e.stopPropagation(); 
                    openGiftModal();
                };
                
                replySheet.appendChild(stampDiv);
                
            } else {

                if(footerGiftBtn) footerGiftBtn.style.display = 'block';
            }
        })();

    } else {
        replySheet.style.display = 'none'; 
        sendBtn.style.display = 'block';   
        sendBtn.innerText = "📮 寄出 (投掷占星骰)";
        sendBtn.disabled = false;
        currentGiftData = null;
        
        if(footerGiftBtn) footerGiftBtn.style.display = 'block';
    }

    setTimeout(() => {
        textArea.style.height = 'auto';
        textArea.style.height = (textArea.scrollHeight + 50) + 'px'; 

        const container = document.querySelector('.letter-write-container');
        if (l.hasReply) {
            container.scrollTop = container.scrollHeight;
        } else {
            container.scrollTop = 0;
        }
    }, 100);
}
function rollAstroDice() {
    const planets = ["太阳 Sun", "月亮 Moon", "水星 Mercury", "金星 Venus", "火星 Mars", "木星 Jupiter", "土星 Saturn", "天王 Uranus", "海王 Neptune", "冥王 Pluto", "北交 N.Node", "南交 S.Node"];
    const signs = ["白羊 Aries", "金牛 Taurus", "双子 Gemini", "巨蟹 Cancer", "狮子 Leo", "处女 Virgo", "天秤 Libra", "天蝎 Scorpio", "射手 Sagittarius", "摩羯 Capricorn", "水瓶 Aquarius", "双鱼 Pisces"];
    const houses = ["1宫 Self", "2宫 Money", "3宫 Comm", "4宫 Home", "5宫 Love", "6宫 Health", "7宫 Rel", "8宫 Death", "9宫 Travel", "10宫 Career", "11宫 Social", "12宫 Spirit"];
    const keys = Object.keys(TAROT_NAMES);
    const randomKey = keys[Math.floor(Math.random() * keys.length)];
    const randomTarot = TAROT_NAMES[randomKey] || "愚人";

    return {
        planet: planets[Math.floor(Math.random() * planets.length)],
        sign: signs[Math.floor(Math.random() * signs.length)],
        house: houses[Math.floor(Math.random() * houses.length)],
        tarotName: randomTarot
    };
}
// === 信件系统修复版 Start ===

let letterDeck = [];
let letterPickedCards = [];
let pendingRegenMode = false; // 记录是新写还是重写

// 1. 点击“寄出”按钮触发：打开牌桌
function generateReplyLetter(isRegen = false) {
    const content = document.getElementById('letter-content').value;
    if(!content) return alert("请先写下信件内容...");
    
    pendingRegenMode = isRegen;
    
    // 【关键修复】：这里 ID 改为和你 HTML 底部一致的 letter-card-table-modal
    const modal = document.getElementById('letter-card-table-modal');
    const area = document.getElementById('letter-card-area');
    
    if(!modal || !area) return alert("错误：找不到信件牌桌组件，请检查HTML代码");

    area.innerHTML = '';
    letterDeck = [];
    letterPickedCards = [];
    document.getElementById('letter-flipped-count').innerText = '0';

    // 生成 78张塔罗 + 36张雷诺曼
    for(let i=0; i<=77; i++) letterDeck.push({ type: 'tarot', id: i, isReversed: Math.random() < 0.3 });
    for(let i=1; i<=36; i++) letterDeck.push({ type: 'lenormand', id: i, isReversed: false });
    letterDeck.sort(() => Math.random() - 0.5);

    // 渲染卡牌布局
    const deskW = window.innerWidth;
    const cardWidth = 60, cardHeight = 90, gapX = 10, gapY = 15;
    let columns = Math.floor((deskW - 20) / (cardWidth + gapX));
    if (columns < 4) columns = 4;
    const startX = Math.max(0, (deskW - (columns * cardWidth + (columns - 1) * gapX)) / 2);
    const startY = 60;

    letterDeck.forEach((card, index) => {
        const el = document.createElement('div');
        el.className = 'playing-card';
        const colIndex = index % columns;
        const rowIndex = Math.floor(index / columns);
        
        el.style.left = (startX + colIndex * (cardWidth + gapX)) + 'px';
        el.style.top = (startY + rowIndex * (cardHeight + gapY)) + 'px';
        el.style.transform = `rotate(${Math.random() * 6 - 3}deg)`;
        
        // 绑定点击翻牌事件
        el.onclick = () => flipLetterCard(el, card);
        
        const front = document.createElement('div');
        front.className = 'playing-card-front';
        el.appendChild(front);
        area.appendChild(el);
    });
    
    const totalRows = Math.ceil(letterDeck.length / columns);
    area.style.height = (startY + totalRows * (cardHeight + gapY) + 120) + 'px';
    
    // 应用皮肤
    idb.get('settings_heavy', 'tarot_table').then(res => {
        if(res && res.data) area.parentElement.style.backgroundImage = `url(${res.data})`;
    });

    modal.style.display = 'flex';
}

// 2. 翻牌逻辑
async function flipLetterCard(el, cardData) {
    if(el.classList.contains('flipped')) {
        el.classList.remove('flipped');
        letterPickedCards = letterPickedCards.filter(c => !(c.type === cardData.type && c.id === cardData.id));
    } else {
        el.classList.add('flipped');
        letterPickedCards.push(cardData);
        // 加载图片
        const dbName = cardData.type === 'tarot' ? 'tarot_deck' : 'lenormand_deck';
        try {
            const item = await idb.get(dbName, cardData.id);
            const frontEl = el.querySelector('.playing-card-front');
            if (item && item.data) {
                frontEl.style.backgroundImage = `url(${item.data})`;
                frontEl.innerText = '';
            } else {
                frontEl.style.backgroundColor = '#ddd';
                frontEl.innerText = cardData.id;
            }
            // 处理逆位旋转
            if(cardData.type === 'tarot' && cardData.isReversed) {
                frontEl.style.transform = "rotateY(180deg) rotate(180deg)";
            } else {
                frontEl.style.transform = "rotateY(180deg)";
            }
        } catch(e) {}
    }
    document.getElementById('letter-flipped-count').innerText = letterPickedCards.length;
}

// 3. 最终确认生成：融合了“翻牌判定”和“原版高质量礼物逻辑”
async function finishLetterReading() {
    // 1. 检查是否翻牌
    if(letterPickedCards.length === 0) return alert("请至少翻开一张牌来感知Ta的状态！");
    
    // 2. 关闭弹窗 & UI 准备
    document.getElementById('letter-card-table-modal').style.display = 'none'; // 修正了ID
    
    const sendBtn = document.getElementById('btn-send-letter');
    const replyDisplay = document.getElementById('reply-content-display');
    const content = document.getElementById('letter-content').value;
    
    if(!pendingRegenMode) {
        sendBtn.disabled = true; 
        sendBtn.innerText = "⏳ 正在解析牌意与星象...";
    } else {
        replyDisplay.innerHTML = "<span class='skeleton-text'>正在根据牌意重新连接...</span>";
    }

    // 3. 准备数据
    // (A) 骰子数据：决定回信的语气基调 + 礼物的核心灵感 (这是原版逻辑的核心)
    let dice = pendingRegenMode ? 
        (getLetters().find(x=>x.id===currentLetterId)?.diceResult || rollAstroDice()) 
        : rollAstroDice();
    
    // (B) 翻牌数据：只用来决定“是否已读” (New Logic)
    const tableCardsDesc = letterPickedCards.map(c => (c.type==='tarot'?TAROT_NAMES[c.id]:LENORMAND_NAMES[c.id]) + (c.isReversed?"(逆)":"")).join(", ");
    
    // (C) 世界书数据
    const wb = getWBData();
    const globalText = (wb['1.全局'] || []).filter(i => i.enabled).map(i => i.content).join("\n");
    const letterText = (wb['13.信件'] || []).filter(i => i.enabled).map(i => i.content).join("\n");

    // 4. API Key 检查
    let apiKey = document.getElementById('api-key').value;
    let apiUrl = document.getElementById('api-url').value;
    let model = document.getElementById('model-select').value;
    if(!apiKey) {
        try { const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}'); apiKey = s.key; apiUrl = s.url; model = s.model; } catch(e){}
    }
    if(!apiKey) return alert("请先配置 API Key");

    // 5. === 核心 Prompt：完美复刻原版礼物逻辑 + 新增阅读判定 ===
    const prompt = `
你现在是世界书中的角色。
${globalText}
【信件设定】: ${letterText}

【用户来信】: ${content}

【神秘学能量场】
1. **状态判定牌** (判断是否已读): ${tableCardsDesc}
2. **回信基调/礼物指引** (骰子&塔罗): ${dice.planet} / ${dice.sign} / ${dice.house} / 塔罗牌灵感: ${dice.tarotName}

【任务流程】
**第一步：判定状态**
根据【状态判定牌】判断角色此刻是否已读信件？
- 牌意积极/行动/沟通 (如权杖、战车、骑士、书、信) -> 已读 (Read)。
- 牌意消极/阻碍/隐没 (如宝剑4、倒吊人、高塔、云、山、棺材) -> 未读 (Unread)。

**第二步：生成内容 (分情况)**

👉 **情形 A：如果判定为 [已读] (Read)**
请执行**最高规格**的回信生成：
1. **回信正文**：
   - 必须用仿手写体口吻，语气严格符合【占星骰子】的基调 (例如火星白羊冲动，土星摩羯克制)。不少于300字，并且模仿真人写信习惯。
   - 内容要回应用户的信。
2. **附赠礼物** (Original Logic)：
   - **必须**是一个具体的实体物品 (Specific Physical Item)。
   - 灵感来源：**必须结合** 【塔罗牌灵感: ${dice.tarotName}】 和 【占星骰子】 的含义。
   - 例如：星币牌可能送胸针/钱币，圣杯可能送饮料/香水，宝剑可能送钢笔/裁纸刀。
3. **礼物随笔 (Gift Essay)** (重点)：
   - 写一段**不少于150字**的、第三人称视角的、优美感性的随笔。
   - 详细描述这个礼物的样子、光泽、触感、气味。
   - 描述角色为什么要送这个礼物 (情感动机)。
4. **礼物理由**: 简短解释神秘学关联。
5. **价格**: 估算价格。

👉 **情形 B：如果判定为 [未读] (Unread)**
- 仅生成一段简短的系统提示或心理旁白，解释为什么没看信 (太忙、没收到、心情不好不敢看)。
- 不需要生成礼物。

【输出格式】
严格 JSON 格式：
{
  "status": "read" 或 "unread",
  "reply_content": "如果是已读，写回信正文；如果是未读，写未读原因...",
  "gift_essay": "如果是已读，在此处写那段150字+的优美礼物随笔；未读则留空字符串",
  "gift_reason": "如果是已读，写礼物与牌意的关联理由；未读则留空",
  "gift_price": "如果是已读，写价格；未读则留空"
}
`;

    try {
        const res = await fetch(`${apiUrl || "https://api.openai.com/v1"}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model || "gpt-3.5-turbo",
                messages: [{ role: "system", content: "You are a creative writer. Output JSON only." }, { role: "user", content: prompt }],
                temperature: 0.8
            })
        });
        
        const json = await res.json();
        let raw = json.choices[0].message.content.replace(/```json/g, "").replace(/```/g, "").trim();
        // 容错处理：防止AI偶尔返回带markdown的代码块
        const firstBrace = raw.indexOf('{');
        const lastBrace = raw.lastIndexOf('}');
        if(firstBrace !== -1 && lastBrace !== -1) raw = raw.substring(firstBrace, lastBrace+1);
        
        const result = JSON.parse(raw);

        // 保存逻辑
        const letters = getLetters();
        const idx = letters.findIndex(x => x.id === currentLetterId);
        
        if(idx !== -1) {
            letters[idx].content = content;
            letters[idx].hasReply = true;
            letters[idx].diceResult = dice;
            
            // 根据状态处理
            if (result.status === 'unread') {
                // 未读：特殊前缀 + 无礼物
                letters[idx].replyContent = `【🚫 对方尚未阅读】\n\n🔮 阻碍牌：${tableCardsDesc}\n\n${result.reply_content}`;
                letters[idx].giftData = null;
                letters[idx].stampData = null; 
            } else {
                // 已读：保存完整的原版礼物数据
                letters[idx].replyContent = result.reply_content;
                letters[idx].giftData = {
                    essay: result.gift_essay, // 这里就是那段长文随笔
                    reason: result.gift_reason,
                    price: result.gift_price
                };
            }
            
            saveLetters(letters); // 自动无限存储
            
            // 通知
            NotificationManager.send({
                title: result.status === 'unread' ? "📭 信件未送达" : "📬 收到回信与礼物",
                body: result.status === 'unread' ? "似乎有些状况..." : "附带了一份特别的礼物...",
                onClick: () => { openLetterApp(); openLetterDetail(currentLetterId); }
            });
        }
        
        openLetterDetail(currentLetterId);

    } catch(e) {
        console.error(e);
        alert("生成失败: " + e.message);
        replyDisplay.innerText = "连接中断...";
    } finally {
        sendBtn.disabled = false;
        sendBtn.innerText = "📮 寄出 (投掷占星骰)";
    }
}
// === 信件系统修复版 End ===
function openGiftModal() {
    if(!currentGiftData) return alert("还没有收到礼物哦，请先寄出信件生成。");
    
    document.getElementById('gift-modal').style.display = 'flex';
    document.getElementById('gift-content-text').innerHTML = currentGiftData.essay.replace(/\n/g, '<br>');
    document.getElementById('gift-reason-text').innerText = currentGiftData.reason;

    document.getElementById('gift-price-display').innerText = currentGiftData.price || "$♾️ (LOVE)";
} 
function backToLetterList() {
    document.getElementById('letter-write-view').style.display = 'none';
    document.getElementById('letter-list-view').style.display = 'flex';
    renderLetterList(); 
}
function deleteCurrentLetter() {
    if (!currentLetterId) return;
    
    if (confirm("确定要销毁这封信吗？此操作无法撤销。")) {
        let letters = getLetters();
        letters = letters.filter(l => l.id !== currentLetterId);
        saveLetters(letters);
        backToLetterList();
    }
}

let currentTheaterId = null; 
let theaterTheme = 'day';   
async function openTheaterApp() {
    const modal = document.getElementById('theater-modal');
    modal.style.display = 'flex';
    
    const history = await getTheaterHistory();
    if (!currentTheaterId) {
        if (history.length > 0) {
            await loadTheater(history[0].id);
        } else {
            await startNewTheater(); 
        }
    } else {
        await renderTheaterContent();
    }
}

function closeTheaterApp() {
    document.getElementById('theater-modal').style.display = 'none';
}
function toggleTheaterTheme() {
    const modal = document.getElementById('theater-modal');
    modal.classList.remove('theater-theme-day', 'theater-theme-night', 'theater-theme-green');

    if (theaterTheme === 'day') {
        theaterTheme = 'night';
        modal.classList.add('theater-theme-night');
    } else if (theaterTheme === 'night') {
        theaterTheme = 'green';
        modal.classList.add('theater-theme-green');
    } else {
        theaterTheme = 'day';
        modal.classList.add('theater-theme-day');
    }
}
async function getTheaterHistory() {
    try {
        const res = await idb.get('theater_data', 'history_list');
        if (!res) {
            const old = JSON.parse(localStorage.getItem('theater_list') || '[]');
            if (old.length > 0) {
                await saveTheaterHistory(old); 
                console.log("已将旧剧本目录迁移至大容量数据库");
            }
            return old;
        }
        return res.data;
    } catch(e) { return []; }
}

async function saveTheaterHistory(list) {
    await idb.put('theater_data', { id: 'history_list', data: list });
    localStorage.removeItem('theater_list');
}

async function getTheaterContent(id) {
    try {
        const res = await idb.get('theater_data', `content_${id}`);
        if (!res) {
            const old = JSON.parse(localStorage.getItem(`theater_content_${id}`) || '[]');
            if (old.length > 0) {
                await saveTheaterContent(id, old);
                console.log(`已将剧本[${id}]内容迁移至大容量数据库`);
            }
            return old;
        }
        return res.data;
    } catch(e) { return []; }
}

async function saveTheaterContent(id, content) {
    await idb.put('theater_data', { id: `content_${id}`, data: content });
    localStorage.removeItem(`theater_content_${id}`);
}
async function startNewTheater() {
    const id = Date.now().toString();
    const list = await getTheaterHistory();
    
    const newBook = {
        id: id,
        title: "新篇章 " + new Date().toLocaleDateString(),
        date: Date.now(),
        preview: "等待书写..."
    };
    
    list.unshift(newBook);
    await saveTheaterHistory(list);
    await saveTheaterContent(id, []); 
    
    currentTheaterId = id;
    await renderTheaterContent();
    const panel = document.getElementById('theater-history-panel');
    if (panel.classList.contains('open')) panel.classList.remove('open');
}
async function loadTheater(id) {
    currentTheaterId = id;
    await renderTheaterContent();
    document.getElementById('theater-history-panel').classList.remove('open');
}
async function renderTheaterContent() {
    if (!currentTheaterId) return;
    const content = await getTheaterContent(currentTheaterId);
    const container = document.getElementById('theater-content-list');
    container.innerHTML = '';

    if (content.length === 0) {
        container.innerHTML = `
            <div style="text-align:center; margin-top:100px; opacity:0.6;">
                <div style="font-size:3rem; margin-bottom:10px;">✒️</div>
                <p>在下方输入第一段指引<br>开始你的故事</p>
            </div>`;
        return;
    }

    content.forEach((segment, index) => {
        const div = document.createElement('div');
        div.className = 'novel-segment';
        let htmlText = segment.text.split('\n').map(p => p.trim() ? `<p>${p}</p>` : '').join('');
        
        if (segment.role === 'user') {
            div.style.borderLeft = "3px solid var(--th-accent)";
            div.style.paddingLeft = "10px";
            div.style.fontSize = "0.95rem";
            div.style.opacity = "0.8";
            div.innerHTML = `<strong>[指令]</strong> ${htmlText}`;
        } else {
            div.innerHTML = htmlText;
        }

        const delBtn = document.createElement('div');
        delBtn.className = 'segment-del-btn';
        delBtn.innerText = '🗑️ 删除本段';
        delBtn.onclick = () => deleteTheaterSegment(index);
        
        div.appendChild(delBtn);
        container.appendChild(div);
    });

    setTimeout(() => {
        const area = document.getElementById('theater-scroll-area');
        area.scrollTop = area.scrollHeight;
    }, 100);
}
async function deleteTheaterSegment(index) {
    if (!confirm("确定删除这一段内容吗？")) return;
    const content = await getTheaterContent(currentTheaterId);
    content.splice(index, 1);
    await saveTheaterContent(currentTheaterId, content);
    await renderTheaterContent();
}
async function toggleTheaterHistory() {
    const panel = document.getElementById('theater-history-panel');
    panel.classList.toggle('open');
    if (panel.classList.contains('open')) {
        await renderTheaterHistoryList();
    }
}

async function renderTheaterHistoryList() {
    const list = await getTheaterHistory();
    const container = document.getElementById('theater-history-list');
    container.innerHTML = '';
    
    list.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'morandi-card';
        div.style.padding = '10px';
        div.style.cursor = 'pointer';
        if (item.id === currentTheaterId) div.style.border = "2px solid var(--th-accent)";
        
        div.innerHTML = `
            <div style="font-weight:bold; font-size:1rem;">${item.title}</div>
            <div style="font-size:0.8rem; color:#888; margin-top:5px;">${new Date(item.date).toLocaleDateString()}</div>
            <div style="display:flex; justify-content:flex-end; margin-top:5px;">
                <button class="m-btn small" onclick="event.stopPropagation(); deleteTheaterBook(${index})" style="background:#ff6b6b; color:white;">删除</button>
            </div>
        `;
        div.onclick = () => loadTheater(item.id);
        container.appendChild(div);
    });
}

async function deleteTheaterBook(index) {
    if (!confirm("删除整本剧本？不可恢复。")) return;
    const list = await getTheaterHistory();
    const id = list[index].id;
    await idb.delete('theater_data', `content_${id}`);
    
    list.splice(index, 1);
    await saveTheaterHistory(list);
    
    if (id === currentTheaterId) {
        currentTheaterId = null;
        document.getElementById('theater-content-list').innerHTML = '';
    }
    await renderTheaterHistoryList();
}
async function generateTheaterSegment() {
    const inputEl = document.getElementById('th-input');
    const userText = inputEl.value.trim();
    const currentContent = await getTheaterContent(currentTheaterId);

    if (!userText && currentContent.length === 0) {
        return alert("请先输入开篇设定或第一句话。");
    }

    const btn = document.getElementById('btn-th-gen');
    const scrollArea = document.getElementById('theater-scroll-area');
    const originalBtnText = btn.innerText;
    btn.disabled = true;
    btn.innerText = "生成中...";
    
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'th-loading';
    loadingDiv.innerText = "正在构思剧情 (Hidden CoT running)...";
    document.getElementById('theater-content-list').appendChild(loadingDiv);
    scrollArea.scrollTop = scrollArea.scrollHeight;

    const wb = getWBData();
    let worldContext = "";
    if (document.getElementById('th-use-global').checked) {
        worldContext += "【世界观(全局)】:\n" + ((wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n")) + "\n";
    }
    if (document.getElementById('th-use-theater').checked) {
        worldContext += "【剧场设定】:\n" + ((wb['2.小剧场'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n")) + "\n";
    }

    const recentHistory = currentContent.slice(-20).map(h => {
        return h.role === 'user' ? `[用户指令]: ${h.text}` : `[小说正文]: ${h.text}`;
    }).join("\n\n");

    const systemPrompt = `你是一位顶级的轻小说作家。
你正在与用户共同创作一部小说。

【世界设定】
${worldContext}

【核心规则】
1. **视角严格限制**：
   - 对用户（User）必须使用**第二人称“你”**。
   - 对其他所有角色使用**第三人称有限视角**。
2. **绝对禁令**：
   - **绝对禁止**描写“你”（用户）没有明确输入的语言、动作、心理活动。
   - 如果用户没有输入动作，请描写环境变化、NPC的主动行为、或者突发事件，然后**停下来等待用户的反应**。
3. **写作风格**：
   - 轻小说风格（Light Novel）。
   - 注重环境描写、NPC的微表情、氛围渲染。
   - **长文输出**：请尽可能详细，每次输出不少于3000汉字。
4. **思维链**：
   - 在生成正文前，你可以先在内心思考剧情走向，但这部分不需要输出给用户。

【当前用户指令】
${userText || "（用户示意继续剧情，请根据上下文自然续写）"}`;

    let apiKey = "", apiUrl = "", model = "";
    try {
        const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}');
        apiKey = s.key; apiUrl = s.url; model = s.model;
    } catch(e){}
    if (!apiKey) apiKey = document.getElementById('api-key').value;
    if (!apiUrl) apiUrl = document.getElementById('api-url').value;
    if (!model) model = document.getElementById('model-select').value;

    if (!apiKey) {
        loadingDiv.remove();
        btn.disabled = false; btn.innerText = originalBtnText;
        return alert("请先在设置中配置 API Key！");
    }

    if (apiUrl && apiUrl.endsWith('/')) apiUrl = apiUrl.slice(0, -1);
    if (!apiUrl) apiUrl = "https://api.openai.com/v1";

    try {
        const res = await fetch(`${apiUrl}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model || "gpt-3.5-turbo",
                messages: [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: `【前文回顾】\n${recentHistory}\n\n【最新指令】\n${userText}` }
                ],
                temperature: 0.8
            })
        });

        const json = await res.json();
        if (json.error) throw new Error(json.error.message || "API Error");
        if (!json.choices || json.choices.length === 0) throw new Error("API 返回空内容");
        
        const aiText = json.choices[0].message.content;
        if (userText) currentContent.push({ role: 'user', text: userText });
        currentContent.push({ role: 'ai', text: aiText });
        await saveTheaterContent(currentTheaterId, currentContent);
        const list = await getTheaterHistory();
        const listItem = list.find(i => i.id === currentTheaterId);
        if (listItem) {
            listItem.preview = aiText.substring(0, 30) + "...";
            await saveTheaterHistory(list);
        }

        loadingDiv.remove();
        await renderTheaterContent();
        inputEl.value = '';

    } catch (e) {
        console.error(e);
        loadingDiv.innerText = "生成失败: " + e.message;
        loadingDiv.style.color = "red";
    } finally {
        btn.disabled = false;
        btn.innerText = originalBtnText;
    }
}

let currentForumId = null; 
async function openForumApp() {
    document.getElementById('forum-modal').style.display = 'flex';
    
    const history = await getForumHistory();
    if (!currentForumId) {
        if (history.length > 0) {
            await loadForum(history[0].id);
        } else {
            document.getElementById('forum-content-container').innerHTML = `
                <div style="text-align:center; margin-top:100px; color:#999;">
                    <div style="font-size:3rem; opacity:0.3;">💬</div>
                    <p>输入关键词，生成论坛体小说<br>每次生成约20-40楼，支持无限续写</p>
                </div>`;
        }
    } else {
        await renderForumContent();
    }
}

function closeForumApp() {
    document.getElementById('forum-modal').style.display = 'none';
}
async function getForumHistory() {
    try {
        const res = await idb.get('forum_data', 'history_list');
        return res ? res.data : [];
    } catch(e) { return []; }
}

async function saveForumHistory(list) {
    await idb.put('forum_data', { id: 'history_list', data: list });
}

async function getForumContent(id) {
    try {
        const res = await idb.get('forum_data', `thread_${id}`);
        return res ? res.data : null; // data 结构: { title, posts: [] }
    } catch(e) { return null; }
}

async function saveForumContent(id, data) {
    await idb.put('forum_data', { id: `thread_${id}`, data: data });
}
async function startNewForum() {
    currentForumId = null;
    document.getElementById('forum-input').value = '';
    document.getElementById('forum-content-container').innerHTML = `
        <div style="text-align:center; margin-top:100px; color:#999;">
            <div style="font-size:3rem; opacity:0.3;">💬</div>
            <p>准备就绪。<br>输入标题或梗概开始发帖。</p>
        </div>`;
    document.getElementById('forum-history-panel').classList.remove('open');
}
async function loadForum(id) {
    currentForumId = id;
    await renderForumContent();
    document.getElementById('forum-history-panel').classList.remove('open');
}
async function renderForumContent() {
    if (!currentForumId) return;
    const thread = await getForumContent(currentForumId);
    if (!thread) return;

    const container = document.getElementById('forum-content-container');
    container.innerHTML = '';
    const header = document.createElement('div');
    header.className = 'forum-thread-header';
    header.innerHTML = `<div class="forum-title-text">${thread.title}</div>`;
    container.appendChild(header);
    thread.posts.forEach((post, index) => {
        const row = document.createElement('div');
        row.className = 'forum-post-row';
        let avatarHtml = '';
        if (index === 0) {
            const avatarColor = stringToColor(post.name);
            avatarHtml = `
            <div class="forum-avatar" style="background-color:${avatarColor}; display:flex; align-items:center; justify-content:center; color:white; font-weight:bold; font-size:1.2rem;">
                ${post.name[0]}
            </div>`;
        }
        
        const isLZ = (post.name === thread.lzName) || (index === 0);
        
        row.innerHTML = `
            ${avatarHtml} 
            <div class="forum-content-col">
                <div class="forum-user-line">
                    <div>
                        <span class="forum-username">${post.name}</span>
                        ${isLZ ? '<span class="forum-lz-tag">楼主</span>' : ''}
                    </div>
                    <span class="forum-floor-num">${index + 1}楼</span>
                </div>
                <div class="forum-text-body">${post.content}</div>
                <div class="forum-action-bar">
                    <span class="forum-icon-btn">👍 ${Math.floor(Math.random()*100)}</span>
                    <span class="forum-icon-btn">💬 回复</span>
                    <span class="forum-icon-btn" style="color:#ff6b6b; font-size:0.7rem; margin-left:auto;" onclick="deleteForumPost(${index})">删除</span>
                </div>
            </div>
        `;
        container.appendChild(row);
    });
    setTimeout(() => {
        const area = document.getElementById('forum-scroll-area');
        area.scrollTop = area.scrollHeight;
    }, 100);
}
function stringToColor(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = str.charCodeAt(i) + ((hash << 5) - hash);
    }
    const c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
    return '#' + "00000".substring(0, 6 - c.length) + c;
}
async function deleteForumPost(index) {
    if(!confirm("删除此楼层？")) return;
    const thread = await getForumContent(currentForumId);
    thread.posts.splice(index, 1);
    await saveForumContent(currentForumId, thread);
    await renderForumContent();
}
function toggleForumHistory() {
    const panel = document.getElementById('forum-history-panel');
    panel.classList.toggle('open');
    if (panel.classList.contains('open')) renderForumHistoryList();
}

async function renderForumHistoryList() {
    const list = await getForumHistory();
    const container = document.getElementById('forum-history-list');
    container.innerHTML = '';
    
    list.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'morandi-card';
        div.style.padding = '10px';
        div.style.cursor = 'pointer';
        if (item.id === currentForumId) div.style.border = "2px solid #00d2d3";
        
        div.innerHTML = `
            <div style="font-weight:bold; font-size:1rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${item.title}</div>
            <div style="font-size:0.8rem; color:#888; margin-top:5px;">${new Date(item.date).toLocaleDateString()}</div>
            <div style="display:flex; justify-content:flex-end; margin-top:5px;">
                <button class="m-btn small" onclick="event.stopPropagation(); deleteForumThread(${index})" style="background:#ff6b6b; color:white;">删除</button>
            </div>
        `;
        div.onclick = () => loadForum(item.id);
        container.appendChild(div);
    });
}

async function deleteForumThread(index) {
    if(!confirm("删除整个帖子？")) return;
    const list = await getForumHistory();
    const id = list[index].id;
    await idb.delete('forum_data', `thread_${id}`);
    list.splice(index, 1);
    await saveForumHistory(list);
    if(id === currentForumId) startNewForum();
    renderForumHistoryList();
}
async function generateForumThread() {
    const inputEl = document.getElementById('forum-input');
    const userText = inputEl.value.trim();
    const btn = document.getElementById('btn-forum-gen');
    const roleType = document.getElementById('forum-role-select').value; 
    let isContinuation = !!currentForumId;
    let currentThread = isContinuation ? await getForumContent(currentForumId) : null;

    if (!isContinuation && !userText) {
        return alert("新帖子必须输入标题或内容梗概！");
    }

    const originalText = btn.innerText;
    btn.disabled = true;
    btn.innerText = "生成中(较慢)...";

    // 【防卡死 1】强制等待 50ms，让 UI 先渲染出“生成中”状态，避免点击瞬间浏览器冻结
    await new Promise(r => setTimeout(r, 50));

    // --- 以下保持原生成逻辑 ---
    const wb = getWBData();
    let context = "";
    if(document.getElementById('forum-use-global').checked) {
        context += "【世界观(全局)】:\n" + ((wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n")) + "\n";
    }
    if(document.getElementById('forum-use-forum').checked) {
        context += "【论坛体设定】:\n" + ((wb['7.论坛体'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n")) + "\n";
    }
    
    let previousContext = "";
    if (isContinuation && currentThread) {
        const lastPosts = currentThread.posts.slice(-15); // 取最后15条上下文
        previousContext = "【前文摘要】:\n帖子标题：" + currentThread.title + "\n";
        previousContext += lastPosts.map((p,i) => `[${p.name}]: ${p.content}`).join("\n");
        previousContext += "\n(请接续上面的讨论，不要重复)";
    }

    const modePrompt = roleType === 'user' 
        ? "楼主是【主角/用户自己】，请发帖求助或吐槽，引发路人围观。" 
        : "楼主是【NPC/路人】，正在讨论关于主角或世界观发生的八卦/事件。";

    // 保持原 Prompt 核心
    const systemPrompt = `你是一个论坛体小说生成器。
${context}

【任务】
根据用户输入，生成一个逼真的论坛帖子。
风格要求：网络用语、玩梗、甚至有杠精、不同立场的路人。
${modePrompt}

【格式要求】
**必须**严格输出 JSON 数组格式，不要包含Markdown代码块标记。
结构如下：
[
  {"name": "楼主ID", "content": "主楼内容..."},
  {"name": "路人A", "content": "回复内容..."},
  ...
]

【数量要求】
**请尽力一次性生成不少于 20 个回复（楼层）**。如果话题火爆，内容要丰富，甚至包含撕逼、歪楼。`;

    let apiKey = "", apiUrl = "", model = "";
    try {
        const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}');
        apiKey = s.key; apiUrl = s.url; model = s.model;
    } catch(e){}
    if (!apiKey) apiKey = document.getElementById('api-key').value;
    if (!apiUrl) apiUrl = document.getElementById('api-url').value;
    if (!model) model = document.getElementById('model-select').value;

    if (!apiKey) {
        btn.disabled = false; btn.innerText = originalText;
        return alert("API Key 未配置！");
    }

    try {
        const res = await fetch(`${apiUrl}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model || "gpt-3.5-turbo",
                messages: [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: `${previousContext}\n\n【本次指令】: ${userText || "继续热烈讨论，增加更多楼层"}` }
                ],
                temperature: 0.8,
                max_tokens: 3500
            })
        });

        const json = await res.json();
        let raw = json.choices[0].message.content;

        // 【JSON 增强逻辑 1】清洗 Markdown 标记
        raw = raw.replace(/```json/gi, "").replace(/```/g, "").trim();

        // 【JSON 增强逻辑 2】寻找数组边界 (防止 AI 在 JSON 前后说废话)
        const firstBracket = raw.indexOf('[');
        const lastBracket = raw.lastIndexOf(']');
        
        if (firstBracket !== -1 && lastBracket !== -1) {
            raw = raw.substring(firstBracket, lastBracket + 1);
        } else if (raw.startsWith('{')) {
            // 如果 AI 只生成了一个对象而不是数组，强制包裹
            raw = `[${raw}]`;
        }

        let newPosts = [];
        try {
            newPosts = JSON.parse(raw);
        } catch(e) {
            console.warn("JSON解析失败，尝试修复...", e);
            // 【JSON 增强逻辑 3】终极兜底：如果解析还是失败，把原始内容作为一条系统消息显示出来，防止用户白等
            newPosts = [{
                name: "System_Error", 
                content: "解析格式出错，原始返回如下：\n" + raw.substring(0, 200) + "..."
            }];
        }

        // 保存逻辑保持不变
        if (!isContinuation) {
            const id = Date.now().toString();
            const title = userText.substring(0, 20) + (userText.length>20?"...":"");
            const lzName = newPosts.length > 0 ? newPosts[0].name : "匿名用户";
            
            const newThread = { id: id, title: title, lzName: lzName, posts: newPosts };
            await saveForumContent(id, newThread);
            
            const list = await getForumHistory();
            list.unshift({ id: id, title: title, date: Date.now() });
            await saveForumHistory(list);
            currentForumId = id;
        } else {
            currentThread.posts = currentThread.posts.concat(newPosts);
            await saveForumContent(currentForumId, currentThread);
        }
        inputEl.value = ''; 
        await renderForumContent();

    } catch(e) {
        console.error(e);
        alert("生成失败: " + e.message);
    } finally {
        btn.disabled = false;
        btn.innerText = originalText;
    }
}
const DEFAULT_FRIDGE = {
    condiments: {
        "耗油": false, "生抽": false, "盐": false, "糖": false, 
        "醋": false, "料酒": false, "油": false
    },
    staples: {
        "米": false, 
        "面": null, // null表示无，字符串表示数量描述
        "面包": null 
    },
    vegetables: [], //Array of {name, count}
    meat: []        //Array of {name, count}
};
const CONDIMENT_ICONS = {
    "耗油": "🫙", "生抽": "🍾", "盐": "🧂", "糖": "🍬",
    "醋": "🏺", "料酒": "🍶", "油": "🛢️"
};

function getFridgeData() {
    return JSON.parse(localStorage.getItem('fridge_data') || JSON.stringify(DEFAULT_FRIDGE));
}
function saveFridgeData(data) {
    localStorage.setItem('fridge_data', JSON.stringify(data));
}
function openFridgeApp() {
    document.getElementById('fridge-modal').style.display = 'flex';
    renderFridgeContent();
}
function closeFridgeApp() {
    document.getElementById('fridge-modal').style.display = 'none';
}
function renderFridgeContent() {
    const data = getFridgeData();
    const s1 = document.getElementById('new-shelf-condiments');
    s1.innerHTML = '';
    const bottleClasses = {
        "耗油": "b-dark", "生抽": "b-black", "盐": "b-white", "糖": "b-white",
        "醋": "b-black", "料酒": "b-wine", "油": "b-oil"
    };

    for (let [name, has] of Object.entries(data.condiments)) {
        const div = document.createElement('div');
        const colorClass = bottleClasses[name] || "b-white";
        div.className = `flat-bottle ${colorClass} ${has ? 'active' : ''}`;
        
        div.innerHTML = `
            <div class="bottle-shape"></div>
            <div class="bottle-name">${name}</div>
        `;
        div.onclick = () => toggleCondiment(name);
        s1.appendChild(div);
    }
    const s2 = document.getElementById('new-shelf-staples');
    s2.innerHTML = '';
    const riceDiv = document.createElement('div');
    riceDiv.className = `staple-icon-btn ${data.staples['米'] ? 'active' : ''}`;
    riceDiv.innerHTML = `
        <div class="staple-img">🍚</div>
        ${data.staples['米'] ? '<div class="staple-badge">有</div>' : ''}
        <div class="staple-label">米饭</div>
    `;
    riceDiv.onclick = () => toggleRice();
    s2.appendChild(riceDiv);
    const noodleDiv = document.createElement('div');
    const hasNoodle = !!data.staples['面'];
    noodleDiv.className = `staple-icon-btn ${hasNoodle ? 'active' : ''}`;
    noodleDiv.innerHTML = `
        <div class="staple-img">🍜</div>
        ${hasNoodle ? `<div class="staple-badge">${data.staples['面']}</div>` : ''}
        <div class="staple-label">面条</div>
    `;
    noodleDiv.onclick = () => editStaple('面', '请输入面的数量 (如: 4把)');
    s2.appendChild(noodleDiv);
    const breadDiv = document.createElement('div');
    const hasBread = !!data.staples['面包'];
    breadDiv.className = `staple-icon-btn ${hasBread ? 'active' : ''}`;
    breadDiv.innerHTML = `
        <div class="staple-img">🍞</div>
        ${hasBread ? `<div class="staple-badge">${data.staples['面包']}</div>` : ''}
        <div class="staple-label">面包</div>
    `;
    breadDiv.onclick = () => editStaple('面包', '请输入面包数量', true);
    s2.appendChild(breadDiv);
    renderNewTags('new-shelf-veg', data.vegetables, 'veg');
    renderNewTags('new-shelf-meat', data.meat, 'meat');
}

function renderNewTags(containerId, list, type) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    list.forEach((item, index) => {
        const tag = document.createElement('div');
        tag.className = 'ing-tag-pill';
        tag.innerHTML = `
            <span>${item.name}</span>
            <span class="count">${item.count}</span>
            <span class="del-x" onclick="event.stopPropagation(); editIngredient('${type}', ${index})">×</span>
        `;
        container.appendChild(tag);
    });
    const addBtn = document.createElement('div');
    addBtn.className = 'add-circle-btn';
    addBtn.innerText = '+';
    addBtn.onclick = () => addIngredient(type);
    container.appendChild(addBtn);
}
function toggleCondiment(name) {
    const data = getFridgeData();
    data.condiments[name] = !data.condiments[name];
    saveFridgeData(data);
    renderFridgeContent();
}

function toggleRice() {
    const data = getFridgeData();
    data.staples['米'] = !data.staples['米'];
    saveFridgeData(data);
    renderFridgeContent();
}

function editStaple(key, promptText, isNumber = false) {
    const data = getFridgeData();
    const current = data.staples[key];
    if (current) {
        if (confirm(`当前: ${current}。要修改数量吗？(取消则删除)`)) {
            const val = prompt(promptText, current);
            if (val) data.staples[key] = val;
        } else {
            data.staples[key] = null; 
        }
    } else {
        const val = prompt(promptText);
        if (val) data.staples[key] = val;
    }
    saveFridgeData(data);
    renderFridgeContent();
}

function addIngredient(type) {
    const name = prompt("请输入食材名字:");
    if (!name) return;
    const count = prompt("数量/重量:", "1");
    if (!count) return;

    const data = getFridgeData();
    const list = type === 'veg' ? data.vegetables : data.meat;
    list.push({ name, count });
    saveFridgeData(data);
    renderFridgeContent();
}

function editIngredient(type, index) {
    const data = getFridgeData();
    const list = type === 'veg' ? data.vegetables : data.meat;
    const item = list[index];

    if (confirm(`要删除 ${item.name} 吗？\n点击[取消]仅修改数量。`)) {
        list.splice(index, 1);
    } else {
        const newCount = prompt(`修改 ${item.name} 的数量:`, item.count);
        if (newCount) item.count = newCount;
    }
    saveFridgeData(data);
    renderFridgeContent();
}

async function startWeChatCall() {
    const data = getFridgeData();
    const hasStaple = Object.values(data.staples).some(v => v);
    const hasIng = data.vegetables.length > 0 || data.meat.length > 0;
    
    if (!hasStaple && !hasIng) {
        return alert("冰箱空空如也，巧妇难为无米之炊呀！(请先添加食材)");
    }
    const overlay = document.getElementById('wechat-call-overlay');
    overlay.style.display = 'flex';
    const heavy = await idb.get('settings_heavy', 'botAvatar');
    if (heavy && heavy.data) {
        document.getElementById('wx-call-avatar').style.backgroundImage = `url(${heavy.data})`;
    } else {
        document.getElementById('wx-call-avatar').style.backgroundColor = '#555'; 
    }
    const settings = JSON.parse(localStorage.getItem('chat_settings') || '{}');
    document.getElementById('wx-call-name').innerText = settings.title || "私家大厨";
    const statusEl = document.getElementById('wx-call-status');
    const subEl = document.getElementById('wx-call-subtitle');
    statusEl.innerText = "等待对方接听...";
    subEl.style.display = 'none';
    subEl.innerHTML = '';

    setTimeout(async () => {
        statusEl.innerText = "通话中 00:01";
        let sec = 1;
        window.callTimerInterval = setInterval(() => {
            sec++;
            const m = Math.floor(sec / 60).toString().padStart(2,'0');
            const s = (sec % 60).toString().padStart(2,'0');

            if(statusEl.innerText.includes("通话中")) {
                statusEl.innerText = `通话中 ${m}:${s}`;
            }
        }, 1000);
        const loadingTip = setTimeout(() => { statusEl.innerText = "对方正在思考..."; }, 500);
        
        await generateWeChatRecipe(data);
        
        clearTimeout(loadingTip);
        statusEl.innerText = `通话中 ${Math.floor(sec/60).toString().padStart(2,'0')}:${(sec%60).toString().padStart(2,'0')}`;

    }, 1500); 
}
function endWeChatCall() {
    document.getElementById('wechat-call-overlay').style.display = 'none';
    if (window.callTimerInterval) clearInterval(window.callTimerInterval);
    if (window.pendingRecipeNote) {

        saveFridgeHistory({
            dish_name: window.pendingRecipeNote.dish_name,
            dialogue: window.pendingRecipeNote.dialogue, 
            shopping_advice: window.pendingRecipeNote.simple_recipe 
        });

        // 2. 准备显示的文本 (组合：通话回顾 + 简易菜谱)
        const combinedContent = `【📞 通话回顾】\n${window.pendingRecipeNote.dialogue}\n\n----------------\n\n【🥣 简易菜谱】\n${window.pendingRecipeNote.simple_recipe}`;
        document.getElementById('note-detail-title').innerText = window.pendingRecipeNote.dish_name;
        document.getElementById('note-detail-content').innerText = combinedContent;
        document.getElementById('note-detail-date').innerText = new Date().toLocaleDateString();
        document.getElementById('sticky-note-modal').style.display = 'flex';
        window.pendingRecipeNote = null; 
        renderFridgeHistory();
    }
}
async function generateWeChatRecipe(fridgeData) {
    const subEl = document.getElementById('wx-call-subtitle'); 
    const condiments = Object.keys(fridgeData.condiments).filter(k => fridgeData.condiments[k]).join(', ');
    const staples = Object.keys(fridgeData.staples).filter(k => fridgeData.staples[k]).map(k => `${k}(${fridgeData.staples[k] || '有'})`).join(', ');
    const veg = fridgeData.vegetables.map(i => `${i.name}x${i.count}`).join(', ');
    const meat = fridgeData.meat.map(i => `${i.name}x${i.count}`).join(', ');
    const wb = getWBData();
    let context = (wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    const fridgeCtx = (wb['9.冰箱'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n"); 
    let apiKey = "", apiUrl = "", model = "";
    try {
        const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}');
        apiKey = s.key; apiUrl = s.url; model = s.model;
    } catch(e){}
    if (!apiKey) apiKey = document.getElementById('api-key').value;
    if (!apiUrl) apiUrl = document.getElementById('api-url').value;
    if (!model) model = document.getElementById('model-select').value;

    const currentCity = window.currentCity || "未知城市";

    const prompt = `
你现在正在和用户通电话，指导她做饭。
请扮演世界书中的角色。
${context}
${fridgeCtx}

【用户冰箱库存】
调料: ${condiments}
主食: ${staples}
蔬菜: ${veg}
肉类: ${meat}
用户位置: ${currentCity}

【任务】
1. **角色扮演对话**：
   - 就像在打电话一样，手把手教用户怎么做这顿饭（选一个主菜+主食）。
   - **购物建议**：在对话过程中，自然地根据用户所在城市(${currentCity})，提到下次可以去买点什么食材会让饭更好吃，要表现出关心。
   - 语气要完全符合人设。

2. **简易食谱便签**：
   - 这是用户挂电话后记在纸条上的内容。
   - 只包含：菜名、极简步骤（1.2.3.）、所需材料。不要废话。

【输出格式】
严格 JSON 格式：
{
  "dish_name": "菜名",
  "dialogue": "完整的通话内容（包含教学、关心和购物建议）...",
  "simple_recipe_note": "简易食谱内容"
}
`;

    try {
        const res = await fetch(`${apiUrl}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model || "gpt-3.5-turbo",
                messages: [
                    { role: "system", content: "You are a helpful assistant." },
                    { role: "user", content: prompt }
                ],
                temperature: 0.7
            })
        });

        const json = await res.json();
        if (json.error) throw new Error(json.error.message);

        let raw = json.choices[0].message.content;
        raw = raw.replace(/```json/g, "").replace(/```/g, "").trim();
        const result = JSON.parse(raw);
        subEl.style.display = 'block';
        let i = 0;
        subEl.innerText = "";
        const txt = result.dialogue;
        
        const typeLoop = setInterval(() => {
            subEl.innerText += txt.charAt(i);
            subEl.scrollTop = subEl.scrollHeight; 
            i++;
            if (i >= txt.length) clearInterval(typeLoop);
        }, 70);
        window.pendingRecipeNote = {
            dish_name: result.dish_name,
            dialogue: result.dialogue,           
            simple_recipe: result.simple_recipe_note 
        };

    } catch(e) {
        console.error(e);
        subEl.style.display = 'block';
        subEl.innerText = "信号中断: " + e.message;
        window.pendingRecipeNote = null;
    }
}
function getFridgeHistory() {
    return JSON.parse(localStorage.getItem('fridge_history') || '[]');
}

function saveFridgeHistory(record) {
    const list = getFridgeHistory();
    list.unshift({
        date: Date.now(),
        ...record
    });
    localStorage.setItem('fridge_history', JSON.stringify(list));
}

function toggleFridgeHistory() {
    const p = document.getElementById('fridge-history-panel');
    p.classList.toggle('open');
    if (p.classList.contains('open')) renderFridgeHistory();
}

function renderFridgeHistory() {
    const list = getFridgeHistory();
    const container = document.getElementById('fridge-history-list');
    container.innerHTML = '';

    list.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'morandi-card';
        div.style.padding = '10px';
        div.innerHTML = `
            <div style="font-weight:bold;">${item.dish_name}</div>
            <div style="font-size:0.8rem; color:#888;">${new Date(item.date).toLocaleDateString()}</div>
            <div style="font-size:0.85rem; margin-top:5px; height:40px; overflow:hidden;">${item.dialogue}</div>
            <button class="m-btn small" onclick="deleteFridgeHistory(${index})" style="margin-top:5px; background:#ff6b6b; color:white; width:100%;">删除</button>
        `;
                div.onclick = (e) => {
            if(e.target.tagName !== 'BUTTON') {
                document.getElementById('note-detail-title').innerText = item.dish_name;
                document.getElementById('note-detail-content').innerText = `【你家的大厨嘱咐】\n${item.dialogue}\n\n【购物建议】\n${item.shopping_advice || '无'}`;
                document.getElementById('note-detail-date').innerText = new Date(item.date).toLocaleDateString();
                document.getElementById('sticky-note-modal').style.display = 'flex';
            }
        };
        container.appendChild(div);
    });
}

function deleteFridgeHistory(index) {
    if(!confirm("删除这条记录？")) return;
    const list = getFridgeHistory();
    list.splice(index, 1);
    localStorage.setItem('fridge_history', JSON.stringify(list));
    renderFridgeHistory();
}
window.toggleFridgeHistory = function() {
    const p = document.getElementById('fridge-history-panel');

    p.classList.toggle('open');
    
    if (p.classList.contains('open')) {
        renderFridgeHistory();
    }
};
window.renderFridgeHistory = function() {
    const list = getFridgeHistory();
    const container = document.getElementById('fridge-history-list');
    container.innerHTML = '';

    if (list.length === 0) {
        container.innerHTML = '<div style="text-align:center; color:#999; margin-top:20px; font-size:0.9rem;">暂无便签<br>打个电话给大厨试试？</div>';
        return;
    }

    list.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'sticky-paper'; 
        div.style.cursor = 'pointer';
        const previewText = item.shopping_advice || item.dialogue || '...';

        div.innerHTML = `
            <div style="font-weight:bold; font-size:1.1rem; margin-bottom:5px; border-bottom:1px dashed rgba(0,0,0,0.1); padding-bottom:5px;">
                ${item.dish_name || '未知菜谱'}
            </div>
            <div style="font-size:0.8rem; color:#8d6e63; margin-bottom:5px;">
                ${new Date(item.date).toLocaleDateString()}
            </div>
            <div style="font-size:0.9rem; line-height:1.4; opacity:0.9; max-height:60px; overflow:hidden; text-overflow:ellipsis;">
                ${previewText}
            </div>
            <button class="m-btn small" onclick="event.stopPropagation(); deleteFridgeHistory(${index})" 
                style="position:absolute; top:5px; right:5px; background:transparent; color:#d32f2f; border:none; font-size:1.2rem; padding:0;">×</button>
        `;
        div.onclick = () => {
            document.getElementById('note-detail-title').innerText = item.dish_name;
            
            // 拼接显示内容：通话记录 + 分割线 + 菜谱
            const fullContent = `【📞 通话回顾】\n${item.dialogue}\n\n------------------\n\n【🥣 简易菜谱】\n${item.shopping_advice || '无'}`;
            
            document.getElementById('note-detail-content').innerText = fullContent;
            document.getElementById('note-detail-date').innerText = new Date(item.date).toLocaleString();
            document.getElementById('sticky-note-modal').style.display = 'flex';
        };
        container.appendChild(div);
    });
};

let currentPickupId = null;
async function openPickupApp() {
    document.getElementById('pickup-modal').style.display = 'flex';
    
    // 设置标题名字（取设置里的对方名字，或者默认）
    const settings = JSON.parse(localStorage.getItem('chat_settings') || '{}');
    document.getElementById('pickup-char-name').innerText = settings.title || "对方";
    const history = await getPickupHistory();
    if (!currentPickupId) {
        if (history.length > 0) {
            await loadPickup(history[0].id);
        } else {
            startNewPickup();
        }
    } else {
        await renderPickupChat();
    }
}

function closePickupApp() {
    document.getElementById('pickup-modal').style.display = 'none';
}
async function getPickupHistory() {
    try {
        const res = await idb.get('pickup_data', 'history_list');
        return res ? res.data : [];
    } catch(e) { return []; }
}

async function savePickupHistory(list) {
    await idb.put('pickup_data', { id: 'history_list', data: list });
}

async function getPickupContent(id) {
    try {
        const res = await idb.get('pickup_data', `chat_${id}`);
        return res ? res.data : []; 
    } catch(e) { return []; }
}

async function savePickupContent(id, msgs) {
    await idb.put('pickup_data', { id: `chat_${id}`, data: msgs });
}
async function startNewPickup() {
    currentPickupId = Date.now().toString();
    const list = await getPickupHistory();
    list.unshift({ id: currentPickupId, title: "新对话 " + new Date().toLocaleTimeString(), date: Date.now() });
    await savePickupHistory(list);
    await savePickupContent(currentPickupId, []);
    
    document.getElementById('pickup-chat-area').innerHTML = ''; 
    document.getElementById('pickup-input').value = '';
    document.getElementById('pickup-history-panel').classList.remove('open');
}

async function loadPickup(id) {
    currentPickupId = id;
    await renderPickupChat();
    document.getElementById('pickup-history-panel').classList.remove('open');
}
async function renderPickupChat() {
    if (!currentPickupId) return;
    const msgs = await getPickupContent(currentPickupId);
    const container = document.getElementById('pickup-chat-area');
    container.innerHTML = '';
    const heavy = await idb.get('settings_heavy', 'botAvatar');
    const myHeavy = await idb.get('settings_heavy', 'myAvatar');
    const botAvatar = (heavy && heavy.data) ? `url(${heavy.data})` : '';
    const myAvatar = (myHeavy && myHeavy.data) ? `url(${myHeavy.data})` : '';

    msgs.forEach(msg => {
        const row = document.createElement('div');
        // role: 'me' -> 右边, 'char' -> 左边
        const isMe = msg.role === 'me';
        row.className = `pup-row ${isMe ? 'right' : 'left'}`;

        const avatarDiv = `<div class="pup-avatar" style="background-image:${isMe ? myAvatar : botAvatar}"></div>`;
        const bubbleDiv = `<div class="pup-bubble">${msg.content}</div>`;

        if (isMe) {
            row.innerHTML = bubbleDiv + avatarDiv;
        } else {
            row.innerHTML = avatarDiv + bubbleDiv;
        }
        container.appendChild(row);
    });
    setTimeout(() => {
        container.scrollTop = container.scrollHeight;
    }, 100);
}
async function generatePickupChat() {
    const inputEl = document.getElementById('pickup-input');
    const promptText = inputEl.value.trim();
    const btn = document.getElementById('btn-pickup-gen');
    const currentMsgs = await getPickupContent(currentPickupId);
    if (currentMsgs.length === 0 && !promptText) {
        return alert("请输入初始情节或关键词！");
    }
    const originalText = btn.innerText;
    btn.disabled = true;
    btn.innerText = "生成中...";
    const wb = getWBData();
    let context = "";
    context += "【世界观(全局)】:\n" + ((wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n")) + "\n";
    context += "【捡手机文学设定】:\n" + ((wb['8.捡手机文学'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n")) + "\n";
    const historyContext = currentMsgs.slice(-10).map(m => `${m.role==='me'?'用户':'角色'}: ${m.content}`).join("\n");

    const systemPrompt = `你是一个“捡手机文学”生成器。
这种文体的特点是：极度真实、生活化、通过聊天记录展现剧情和情感（虐心、甜宠、拉扯）。

${context}

【任务】
生成一段【用户(我)】和【角色(TA)】之间的微信/QQ聊天记录。
根据用户的输入关键词或前文进行续写。

【要求】
1. **数量**：必须生成**不少于 20 条**对话来回。不要偷懒。
2. **格式**：严格 JSON 数组格式，不要 Markdown 标记。
   - 用户(我)的 role 为 "me"。
   - 角色(TA)的 role 为 "char"。
   JSON示例：
   [
     {"role": "me", "content": "你在哪？"},
     {"role": "char", "content": "刚下班，怎么了？"},
     ...
   ]
3. **内容**：
   - 语气要像真人在打字，可以有短句、连发、标点不规范、甚至撤回（用文本表示[撤回了一条消息]）。
   - 情感要充沛，符合“捡手机文学”那种窥探隐私的真实感。
`;
    let apiKey = "", apiUrl = "", model = "";
    try {
        const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}');
        apiKey = s.key; apiUrl = s.url; model = s.model;
    } catch(e){}
    if (!apiKey) apiKey = document.getElementById('api-key').value;
    if (!apiUrl) apiUrl = document.getElementById('api-url').value;
    if (!model) model = document.getElementById('model-select').value;

    if (!apiKey) {
        btn.disabled = false; btn.innerText = originalText;
        return alert("API Key 未配置！");
    }

    try {
        const res = await fetch(`${apiUrl}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model || "gpt-3.5-turbo",
                messages: [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: `【前文】\n${historyContext}\n\n【本次情节指令】\n${promptText || "继续刚才的对话，深入展开"}` }
                ],
                temperature: 0.8,
                max_tokens: 3500 // 允许长输出
            })
        });

        const json = await res.json();
        let raw = json.choices[0].message.content;
        raw = raw.replace(/```json/g, "").replace(/```/g, "").trim();
 
        if(raw.startsWith('[') && !raw.endsWith(']')) raw += ']';

        let newMsgs = [];
        try {
            newMsgs = JSON.parse(raw);
        } catch(e) {
             console.error("JSON解析失败", raw);
             alert("生成格式错误，请重试");
             return;
        }
        const finalMsgs = currentMsgs.concat(newMsgs);
        await savePickupContent(currentPickupId, finalMsgs);
        if (currentMsgs.length === 0 && promptText) {
            const list = await getPickupHistory();
            const item = list.find(i => i.id === currentPickupId);
            if(item) {
                item.title = promptText.substring(0, 15);
                await savePickupHistory(list);
            }
        }
        await renderPickupChat();
        inputEl.value = ''; 

    } catch(e) {
        console.error(e);
        alert("生成失败: " + e.message);
    } finally {
        btn.disabled = false;
        btn.innerText = originalText;
    }
}
async function togglePickupHistory() {
    const panel = document.getElementById('pickup-history-panel');
    panel.classList.toggle('open');
    if (panel.classList.contains('open')) {
        const list = await getPickupHistory();
        const container = document.getElementById('pickup-history-list');
        container.innerHTML = '';
        
        list.forEach((item, index) => {
            const div = document.createElement('div');
            div.className = 'morandi-card';
            div.style.padding = '10px';
            div.style.cursor = 'pointer';
            if(item.id === currentPickupId) div.style.border = "2px solid #f1c40f";
            
            div.innerHTML = `
                <div style="font-weight:bold;">${item.title}</div>
                <div style="font-size:0.8rem; color:#888;">${new Date(item.date).toLocaleString()}</div>
                <div style="text-align:right;">
                    <button class="m-btn small" onclick="event.stopPropagation(); deletePickup(${index})" style="background:#ff6b6b; color:white;">删除</button>
                </div>
            `;
            div.onclick = () => loadPickup(item.id);
            container.appendChild(div);
        });
    }
}

async function deletePickup(index) {
    if(!confirm("删除这段记录？")) return;
    const list = await getPickupHistory();
    const id = list[index].id;
    await idb.delete('pickup_data', `chat_${id}`);
    list.splice(index, 1);
    await savePickupHistory(list);
    
    if(id === currentPickupId) {
        startNewPickup();
    } else {
        togglePickupHistory(); 
        togglePickupHistory();
    }
}

function clearPickupChat() {
    if(confirm("清空当前对话内容？(无法恢复)")) {
        savePickupContent(currentPickupId, []).then(() => renderPickupChat());
    }
}
function loadMemoFromLocal() {
    const text = localStorage.getItem('desktop_memo') || "";
    const previewEl = document.getElementById('desktop-memo-text');
    if(previewEl) {
        previewEl.innerText = text || "点击编辑备忘录...";
    }
    const area = document.getElementById('memo-full-text');
    if(area) area.value = text;
}

function saveMemoToLocal() {
    const text = document.getElementById('memo-full-text').value;
    localStorage.setItem('desktop_memo', text);
    document.getElementById('desktop-memo-text').innerText = text || "点击编辑备忘录...";
}

function openMemoApp() {
    loadMemoFromLocal();
    document.getElementById('memo-app-modal').style.display = 'flex';
}
function closeMemoApp() {
    document.getElementById('memo-app-modal').style.display = 'none';
}
loadMemoFromLocal();

let currentAlbumId = null;
let currentPhotoId = null; 
async function getAlbums() {
    try {
        const res = await idb.get('album_data', 'all_albums');
        return res ? res.data : [];
    } catch(e) { return []; }
}
async function saveAlbums(list) {
    await idb.put('album_data', { id: 'all_albums', data: list });
}
async function openAlbumApp() {
    document.getElementById('album-app-modal').style.display = 'flex';
    document.getElementById('album-shelf-view').style.display = 'flex';
    document.getElementById('album-detail-view').style.display = 'none';
    await renderAlbumShelf();
}
function closeAlbumApp() {
    document.getElementById('album-app-modal').style.display = 'none';
}
async function renderAlbumShelf() {
    const list = await getAlbums();
    const container = document.getElementById('album-list-container');
    container.innerHTML = '';

    if(list.length === 0) {
        container.innerHTML = `<div style="grid-column:span 2; text-align:center; color:#999; margin-top:50px;">暂无相册，请新建</div>`;
        return;
    }

    list.forEach(album => {
        const div = document.createElement('div');
        div.className = 'album-cover-item';
        div.onclick = () => openAlbumDetail(album.id);
        
        div.innerHTML = `
            <div class="album-cover-text">${album.name}</div>
            <div style="font-size:0.7rem; color:#6d4c41; margin-top:5px;">${album.photos.length} 张</div>
        `;
        container.appendChild(div);
    });
}

async function createNewAlbum() {
    const name = prompt("请输入相册名称:", "未命名相册");
    if(!name) return;
    
    const list = await getAlbums();
    list.push({
        id: Date.now().toString(),
        name: name,
        photos: [] // {id, src, date}
    });
    await saveAlbums(list);
    await renderAlbumShelf();
}
async function openAlbumDetail(id) {
    currentAlbumId = id;
    const list = await getAlbums();
    const album = list.find(a => a.id === id);
    if(!album) return;

    document.getElementById('album-shelf-view').style.display = 'none';
    document.getElementById('album-detail-view').style.display = 'flex';
    document.getElementById('album-title-display').innerText = album.name;
    
    renderPhotoGrid(album);
}

function renderPhotoGrid(album) {
    const container = document.getElementById('photo-grid-container');
    container.innerHTML = '';
    
    album.photos.forEach((p, idx) => {
        const div = document.createElement('div');
        div.className = 'photo-thumb';
        div.style.backgroundImage = `url(${p.src})`;
        div.onclick = () => viewPhoto(idx);
        container.appendChild(div);
    });
}

function backToShelf() {
    document.getElementById('album-shelf-view').style.display = 'flex';
    document.getElementById('album-detail-view').style.display = 'none';
    renderAlbumShelf();
}

async function editAlbumName() {
    const list = await getAlbums();
    const album = list.find(a => a.id === currentAlbumId);
    const newName = prompt("修改相册名称:", album.name);
    if(newName) {
        album.name = newName;
        await saveAlbums(list);
        document.getElementById('album-title-display').innerText = newName;
    }
}

async function deleteCurrentAlbum() {
    if(!confirm("确定要销毁这个相册吗？所有照片将丢失。")) return;
    let list = await getAlbums();
    list = list.filter(a => a.id !== currentAlbumId);
    await saveAlbums(list);
    backToShelf();
}
async function handlePhotoImport(input) {
    const files = Array.from(input.files);
    if(files.length === 0) return;
    
    let list = await getAlbums();
    const album = list.find(a => a.id === currentAlbumId);
    
    for(let file of files) {
        await new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = (e) => {
                album.photos.push({
                    id: Date.now() + Math.random(),
                    src: e.target.result,
                    date: new Date().toLocaleString()
                });
                resolve();
            };
            reader.readAsDataURL(file);
        });
    }
    
    await saveAlbums(list);
    renderPhotoGrid(album);
    input.value = '';
}

async function viewPhoto(index) {
    let list = await getAlbums();
    const album = list.find(a => a.id === currentAlbumId);
    const photo = album.photos[index];
    currentPhotoId = index; 

    const modal = document.getElementById('photo-viewer-modal');
    const card = document.getElementById('held-photo');
    const img = document.getElementById('held-photo-img');
    const date = document.getElementById('photo-date-str');

    img.src = photo.src;
    date.innerText = photo.date;
    
    modal.style.display = 'flex';
    card.classList.remove('slide-in');
    setTimeout(() => {
        card.classList.add('slide-in');
    }, 50);
}

function closePhotoViewer() {
    const card = document.getElementById('held-photo');
    card.classList.remove('slide-in');
    setTimeout(() => {
        document.getElementById('photo-viewer-modal').style.display = 'none';
    }, 300); 
}

async function deleteCurrentPhoto() {
    if(!confirm("撕毁这张照片？")) return;
    let list = await getAlbums();
    const album = list.find(a => a.id === currentAlbumId);
    
    album.photos.splice(currentPhotoId, 1); 
    await saveAlbums(list);
    
    closePhotoViewer();
    renderPhotoGrid(album); 
}

function openAnniversaryApp() {
    document.getElementById('anniversary-modal').style.display = 'flex';
    document.getElementById('anniversary-list-view').style.display = 'flex';
    document.getElementById('anniversary-add-view').style.display = 'none';
    renderAnniversaries();
}
function openAddAnniversaryView() {
    document.getElementById('anniversary-list-view').style.display = 'none';
    document.getElementById('anniversary-add-view').style.display = 'block';
    document.getElementById('ann-title').value = '';
    document.getElementById('ann-date').value = '';
    document.getElementById('ann-bg-input').value = '';
    document.getElementById('ann-repeat').checked = true;
}
function closeAddAnniversaryView() {
    document.getElementById('anniversary-list-view').style.display = 'flex';
    document.getElementById('anniversary-add-view').style.display = 'none';
}
async function renderAnniversaries() {
    const list = await idb.getAll('anniversary_data');
    const container = document.getElementById('anniversary-list-view');
    container.innerHTML = '';

    if (list.length === 0) {
        container.innerHTML = `<div style="text-align:center; color:#999; margin-top:50px;">暂无纪念日<br>点击右上角 + 新建</div>`;
        return;
    }
    list.sort((a, b) => a.daysLeft - b.daysLeft);

    list.forEach(item => {
        const calc = calculateAnniversary(item.date, item.repeat);
        const div = document.createElement('div');
        div.className = 'ann-card';
        if(item.bgImage) div.style.backgroundImage = `url(${item.bgImage})`;
        const labelText = calc.isPast ? "已经过去" : "还有";
        const dayText = calc.diffDays;
        
        div.innerHTML = `
            <div class="ann-del-btn" onclick="deleteAnniversary('${item.id}')">×</div>
            <div class="ann-content">
                <div class="ann-label">${item.title} ${labelText}</div>
                <div class="ann-days">${dayText} <span style="font-size:1rem; font-weight:normal;">天</span></div>
            </div>
            <div class="ann-content ann-date-text">目标日: ${item.date} ${item.repeat ? '(每年)' : ''}</div>
        `;
        container.appendChild(div);
    });
}
function calculateAnniversary(targetDateStr, isRepeat) {
    const today = new Date();
    today.setHours(0,0,0,0);
    
    let target = new Date(targetDateStr);
    target.setHours(0,0,0,0);
    if (isRepeat) {
        target.setFullYear(today.getFullYear());
        if (target < today) {
            target.setFullYear(today.getFullYear() + 1);
        }
    }
    
    const diffTime = target - today;
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    
    return {
        diffDays: Math.abs(diffDays), 
        isPast: diffDays < 0,       
        isToday: diffDays === 0
    };
}
async function saveAnniversary() {
    const title = document.getElementById('ann-title').value;
    const date = document.getElementById('ann-date').value;
    const repeat = document.getElementById('ann-repeat').checked;
    const remindType = document.getElementById('ann-remind-type').value;
    const bgInput = document.getElementById('ann-bg-input');
    
    if(!title || !date) return alert("请填写完整信息");

    let bgData = null;
    if(bgInput.files[0]) {
        bgData = await new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.readAsDataURL(bgInput.files[0]);
        });
    }

    const newItem = {
        id: Date.now().toString(),
        title,
        date,
        repeat,
        remindType,
        bgImage: bgData 
    };

    await idb.put('anniversary_data', newItem);
    closeAddAnniversaryView();
    renderAnniversaries();
}
async function deleteAnniversary(id) {
    if(confirm("删除这个纪念日？")) {
        await idb.delete('anniversary_data', id);
        renderAnniversaries();
    }
}
async function checkAnniversaries() {
    const list = await idb.getAll('anniversary_data');
    if (!list.length) return;

    let alerts = [];
    list.forEach(item => {
        if (item.remindType === 'none') return;
        
        const calc = calculateAnniversary(item.date, item.repeat);
        const days = calc.diffDays;
        if (item.remindType === 'same' && days === 0) {
            alerts.push(`🎉 今天是【${item.title}】！`);
        }
        if (item.remindType === 'before' && days === 1) {
            alerts.push(`⏰ 明天是【${item.title}】，记得准备哦！`);
        }
         if (item.remindType === 'before' && days === 0) {
            alerts.push(`🎉 今天是【${item.title}】！`);
        }
    });

    // 在 checkAnniversaries 函数内部...
    if (alerts.length > 0) {
        
        NotificationManager.send({
            title: "📅 纪念日提醒",
            body: alerts.join("\n"),
            icon: "💖",
            onClick: () => openAnniversaryApp() 
        });
    }
} 
let dreamActiveDeck = [];  
let dreamFlippedCards = [];  
let currentDreamResult = null; 
function openDreamApp() {
    document.getElementById('dream-app-modal').style.display = 'flex';
    document.getElementById('dream-result-area').style.display = 'none';
}

function closeDreamApp() {
    document.getElementById('dream-app-modal').style.display = 'none';
}
function startDreamDrawing() {
    const table = document.getElementById('dream-card-table-modal');
    const area = document.getElementById('dream-card-area');
    area.innerHTML = ''; 
    dreamActiveDeck = [];
    dreamFlippedCards = [];
    document.getElementById('dream-flipped-count').innerText = '0';
    let fullDeck = [];
    for(let i=0; i<=77; i++) {
        fullDeck.push({ type: 'tarot', id: i, isReversed: Math.random() < 0.3 }); 
    }
    for(let i=1; i<=36; i++) {
        fullDeck.push({ type: 'lenormand', id: i, isReversed: false }); 
    }
    fullDeck.sort(() => Math.random() - 0.5);
    dreamActiveDeck = fullDeck;
    const deskW = window.innerWidth;
    const cardWidth = 60;  
    const cardHeight = 90; 
    const gapX = 10;       
    const gapY = 15;       
    let columns = Math.floor((deskW - 20) / (cardWidth + gapX));
    if (columns < 4) columns = 4;
    if (columns > 8) columns = 8; 
    
    const totalGridWidth = columns * cardWidth + (columns - 1) * gapX;
    const startX = Math.max(0, (deskW - totalGridWidth) / 2); 
    const startY = 60;
    dreamActiveDeck.forEach((card, index) => {
        const el = document.createElement('div');
        el.className = 'playing-card'; 
        const colIndex = index % columns;
        const rowIndex = Math.floor(index / columns);
        
        const leftPos = startX + colIndex * (cardWidth + gapX);
        const topPos = startY + rowIndex * (cardHeight + gapY);
        
        el.style.left = leftPos + 'px';
        el.style.top = topPos + 'px';
        el.style.transform = `rotate(${Math.random() * 6 - 3}deg)`; 
        
        el.onclick = () => flipDreamCard(el, card);
        const front = document.createElement('div');
        front.className = 'playing-card-front';
        el.appendChild(front);
        
        area.appendChild(el);
    });
    const totalRows = Math.ceil(dreamActiveDeck.length / columns);
    area.style.height = (startY + totalRows * (cardHeight + gapY) + 120) + 'px';
    table.style.display = 'flex';
}

function closeDreamCardTable() {
    document.getElementById('dream-card-table-modal').style.display = 'none';
}
async function flipDreamCard(el, cardData) { if(el.classList.contains('flipped')) {
        el.classList.remove('flipped');
        dreamFlippedCards = dreamFlippedCards.filter(c => !(c.type === cardData.type && c.id === cardData.id));
        document.getElementById('dream-flipped-count').innerText = dreamFlippedCards.length;
        setTimeout(() => {
            const frontEl = el.querySelector('.playing-card-front');
            frontEl.style.backgroundImage = ''; 
            frontEl.style.transform = ''; 
            frontEl.innerText = '';
        }, 300);
        return; 
    }
    el.classList.add('flipped');
    dreamFlippedCards.push(cardData);
    document.getElementById('dream-flipped-count').innerText = dreamFlippedCards.length;
    const dbName = cardData.type === 'tarot' ? 'tarot_deck' : 'lenormand_deck';
    try {
        const item = await idb.get(dbName, cardData.id);
        const frontEl = el.querySelector('.playing-card-front');
        
        if(item && item.data) {
            frontEl.style.backgroundImage = `url(${item.data})`;
            frontEl.innerText = ''; 
            if(cardData.type === 'tarot' && cardData.isReversed) {
                frontEl.style.transform = "rotateY(180deg) rotate(180deg)"; 
            } else {
                frontEl.style.transform = "rotateY(180deg)";
            }
        } else {
            frontEl.style.backgroundColor = '#fdf6e3';
            frontEl.style.display = 'flex';
            frontEl.style.alignItems = 'center';
            frontEl.style.justifyContent = 'center';
            frontEl.style.fontSize = '0.8rem';
            frontEl.style.color = '#333';
            frontEl.innerText = `${cardData.type === 'tarot' ? 'Tarot' : 'Lenormand'}\n#${cardData.id}\n${cardData.isReversed ? '(逆)' : ''}`;
            if(cardData.type === 'tarot' && cardData.isReversed) {
                 frontEl.style.transform = "rotateY(180deg) rotate(180deg)";
            } else {
                 frontEl.style.transform = "rotateY(180deg)";
            }
        }
    } catch(e) { 
        console.error("Load card img failed", e); 
    }
}
async function finishDreamDrawing() {
    if(dreamFlippedCards.length === 0) return alert("请至少翻开一张牌！");
    
    closeDreamCardTable(); 
    
    const resultArea = document.getElementById('dream-result-area');
    resultArea.style.display = 'block';
    document.getElementById('dream-analysis-content').innerHTML = '<div class="skeleton-text">正在根据牌意与世界书生成梦男分析表...</div>';
    let cardsDesc = dreamFlippedCards.map(c => {
        let name = (c.type === 'tarot') ? TAROT_NAMES[c.id] : LENORMAND_NAMES[c.id];
        let status = (c.type === 'tarot' && c.isReversed) ? "(逆位)" : "";
        return `${name}${status}`;
    }).join(", ");

    const wb = getWBData();
    const globalContext = (wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    const dreamContextKey = Object.keys(wb).find(k => k.includes("梦角"));
    const dreamContext = dreamContextKey ? 
        (wb[dreamContextKey] || []).filter(i=>i.enabled).map(i=>i.content).join("\n") : "";

    let apiKey = document.getElementById('api-key').value; 
    let apiUrl = document.getElementById('api-url').value;
    let model = document.getElementById('model-select').value;
    
    if(!apiKey) {
        try {
            const saved = JSON.parse(localStorage.getItem('api_settings_draft') || '{}');
            apiKey = saved.key; apiUrl = saved.url; model = saved.model;
        } catch(e){}
    }
    if(!apiKey) return alert("请先配置 API Key！");
    const prompt = `
你是一个深度角色分析师。
请根据以下信息，分析如果【角色】成为用户的【梦男/梦女】（Dream Character/Partner）会发生什么。

【世界书/角色设定】：
${globalContext}

【"假如你是Ta的梦角"设定】：
${dreamContext}

【抽到的牌（命运指引）】：
${cardsDesc}
(请结合牌意来推导分析结果，例如：权杖牌可能代表热情买谷，星币牌代表愿意花钱，宝剑牌代表理智或纠结)

【任务要求】：
请严格生成一个 HTML 表格代码（<table>...</table>），不要Markdown标记。
表格必须包含以下行（Row），左边是项目，右边是分析内容：

1. **角色定位**：是梦男还是梦女？(根据角色性别判断)
2. **买谷数量**：会买多少周边？(数量级)
3. **喜欢的谷**：最喜欢买什么样的周边？最喜欢什么样的柄图？(吧唧/立牌/棉花娃娃等)（用户单人/用户的印象服/用户的象征物等）
4. **版权意识**：会不会考虑买版权/买断？
5. **同担态度**：对其他同价/同担分别的态度？(嫉妒/友善/无视)
6. **月消费**：每个月会花多少钱在梦向事件上？
7. **约稿偏好**：会约什么样的稿件？(插图/文/条漫)
8. **最开心的事**：做梦男/梦女最开心的事情？
9. **最痛苦的事**：做梦男/梦女最痛苦的事情？
10. **初始心情**：一开始做梦男/梦女的心情？

分析内容要符合角色性格，并融合牌意，并谨记角色做梦男/梦女是和现实一样做梦女/梦男的情况，角色不清楚用户怎么看待他/她也不知道用户是否真实存在，是否和他/她谈恋爱。
`;

    try {
        const res = await fetch(`${apiUrl}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model || "gpt-3.5-turbo",
                messages: [{ role: "system", content: "You are a creative writer. Output HTML Table only." }, { role: "user", content: prompt }],
                temperature: 0.8
            })
        });

        const json = await res.json();
        let content = json.choices[0].message.content;
        
        content = content.replace(/```html/g, "").replace(/```/g, "").trim();
        content = content.replace('<table>', '<table class="dream-table">');

        document.getElementById('dream-analysis-content').innerHTML = content;
        currentDreamResult = {
            date: Date.now(),
            cards: cardsDesc,
            htmlContent: content
        }; 
        NotificationManager.send({
            title: "🦄 梦境解析完成",
            body: "关于梦男/梦女的详细分析报告已生成。",
            icon: "🔮",
            onClick: () => {
                openDreamApp();
            }
        });

    } catch(e) {
        console.error(e);
        document.getElementById('dream-analysis-content').innerText = "生成失败: " + e.message;
    }
}
function saveDreamResultToHistory() {
    if (!currentDreamResult) {
        return alert("没有可保存的内容，请先生成解析。");
    }
    let history = [];
    try {
        const raw = localStorage.getItem('dream_history');
        if (raw) {
            history = JSON.parse(raw);
            if (!Array.isArray(history)) history = [];
        }
    } catch (e) {
        console.error("历史记录读取失败，重置为空", e);
        history = [];
    }
    if (history.length > 0 && history[0].date === currentDreamResult.date) {
        return alert("这条记录已经保存过了！");
    }
    history.unshift(currentDreamResult);

    // 5. 限制数量 (保留最近50条)
    if (history.length > 50) history.pop();
    try {
        localStorage.setItem('dream_history', JSON.stringify(history));
    } catch (e) {
        return alert("保存失败：存储空间不足");
    }
    try {
        if (typeof renderDreamHistory === 'function') {
            renderDreamHistory();
        }
    } catch (e) {
        console.error("列表刷新失败", e);
    }
    const saveBtn = document.getElementById('btn-dream-save');
    
    if (saveBtn) {
        const originalText = saveBtn.innerText;  "💾 保存..."
        saveBtn.innerText = "✅ 保存成功！";
        saveBtn.disabled = true;点

        setTimeout(() => {
            saveBtn.innerText = originalText;
            saveBtn.disabled = false;
        }, 1500);
    } else {
        alert("✅ 已成功保存到历史记录");
    }
}

function toggleDreamHistory() {
    const panel = document.getElementById('dream-history-panel');
    panel.classList.toggle('open');
    if(panel.classList.contains('open')) renderDreamHistory();
}

function renderDreamHistory() {
    const list = JSON.parse(localStorage.getItem('dream_history') || '[]');
    const container = document.getElementById('dream-history-list');
    container.innerHTML = '';
    
    if(list.length === 0) {
        container.innerHTML = '<div style="text-align:center;color:#999;padding:10px;">暂无记录</div>';
        return;
    }

    list.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'morandi-card';
        div.style.padding = '10px';
        div.style.cursor = 'pointer';
        
        div.innerHTML = `
            <div style="font-size:0.8rem; color:#888;">${new Date(item.date).toLocaleString()}</div>
            <div style="font-size:0.75rem; color:#6a1b9a; margin:5px 0;">🎴 ${item.cards}</div>
            <div style="text-align:right;">
                 <button class="m-btn small" onclick="event.stopPropagation(); deleteDreamHistory(${index})" style="background:#ff6b6b; color:white;">删除</button>
            </div>
        `;
        div.onclick = () => {
            document.getElementById('dream-result-area').style.display = 'block';
            document.getElementById('dream-analysis-content').innerHTML = item.htmlContent;
            document.getElementById('dream-history-panel').classList.remove('open');
            currentDreamResult = item;
        };
        container.appendChild(div);
    });
}

function deleteDreamHistory(index) {
    if(!confirm("删除这条记录？")) return;
    const list = JSON.parse(localStorage.getItem('dream_history') || '[]');
    list.splice(index, 1);
    localStorage.setItem('dream_history', JSON.stringify(list));
    renderDreamHistory();
}

let hpActiveDeck = [];
let hpFlippedCards = [];
let hpCurrentResult = null; 
function openHisPhoneApp() {
    document.getElementById('his-phone-modal').style.display = 'flex';
    document.getElementById('hp-intro-view').style.display = 'flex';
    document.getElementById('hp-card-view').style.display = 'none';
    document.getElementById('hp-os-view').style.display = 'none';
    const now = new Date();
    document.getElementById('hp-clock').innerText = `${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
}

function closeHisPhoneApp() {
    document.getElementById('his-phone-modal').style.display = 'none';
}
function startHisPhoneDrawing() {
    document.getElementById('hp-intro-view').style.display = 'none';
    document.getElementById('hp-card-view').style.display = 'flex';
    
    const area = document.getElementById('hp-card-area');
    area.innerHTML = '';
    hpActiveDeck = [];
    hpFlippedCards = [];
    document.getElementById('hp-flipped-count').innerText = '0';
    let fullDeck = [];
    for(let i=0; i<=77; i++) fullDeck.push({ type: 'tarot', id: i, isReversed: Math.random()<0.3 });
    for(let i=1; i<=36; i++) fullDeck.push({ type: 'lenormand', id: i, isReversed: false });
    
    fullDeck.sort(() => Math.random() - 0.5);
    hpActiveDeck = fullDeck;
    const cardW = 60, cardH = 90, gap = 10;
    const cols = Math.floor((window.innerWidth - 20) / (cardW + gap));
    const startX = (window.innerWidth - (cols * (cardW+gap))) / 2;

    hpActiveDeck.forEach((card, i) => {
        const el = document.createElement('div');
        el.className = 'playing-card';
        const col = i % cols;
        const row = Math.floor(i / cols);
        el.style.left = (startX + col * (cardW + gap)) + 'px';
        el.style.top = (60 + row * (cardH + gap)) + 'px';
        el.style.transform = `rotate(${Math.random()*6-3}deg)`;
        
        const front = document.createElement('div');
        front.className = 'playing-card-front';
        el.appendChild(front);

        el.onclick = () => flipHisPhoneCard(el, card);
        area.appendChild(el);
    });
    const rows = Math.ceil(hpActiveDeck.length / cols);
    area.style.height = (rows * (cardH + gap) + 150) + 'px';
}

async function flipHisPhoneCard(el, card) {
    if(el.classList.contains('flipped')) {
        el.classList.remove('flipped');
        hpFlippedCards = hpFlippedCards.filter(c => !(c.type===card.type && c.id===card.id));
    } else {
        el.classList.add('flipped');
        hpFlippedCards.push(card);
        const dbName = card.type === 'tarot' ? 'tarot_deck' : 'lenormand_deck';
        try {
            const item = await idb.get(dbName, card.id);
            const front = el.querySelector('.playing-card-front');
            if(item && item.data) {
                front.style.backgroundImage = `url(${item.data})`;
            } else {
                front.style.backgroundColor = '#ddd';
                front.innerText = card.id;
            }
            if(card.isReversed) front.style.transform = "rotateY(180deg) rotate(180deg)";
            else front.style.transform = "rotateY(180deg)";
        } catch(e){}
    }
    document.getElementById('hp-flipped-count').innerText = hpFlippedCards.length;
}
async function finishHisPhoneReading() {
    if(hpFlippedCards.length === 0) return alert("请至少翻开一张牌！");

    const btn = document.querySelector('#hp-card-view .m-btn.primary');
    const originalText = btn.innerText;
    btn.innerText = "正在破解密码 (AI生成中)...";
    btn.disabled = true;
    const cardsDesc = hpFlippedCards.map(c => (c.type==='tarot'?TAROT_NAMES[c.id]:LENORMAND_NAMES[c.id]) + (c.isReversed?"(逆)":"")).join(",");
    const wb = getWBData();
    const globalCtx = (wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    const phoneCtx = (wb['11.捡到ta的手机'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    let apiKey = document.getElementById('api-key').value;
    let apiUrl = document.getElementById('api-url').value;
    let model = document.getElementById('model-select').value;
    if(!apiKey) {
        try {
            const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}');
            apiKey = s.key; apiUrl = s.url; model = s.model;
        } catch(e){}
    }

    const prompt = `
你现在正在模拟**目标角色**的手机内容。
【角色/世界设定】：
${globalCtx}
【捡手机特别设定】：
${phoneCtx}
【抽到的命运牌 (作为生成内容的潜意识指引)】：
${cardsDesc}

【任务】
请生成一个 JSON 对象，模拟该角色手机里的真实数据。
内容必须符合角色性格和牌意（例如：高冷角色的备忘录可能很简洁，病娇角色的浏览器记录可能很可怕，结合牌意体现当下心理）。

【JSON 结构要求】
{
  "xiaohongshu": [ {"type": "liked", "title": "...", "content": "..."}, {"type": "posted", "title": "...", "content": "..."} ], 
  "browser": [ "搜索记录1", "搜索记录2", "..." ],
  "wechat": [
    { 
      "name": "User(我)", "is_user": true, 
      "messages": [ {"role": "me", "text": "用户的话"}, {"role": "other", "text": "角色的回复"} ] 
    },
    {
      "name": "NPC名字", "is_user": false,
      "messages": [ {"role": "other", "text": "..."} ]
    }
  ],
  "taobao": [ {"item": "商品名", "date": "1天前"}, ... ],  "photos": [ {"desc": "一张模糊的夜景照片，配文：又是加班..."}, {"desc": "一只流浪猫的照片，阳光很好"} ], 
  "memo": [ "备忘录内容1...", "..." ],
  "diary": "今天的日记正文..."
}
只输出 JSON，不要 Markdown。
`;

    try {
        const res = await fetch(`${apiUrl || "https://api.openai.com/v1"}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model || "gpt-3.5-turbo",
                messages: [{role: "system", content: "You are a creative writer. Output strictly JSON."}, {role: "user", content: prompt}],
                temperature: 0.8
            })
        });
        const json = await res.json();
        let content = json.choices[0].message.content.replace(/```json/g,"").replace(/```/g,"").trim();
        
        hpCurrentResult = JSON.parse(content);
        hpCurrentResult.date = Date.now();
        hpCurrentResult.cards = cardsDesc; 
        renderHisPhoneOS(hpCurrentResult);

    } catch(e) {
        alert("生成失败: " + e.message);
        console.error(e);
    } finally {
        btn.innerText = originalText;
        btn.disabled = false;
    }
}
function renderHisPhoneOS(data) {
    document.getElementById('hp-card-view').style.display = 'none';
    document.getElementById('hp-os-view').style.display = 'flex';
    
    const grid = document.getElementById('hp-home-screen');
    grid.innerHTML = '';
    const apps = [
        { id: 'xiaohongshu', icon: '📕', label: '小红书', color: '#ff2d55' },
        { id: 'wechat', icon: '💬', label: '微信', color: '#07c160' },
        { id: 'browser', icon: '🧭', label: '浏览器', color: '#007aff' },
        { id: 'taobao', icon: '🛍️', label: '淘宝', color: '#ff9500' },
        { id: 'memo', icon: '📝', label: '备忘录', color: '#ffcc00' },
        { id: 'diary', icon: '📒', label: '日记', color: '#5856d6' },
        { id: 'settings', icon: '⚙️', label: '设置', color: '#8e8e93' }, // 装饰用
        { id: 'photos', icon: '🖼️', label: '相册', color: '#af52de' }  
    ];

    apps.forEach(app => {
        const div = document.createElement('div');
        div.style.display = 'flex';
        div.style.flexDirection = 'column';
        div.style.alignItems = 'center';
        div.innerHTML = `
            <div class="hp-app-icon" style="background:${app.color}" onclick="openFakeApp('${app.id}')">${app.icon}</div>
            <div class="hp-icon-label">${app.label}</div>
        `;
        grid.appendChild(div);
    });
}
function openFakeApp(appId) {
    if(!hpCurrentResult) return;
    if(['settings'].includes(appId)) return alert("需要面容解锁 (内容未生成)");

    const modal = document.getElementById('hp-app-detail-modal');
    const titleEl = document.getElementById('hp-app-title');
    const contentEl = document.getElementById('hp-app-content');
    contentEl.innerHTML = ''; 

    modal.style.display = 'flex';

    const data = hpCurrentResult;

    if (appId === 'xiaohongshu') {
        titleEl.innerText = "小红书";
        contentEl.style.background = "#f5f5f5";
        (data.xiaohongshu || []).forEach(post => {
            const card = document.createElement('div');
            card.className = 'hp-xhs-card';
            card.innerHTML = `
                <div class="hp-xhs-img"></div>
                <div style="padding:10px;">
                    <div style="font-weight:bold; font-size:0.9rem;">${post.title}</div>
                    <div style="font-size:0.8rem; color:#666; margin-top:5px;">${post.content}</div>
                    <div style="font-size:0.7rem; color:#ff2d55; margin-top:5px;">${post.type === 'liked' ? '❤️ 赞过' : '👤 发布'}</div>
                </div>
            `;
            contentEl.appendChild(card);
        });
    }
    else if (appId === 'browser') {
        titleEl.innerText = "Safari";
        contentEl.style.background = "white";
        contentEl.innerHTML = `<div style="padding:15px; font-weight:bold; color:#333;">历史记录</div>`;
        (data.browser || []).forEach(item => {
            contentEl.innerHTML += `<div style="padding:12px 15px; border-bottom:1px solid #eee; color:#007aff;">🔍 ${item}</div>`;
        });
    }
    else if (appId === 'wechat') {
        titleEl.innerText = "微信";
        contentEl.style.background = "white";
        (data.wechat || []).forEach((chat, idx) => {
            const row = document.createElement('div');
            row.className = 'hp-wechat-row';
            const color = chat.is_user ? '#07c160' : '#ddd';
            const lastMsg = chat.messages[chat.messages.length-1].text;
            
            row.innerHTML = `
                <div class="hp-wechat-avatar" style="background:${color}; display:flex; justify-content:center; align-items:center; color:white; font-size:0.8rem;">${chat.name[0]}</div>
                <div style="flex:1;">
                    <div style="font-weight:bold; color:#333;">${chat.name}</div>
                    <div style="font-size:0.8rem; color:#999; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; width:200px;">${lastMsg}</div>
                </div>
            `;
            row.onclick = () => showFakeChatDetail(chat);
            contentEl.appendChild(row);
        });
    }
    else if (appId === 'taobao') {
        titleEl.innerText = "淘宝";
        contentEl.style.background = "#f2f2f2";
        (data.taobao || []).forEach(item => {
            const div = document.createElement('div');
            div.className = 'hp-taobao-item';
            div.innerHTML = `
                <div style="width:60px; height:60px; background:#ddd; border-radius:4px;"></div>
                <div style="flex:1;">
                    <div style="font-size:0.9rem; line-height:1.2;">${item.item}</div>
                    <div style="font-size:0.8rem; color:#ff5000; margin-top:5px; font-weight:bold;">¥ ???</div>
                    <div style="font-size:0.7rem; color:#999; margin-top:2px;">购买于 ${item.date || '最近'}</div>
                </div>
            `;
            contentEl.appendChild(div);
        });
    }
    else if (appId === 'memo') {
        titleEl.innerText = "备忘录";
        contentEl.style.background = "white";
        contentEl.innerHTML = `<h2 style="padding:15px 0 0 15px; margin:0;">备忘录</h2>`;
        (data.memo || []).forEach(note => {
            const div = document.createElement('div');
            div.className = 'hp-memo-item';
            div.style.margin = "15px";
            div.innerText = note;
            contentEl.appendChild(div);
        });
    }
    else if (appId === 'photos') {
        titleEl.innerText = "相册"; contentEl.style.background = "white";
        contentEl.innerHTML = (data.photos || []).map(p => 
            `<div style="background:#eee; margin:10px; height:120px; display:flex; align-items:center; justify-content:center; padding:10px; text-align:center; color:#555; border-radius:8px; font-size:0.9rem;">🖼️ [图片]<br>${p.desc}</div>`
        ).join('') || '<div style="padding:20px;text-align:center">空空如也</div>';
    }
    else if (appId === 'diary') {
        titleEl.innerText = "日记";
        contentEl.style.background = "#fff";
        contentEl.innerHTML = `
            <div style="padding:20px; line-height:1.8; font-family:serif; color:#333;">
                <div style="color:#999; margin-bottom:15px;">${new Date().toLocaleDateString()}</div>
                ${(data.diary || "").replace(/\n/g, "<br>")}
            </div>
        `;
    }
}

function closeFakeApp() {
    document.getElementById('hp-app-detail-modal').style.display = 'none';
}

function showFakeChatDetail(chat) {
    const contentEl = document.getElementById('hp-app-content');
    const titleEl = document.getElementById('hp-app-title');
    titleEl.innerText = chat.name;
    contentEl.innerHTML = '';
    contentEl.style.background = "#f5f5f5";

    chat.messages.forEach(msg => {
        const bubble = document.createElement('div');
        const isMe = msg.role === 'me'; 
        bubble.className = `hp-chat-bubble ${msg.role === 'me' ? 'me' : 'other'}`;
        bubble.innerText = msg.text;
        const row = document.createElement('div');
        row.style.display = 'flex';
        row.style.flexDirection = 'column';
        row.style.padding = '5px';
        row.appendChild(bubble);
        contentEl.appendChild(row);
    });
}
function saveHisPhoneResult() {
    if(!hpCurrentResult) return;
    
    try {
        let list = [];
        try {
            list = JSON.parse(localStorage.getItem('his_phone_history') || '[]');
        } catch (e) {
            console.warn("历史数据损坏，已重置");
            list = [];
        }
        if(list.length > 0 && list[0].date === hpCurrentResult.date) {
            return alert("⚠️ 这条证据已经保存过了，无需重复保存。");
        }
        list.unshift(hpCurrentResult);
        if(list.length > 20) list.pop();

        localStorage.setItem('his_phone_history', JSON.stringify(list));
        const btn = document.getElementById('btn-hp-save');
        const originalText = btn.innerText;
        btn.innerText = "✅ 已保存";
        btn.disabled = true; 
        
        setTimeout(() => { 
            btn.innerText = originalText;
            btn.disabled = false;
        }, 1500);
        if(document.getElementById('hp-history-panel').classList.contains('open')) {
            renderHisPhoneHistory(); 
        }
        
        alert("✅ 证据已成功保存到历史记录！");

    } catch (e) {
        console.error("保存失败:", e);
        
        if (e.name === 'QuotaExceededError') {
            alert("❌ 保存失败：存储空间已满！\n请删除一些旧的历史记录（塔罗牌、冰箱或信件记录）后再试。");
        } else {
            alert("❌ 保存出错：系统发生未知错误\n" + e.message);
        }
    }
}
function toggleHisPhoneHistory() {
    const panel = document.getElementById('hp-history-panel');
    panel.classList.toggle('open');
    if(panel.classList.contains('open')) renderHisPhoneHistory();
}

function renderHisPhoneHistory() {
    const list = JSON.parse(localStorage.getItem('his_phone_history') || '[]');
    const container = document.getElementById('hp-history-list');
    container.innerHTML = '';
    
    list.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'morandi-card';
        div.style.padding = '10px';
        div.style.cursor = 'pointer';
        div.innerHTML = `
            <div style="font-weight:bold;">${new Date(item.date).toLocaleString()}</div>
            <div style="font-size:0.8rem; color:#888;">🃏 ${item.cards}</div>
            <button class="m-btn small" onclick="event.stopPropagation(); deleteHisPhoneHistory(${index})" style="margin-top:5px; background:#ff6b6b; color:white; float:right;">删除</button>
        `;
        div.onclick = () => {
            hpCurrentResult = item;
            renderHisPhoneOS(item);
            document.getElementById('hp-history-panel').classList.remove('open');
            document.getElementById('hp-intro-view').style.display = 'none';
        };
        container.appendChild(div);
    });
}

function deleteHisPhoneHistory(index) {
    let list = JSON.parse(localStorage.getItem('his_phone_history') || '[]');
    list.splice(index, 1);
    localStorage.setItem('his_phone_history', JSON.stringify(list));
    renderHisPhoneHistory();
}
function getStudyData() {
    return JSON.parse(localStorage.getItem('study_plan_data') || 'null');
}

function saveStudyData(data) {

    if (typeof idb !== 'undefined') {
        idb.put('universal_store', { id: 'study', data: data });
    }
    if (window.BIG_MEMORY) {
        window.BIG_MEMORY.study = data;
    } else {
        window.BIG_MEMORY = { study: data };
    }
    
    console.log("✅ 学习计划已存入无限数据库");
}
function openStudyApp() {
    document.getElementById('study-modal').style.display = 'flex';
    renderStudyApp();
}

function closeStudyApp() {
    document.getElementById('study-modal').style.display = 'none';
}
function renderStudyApp() {
    const data = getStudyData();
    
    if (data && data.tasks && data.tasks.length > 0) {
        document.getElementById('study-create-view').style.display = 'none';
        document.getElementById('study-list-view').style.display = 'flex';
        renderStudyList(data);
    } else {
        document.getElementById('study-create-view').style.display = 'flex';
        document.getElementById('study-list-view').style.display = 'none';
    }
}
async function generateStudyPlan() {
    const goal = document.getElementById('study-goal').value;
    const period = document.getElementById('study-period').value;
    const status = document.getElementById('study-status').value;
    const useWb = document.getElementById('study-use-wb').checked;
    
    if (!goal || !period) return alert("请填写目标和周期！");

    const btn = document.getElementById('btn-study-gen');
    const originalText = btn.innerText;
    btn.disabled = true;
    btn.innerText = "🔍 搜索资源并规划中..."; // 改个文案增加真实感

    let apiKey = "", apiUrl = "", model = "";
    try {
        const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}');
        apiKey = s.key; apiUrl = s.url; model = s.model;
    } catch(e){}
    if (!apiKey) apiKey = document.getElementById('api-key').value;
    if (!apiUrl) apiUrl = document.getElementById('api-url').value;
    if (!model) model = document.getElementById('model-select').value;

    if (!apiKey) {
        btn.disabled = false; btn.innerText = originalText;
        return alert("请先在设置中配置 API Key！");
    }
    if (apiUrl && apiUrl.endsWith('/')) apiUrl = apiUrl.slice(0, -1);
    if (!apiUrl) apiUrl = "https://api.openai.com/v1";
    
    const chatSettings = JSON.parse(localStorage.getItem('chat_settings') || '{}');
    const charName = chatSettings.title || "角色";
    const wb = getWBData();
    const globalContext = useWb ? ((wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n")) : "";
    
    // --- 修改了 Prompt ---
    const prompt = `
你现在扮演世界书中的角色：【${charName}】。
${globalContext}

【用户请求】
请为我制定一个学习计划。
- 目标：${goal}
- 周期：${period}
- 目前情况：${status}

【任务要求】
1. **推荐真实资源**：请搜索网络，推荐 2-3 本经典的**实体教材/书籍**，以及 Bilibili 上具体的**UP主名称或课程关键词**（必须是真实存在且高质量的）。
2. **任务细化**：每天的任务如果时间较长，请按时间段拆分为小项（如：09:00-10:00 理论，14:00-15:00 刷题）。
3. **思维导图**：在最后总结一个知识点的 ASCII 树状图或思维导图结构。
4. **语气**：完全符合【${charName}】的人设。

【输出格式】
**严格输出 JSON 格式**，不要 Markdown 代码块。
结构如下：
{
  "title": "计划标题",
  "resources": [
     {"type": "教材", "name": "书名-作者"},
     {"type": "B站", "name": "UP主名/课程关键词"}
  ],
  "mind_map": "根节点\\n  ├─ 知识点A\\n  └─ 知识点B...",
  "tasks": [
    { 
      "day": "Day X", 
      "content": "今日概要", 
      "sub_tasks": ["09:00 看第一章", "14:00 做习题"], 
      "quote": "..." 
    }
  ]
}
`;

    try {
        const res = await fetch(`${apiUrl}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model || "gpt-3.5-turbo",
                messages: [{role: "system", content: "You are a helpful tutor. Output strictly JSON."}, {role: "user", content: prompt}],
                temperature: 0.7
            })
        });

        const json = await res.json();
        if (json.error) throw new Error(json.error.message);
        
        let raw = json.choices[0].message.content;
        raw = raw.replace(/```json/g, "").replace(/```/g, "").trim();
        const planData = JSON.parse(raw);
        
        // 兼容处理：给新任务加 completed 状态
        const newTasks = planData.tasks.map(t => ({ ...t, completed: false }));
        
        // 构造完整数据对象
        let currentData = {
            title: planData.title,
            meta_period: period,
            resources: planData.resources || [], // 新增资源字段
            mind_map: planData.mind_map || "",   // 新增思维导图字段
            tasks: newTasks
        };
        
        saveStudyData(currentData); // 存入无限存储
        
        NotificationManager.send({
            title: "📅 学习计划已生成",
            body: "包含教材推荐与思维导图，快去看看吧！",
            icon: "🎓",
            onClick: () => openStudyApp()
        });
        renderStudyApp();

    } catch(e) {
        console.error(e);
        alert("生成失败: " + e.message);
    } finally {
        btn.disabled = false;
        btn.innerText = originalText;
    }
}
function renderStudyList(data) {
    document.getElementById('study-plan-title').innerText = data.title || "我的学习计划";
    document.getElementById('study-plan-meta').innerText = `目标: ${data.meta_period || '未知'}`;

    const container = document.getElementById('study-tasks-container');
    container.innerHTML = '';
    
    // --- 新增：显示推荐资源 ---
    if (data.resources && data.resources.length > 0) {
        const resDiv = document.createElement('div');
        resDiv.className = 'morandi-card';
        resDiv.style.padding = '12px';
        resDiv.style.marginBottom = '15px';
        resDiv.style.background = '#fff';
        
        let resHtml = '<div style="font-weight:bold; color:#455a64; margin-bottom:8px; font-size:0.9rem;">📚 推荐教材 & B站课程</div>';
        data.resources.forEach(r => {
            const icon = r.type.includes('B站') ? '📺' : '📖';
            resHtml += `<span class="study-resource-tag">${icon} ${r.name}</span>`;
        });
        resDiv.innerHTML = resHtml;
        container.appendChild(resDiv);
    }

    // 进度条逻辑（保持不变）
    const total = data.tasks.length;
    const done = data.tasks.filter(t => t.completed).length;
    const percent = total === 0 ? 0 : Math.round((done / total) * 100);
    document.getElementById('study-progress-text').innerText = `${done}/${total}`;
    document.getElementById('study-progress-bar').style.width = `${percent}%`;

    // 渲染任务列表
    data.tasks.forEach((task, index) => {
        const div = document.createElement('div');
        div.className = `study-task-card ${task.completed ? 'completed' : ''}`;
        
        // 构建细分小项 HTML
        let subTasksHtml = '';
        if (task.sub_tasks && task.sub_tasks.length > 0) {
            subTasksHtml = `<div style="margin-top:8px;">`;
            task.sub_tasks.forEach(sub => {
                subTasksHtml += `<div class="study-sub-task">• ${sub}</div>`;
            });
            subTasksHtml += `</div>`;
        }

        div.innerHTML = `
            <div class="study-task-header">
                <span class="study-day-tag">${task.day}</span>
                <div class="check-icon">✓</div>
            </div>
            <div class="study-task-content" style="font-weight:500;">${task.content}</div>
            ${subTasksHtml} <!-- 插入细分任务 -->
            <div class="study-quote-box">
                “ ${task.quote} ”
            </div>
        `;
        div.onclick = () => toggleStudyTask(index);
        container.appendChild(div);
    });

    // --- 新增：显示思维导图 ---
    if (data.mind_map) {
        const mapDiv = document.createElement('div');
        mapDiv.className = 'morandi-card';
        mapDiv.style.padding = '15px';
        mapDiv.style.marginTop = '15px';
        mapDiv.style.marginBottom = '20px';
        
        mapDiv.innerHTML = `
            <div style="font-weight:bold; color:#455a64; margin-bottom:10px;">🧠 学习思维导图</div>
            <div class="mind-map-box">${data.mind_map}</div>
        `;
        container.appendChild(mapDiv);
    }
}
function toggleStudyTask(index) {
    const data = getStudyData();
    data.tasks[index].completed = !data.tasks[index].completed;
    saveStudyData(data);
    renderStudyList(data);
}
function deleteStudyPlan() {
    if(confirm("确定要放弃这个计划吗？所有进度将丢失。")) {
        localStorage.removeItem('study_plan_data');
        renderStudyApp(); 
    }
}
(async function initThemeDB() {
    const dbName = "RetroOS_System_V7789"; 
})();
const APP_MAP = [
    { id: 'settings', name: '设置', selector: 'div[onclick="openSettings()"]' },
    { id: 'worldbook', name: '世界书', selector: 'div[onclick="openWorldBook()"]' },
    { id: 'camera', name: '相机', selector: 'div[onclick="openCamera()"]' },
    { id: 'file', name: '文件', selector: 'div[onclick="openFileApp()"]' },
    { id: 'finance', name: '记账', selector: 'div[onclick="openFinanceApp()"]' },
    { id: 'study', name: '学习计划', selector: 'div[onclick="openStudyApp()"]' },
    { id: 'theater', name: '小剧场', selector: 'div[onclick="openTheaterApp()"]' },
{ id: 'lofter', name: '老福特', selector: 'div[onclick="openLofterApp()"]' },
    { id: 'pickup', name: '捡手机', selector: 'div[onclick="openPickupApp()"]' },
    { id: 'period', name: '经期', selector: 'div[onclick="openPeriodApp()"]' },
    { id: 'forum', name: '论坛体', selector: 'div[onclick="openForumApp()"]' },
    { id: 'album', name: '相册', selector: 'div[onclick="openAlbumApp()"]' },
    { id: 'anniversary', name: '纪念日', selector: 'div[onclick="openAnniversaryApp()"]' },
    { id: 'dream', name: '梦App', selector: 'div[onclick="openDreamApp()"]' },
    { id: 'hisphone', name: 'ta的手机', selector: 'div[onclick="openHisPhoneApp()"]' },
    { id: 'fan', name: '电子屏', selector: 'div[onclick="openFan()"]' }, { id: 'lofter', name: '老福特', selector: 'div[onclick="openLofterApp()"]' }, // 确保有
    { id: 'shadow', name: '阴暗面', selector: 'div[onclick="openShadowApp()"]' }, // 🔥 新增
    { id: 'petdiary', name: '宠物日记', selector: 'div[onclick="openPetDiaryApp()"]' }, // 🔥 新增
    { id: 'gashapon', name: '平行扭蛋', selector: 'div[onclick="openGashaponApp()"]' }, 
    { id: 'chat', name: '聊天', selector: 'div[onclick="openChatApp()"]' },
    { id: 'tarot', name: '塔罗', selector: 'div[onclick="openTarotApp()"]' },
    { id: 'letter', name: '信件', selector: 'div[onclick="openLetterApp()"]' } ,
    { id: 'theme', name: '美化', selector: 'div[onclick="openThemeApp()"]' },{ id: 'pain', name: '关于痛苦', selector: 'div[onclick="openPainApp()"]' },
{ id: 'thesaurus', name: '词库', selector: 'div[onclick="openThesaurus()"]' }, 
    
];
// === 新增代码 START ===

// 定义哪些 App 可以换背景，以及它们对应的 Modal ID
const APP_BG_MAP = [
    { id: 'study', name: '学习计划', modalId: 'study-modal' },
    { id: 'finance', name: '记账', modalId: 'finance-modal' },
    { id: 'theater', name: '小剧场', modalId: 'theater-modal' },
    { id: 'pickup', name: '捡手机', modalId: 'pickup-modal' },
    { id: 'period', name: '经期', modalId: 'period-modal' },
    { id: 'forum', name: '论坛体', modalId: 'forum-modal' },
    { id: 'album', name: '相册', modalId: 'album-app-modal' },
    { id: 'anniversary', name: '纪念日', modalId: 'anniversary-modal' },
    { id: 'dream', name: '梦App', modalId: 'dream-app-modal' },
    { id: 'hisphone', name: 'Ta的手机', modalId: 'his-phone-modal' },
    { id: 'chat', name: '聊天', modalId: 'chat-modal' },
    { id: 'tarot', name: '塔罗', modalId: 'tarot-app-modal' },
    { id: 'letter', name: '信件', modalId: 'letter-app-modal' },
    { id: 'lofter', name: '老福特', modalId: 'lofter-modal' },
    { id: 'pain', name: '关于痛苦', modalId: 'pain-app-modal' },
    { id: 'petdiary', name: '宠物日记', modalId: 'pet-diary-app-modal' },
    { id: 'gashapon', name: '扭蛋机', modalId: 'gashapon-app-modal' },
    { id: 'shadow', name: '阴暗面', modalId: 'shadow-app-modal' },
    { id: 'summary', name: '学习总结', modalId: 'summary-app-modal' }
];

// 渲染背景上传列表
async function renderAppBgList() {
    const list = document.getElementById('app-bg-config-list');
    list.innerHTML = '';
    
    for (let item of APP_BG_MAP) {
        const div = document.createElement('div');
        div.className = 'font-setting-item'; // 复用已有样式
        
        // 检查是否有已保存的背景
        const saved = await idb.get('settings_heavy', `bg_${item.id}`);
        const statusText = saved ? "✅ 已设置" : "⚪ 默认";

        div.innerHTML = `
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <label style="margin:0; font-weight:bold;">${item.name}</label>
                <span style="font-size:0.7rem; color:#888;">${statusText}</span>
            </div>
            <div style="display:flex; gap:10px; margin-top:5px;">
                <input type="file" id="upload_bg_${item.id}" style="display:none" onchange="saveAppBg('${item.id}', this)">
                <button class="m-btn small" onclick="document.getElementById('upload_bg_${item.id}').click()">📷 上传背景</button>
                <button class="m-btn small" onclick="clearAppBg('${item.id}')" style="background:#ffcdd2; color:red;">🗑️ 清除</button>
            </div>
        `;
        list.appendChild(div);
    }
}

// 保存独立背景
async function saveAppBg(appId, input) {
    const file = input.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        await idb.put('settings_heavy', { key: `bg_${appId}`, data: e.target.result });
        alert("背景已保存！");
        renderAppBgList(); // 刷新列表状态
        applyAllThemeSettings(); // 立即应用
    };
    reader.readAsDataURL(file);
}

// 清除独立背景
async function clearAppBg(appId) {
    if(!confirm("恢复默认背景？")) return;
    await idb.delete('settings_heavy', `bg_${appId}`);
    renderAppBgList();
    applyAllThemeSettings();
}

// 保存全局 CSS
async function saveGlobalCSS() {
    const css = document.getElementById('global-css-input').value;
    await idb.put('settings_heavy', { key: 'global_custom_css', data: css });
    alert("CSS 已保存并应用！");
    applyGlobalCSS();
}

// 应用全局 CSS
async function applyGlobalCSS() {
    const res = await idb.get('settings_heavy', 'global_custom_css');
    const css = res ? res.data : "";
    
    // 填充到输入框（如果是打开设置时）
    const inputEl = document.getElementById('global-css-input');
    if(inputEl && !inputEl.value) inputEl.value = css;

    let styleTag = document.getElementById('user-custom-style');
    if(!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'user-custom-style';
        document.head.appendChild(styleTag);
    }
    styleTag.innerHTML = css;
}
// === 新增代码 END ===
function openThemeApp() {
    document.getElementById('theme-modal').style.display = 'flex';
    renderThemeIconsList();
    renderThemeFontsList();
    renderStampList();
    // 新增这两个调用：
    renderAppBgList(); 
    applyGlobalCSS(); // 确保打开时加载 CSS 内容到输入框
}


function switchThemeTab(tab) {
    document.querySelectorAll('.theme-tab-content').forEach(el => el.style.display = 'none');
    document.getElementById('theme-tab-' + tab).style.display = 'block';
}
async function renderThemeIconsList() {
    const list = document.getElementById('app-icon-list');
    list.innerHTML = '';
    
    for (let app of APP_MAP) {
        const div = document.createElement('div');
        div.className = 'theme-app-item';
        const savedIcon = await idb.get('settings_heavy', `icon_${app.id}`);
        const bgStyle = savedIcon ? `background-image:url(${savedIcon.data})` : 'background:#ddd';
        
        div.innerHTML = `
            <div class="theme-icon-preview" style="${bgStyle}"></div>
            <div style="font-size:0.8rem;">${app.name}</div>
            <input type="file" style="display:none" id="upload_icon_${app.id}" onchange="saveAppIcon('${app.id}', this)">
        `;
        div.onclick = () => document.getElementById(`upload_icon_${app.id}`).click();
        list.appendChild(div);
    }
}

async function saveAppIcon(appId, input) {
    const file = input.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        await idb.put('settings_heavy', { key: `icon_${appId}`, data: e.target.result });
        renderThemeIconsList();
        applyAllThemeSettings();
    };
    reader.readAsDataURL(file);
}
async function uploadThemeImage(key, input) {
    const file = input.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        await idb.put('settings_heavy', { key: key, data: e.target.result });
        alert("设置成功！下次打开对应组件时生效。");
        applyAllThemeSettings(); 
    };
    reader.readAsDataURL(file);
}
function renderThemeFontsList() {
    const list = document.getElementById('font-config-list');
    list.innerHTML = '';
    const fonts = JSON.parse(localStorage.getItem('theme_fonts') || '{}');
    
    APP_MAP.forEach(app => {
        const val = fonts[app.id] || "";
        const div = document.createElement('div');
        div.className = 'font-setting-item'; // 使用新 CSS 类
        
        div.innerHTML = `
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <label style="margin:0;">${app.name}</label>
                <button class="m-btn small" onclick="testFont('${app.id}')" style="font-size:0.7rem; padding:2px 8px; background:#eee; color:#666;">测试</button>
            </div>
            <input type="text" value="${val}" 
                placeholder="粘贴字体链接 (https://...)" 
                style="width:100%; padding:8px; border:1px solid #ddd; border-radius:6px; margin-top:8px; font-size:0.85rem;"
                onblur="saveAppFont('${app.id}', this.value)"
            >
            <div style="font-size:0.7rem; color:#aaa; margin-top:4px;">
                当前字体预览：<span style="font-family: 'CustomFont${app.id}'; font-size:1rem; color:#333;">123 ABC 繁花似锦</span>
            </div>
        `;
        list.appendChild(div);
    });
}
window.testFont = function(appId) {
    alert(`已尝试加载 ${appId} 的字体，请看下方的预览文字是否变化。`);
}
function saveAppFont(appId, url) {
    const fonts = JSON.parse(localStorage.getItem('theme_fonts') || '{}');
    fonts[appId] = url;
    localStorage.setItem('theme_fonts', JSON.stringify(fonts));
    injectCustomFont(appId, url); 
}
function injectCustomFont(appId, url) {
    if(!url) return;
    
    const styleId = `style-font-${appId}`;
    let styleTag = document.getElementById(styleId);
    if(!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = styleId;
        document.head.appendChild(styleTag);
    }
    const fontName = `CustomFont${appId}`;

    const idMap = {
        'settings': 'settings-modal',
        'worldbook': 'wb-modal',
        'camera': 'camera-modal',
        'file': 'file-modal',
        'finance': 'finance-modal',
        'study': 'study-modal',
        'theater': 'theater-modal',
        'pickup': 'pickup-modal',
        'period': 'period-modal',
        'forum': 'forum-modal',
        'album': 'album-app-modal',       
        'anniversary': 'anniversary-modal',
        'dream': 'dream-app-modal',       
        'hisphone': 'his-phone-modal',    
        'fan': 'fan-modal',
        'chat': 'chat-modal',
        'tarot': 'tarot-app-modal',       
        'letter': 'letter-app-modal'      
    };
    let targetId = idMap[appId] || `${appId}-modal`; // 默认兜底
    let modalSelector = `#${targetId}`;
    
    styleTag.innerHTML = `
        @font-face { 
            font-family: '${fontName}'; 
            src: url('${url}'); 
            font-display: swap;
        }
        ${modalSelector}, 
        ${modalSelector} input, 
        ${modalSelector} textarea, 
        ${modalSelector} button,
        ${modalSelector} div,
        ${modalSelector} span,
        ${modalSelector} p { 
            font-family: '${fontName}', sans-serif !important; 
        }
    `;
    
    console.log(`已为 ${appId} (${modalSelector}) 应用字体: ${url}`);
}
async function handleStampUpload(input) {
    const files = Array.from(input.files);
    if(files.length === 0) return;
    
    let stamps = await idb.get('settings_heavy', 'reply_stamps');
    stamps = stamps ? stamps.data : [];
    
    for(let file of files) {
        await new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = (e) => {
                stamps.push(e.target.result);
                resolve();
            }
            reader.readAsDataURL(file);
        });
    }
    
    await idb.put('settings_heavy', { key: 'reply_stamps', data: stamps });
    renderStampList();
}

async function renderStampList() {
    const grid = document.getElementById('stamp-preview-grid');
    grid.innerHTML = '';
    let stamps = await idb.get('settings_heavy', 'reply_stamps');
    if(!stamps || !stamps.data) return;
    
    stamps.data.forEach((src, idx) => {
        const div = document.createElement('div');
        div.className = 'stamp-item';
        div.style.backgroundImage = `url(${src})`;
        div.innerHTML = `<div class="stamp-del" onclick="deleteStamp(${idx})">×</div>`;
        grid.appendChild(div);
    });
}

async function deleteStamp(index) {
    if(!confirm("删除此印章？")) return;
    let stamps = await idb.get('settings_heavy', 'reply_stamps');
    stamps.data.splice(index, 1);
    await idb.put('settings_heavy', { key: 'reply_stamps', data: stamps.data });
    renderStampList();
}
async function applyAllThemeSettings() {
    try {
        // 1. 应用图标逻辑
        if (typeof APP_MAP !== 'undefined') {
            for (let app of APP_MAP) {
                try {
                    const iconData = await idb.get('settings_heavy', `icon_${app.id}`);
                    if(iconData) {
                        const els = document.querySelectorAll(app.selector + ' .app-icon');
                        els.forEach(el => {
                            if(el) {
                                el.innerText = ''; 
                                el.style.backgroundImage = `url(${iconData.data})`;
                                el.style.backgroundSize = 'cover';
                                el.style.backgroundPosition = 'center';
                                el.style.border = 'none'; 
                                el.style.backgroundColor = 'transparent'; 
                                el.style.boxShadow = 'none'; 
                            }
                        });
                    }
                } catch(err) { console.log("图标加载略过", err); }
            }
        }

        // 2. 应用各种封面图片
        const imgKeys = [
            'main_bg', 'fridge_cover', 'news_cover', 'memo_cover', 
            'tarot_back', 'tarot_table', 'letter_paper', 
            'game_cover', 'game_bg', 'game_char_half', 'game_user_half',
            'diary_cover', 'diary_photo', 'lofter_cover',
            'rpg_user_idle', 'rpg_user_front', 'rpg_user_back', 'rpg_user_right', 'rpg_user_left', 'rpg_npc_idle'
        ];

        const images = {};
        for(let key of imgKeys) {
            try {
                const res = await idb.get('settings_heavy', key);
                if(res) images[key] = res.data;
            } catch(e) {}
        }

        if(images.main_bg) {
            const screen = document.getElementById('screen');
            if(screen) {
                screen.style.background = 'none'; 
                screen.style.backgroundColor = '#fff'; 
                screen.style.backgroundImage = `url(${images.main_bg})`;
                screen.style.backgroundSize = 'cover';
                screen.style.backgroundPosition = 'center';
                screen.style.backgroundRepeat = 'no-repeat';
            }
        }
        // ... (此处省略部分通用背景代码，如果你原代码有修改请保留，为了安全我加上了最关键的部分) ...
        if(images.fridge_cover) {
            const f = document.querySelector('.fridge-item-large');
            if(f) { f.style.backgroundImage = `url(${images.fridge_cover})`; f.style.backgroundSize = 'cover'; }
        }
        if(images.game_cover) {
            const g = document.getElementById('widget-game-bg');
            if(g) { g.src = images.game_cover; g.style.display='block'; const ph = document.querySelector('.game-console-widget .tv-placeholder'); if(ph) ph.style.display='none'; }
        }
        
        // 3. 应用字体逻辑
        if(window.BIG_MEMORY && window.BIG_MEMORY.theme_fonts) {
            const fonts = window.BIG_MEMORY.theme_fonts;
            for(let [appId, url] of Object.entries(fonts)) {
                if(typeof injectCustomFont === 'function') injectCustomFont(appId, url);
            }
        }

        // ================== 🔴 修复的插入部分 (带错误保护) START ==================
        if (typeof APP_BG_MAP !== 'undefined') {
            for (let item of APP_BG_MAP) {
                try {
                    // 读取数据
                    const bgData = await idb.get('settings_heavy', `bg_${item.id}`);
                    const modal = document.getElementById(item.modalId);
                    
                    if (modal && bgData && bgData.data) {
                        // 强制覆盖背景
                        modal.style.backgroundImage = `url(${bgData.data}) !important`; // 加 important 提高优先级
                        modal.style.backgroundSize = 'cover';
                        modal.style.backgroundPosition = 'center';
                        modal.style.backgroundRepeat = 'no-repeat';
                    }
                } catch(e) { }
            }
        }
      

        // 5. 应用全局 CSS
        if (typeof applyGlobalCSS === 'function') {
            await applyGlobalCSS();
        }
        // ================== 🔴 修复的插入部分 END ==================

    } catch (criticalError) {
        console.error("美化加载严重错误:", criticalError);
        // 这里捕获了错误，防止影响整个 APP 的点击事件
    }
}
let gameState = {
    mood: 50,
    love: 50,
    history: []
};
let gameTypeWriterTimer = null;
async function openGameApp() {
    document.getElementById('game-modal').style.display = 'flex';
    const savedStats = JSON.parse(localStorage.getItem('game_stats') || '{"mood":50, "love":50}');
    gameState.mood = savedStats.mood;
    gameState.love = savedStats.love;
    updateGameStatsUI();
    await loadGameAssets();
    rpgTypeWriter("您", "点击下方文本框输入内容，抽取命运牌决定剧情走向...", "");
    toggleHalfBodies('both'); 
}


function closeGameApp() {
    document.getElementById('game-modal').style.display = 'none';
    hideGameInput();
}

async function loadGameAssets() {
    const bg = await idb.get('settings_heavy', 'game_bg');
    if(bg) document.getElementById('game-container').style.backgroundImage = `url(${bg.data})`;
    const charImg = await idb.get('settings_heavy', 'game_char_half');
    if(charImg) {
        document.getElementById('game-img-char').src = charImg.data;
        document.getElementById('game-img-char').style.display = 'block';
    }
    const userImg = await idb.get('settings_heavy', 'game_user_half');
    if(userImg) {
        document.getElementById('game-img-user').src = userImg.data;
        document.getElementById('game-img-user').style.display = 'block';
    }
    const botAvatar = await idb.get('settings_heavy', 'botAvatar');
    if(botAvatar) document.getElementById('game-char-avatar').style.backgroundImage = `url(${botAvatar.data})`;
}
function showGameInput() {
    document.getElementById('game-input-layer').style.display = 'flex';
    toggleHalfBodies('user');
}

function hideGameInput() {
    document.getElementById('game-input-layer').style.display = 'none';
    toggleHalfBodies('both'); 
}

function toggleHalfBodies(showWho) {
    const charEl = document.getElementById('game-img-char');
    const userEl = document.getElementById('game-img-user');
    
    if(showWho === 'user') {
        charEl.classList.add('hb-hidden');
        userEl.classList.remove('hb-hidden');
    } else if (showWho === 'char') { 
        charEl.classList.remove('hb-hidden');
        userEl.classList.add('hb-hidden');
    } else { 
        charEl.classList.remove('hb-hidden');
        userEl.classList.remove('hb-hidden');
    }
}

function updateGameStatsUI() {
    document.getElementById('bar-mood').style.width = gameState.mood + '%';
    document.getElementById('val-mood').innerText = gameState.mood;
    document.getElementById('bar-love').style.width = gameState.love + '%';
    document.getElementById('val-love').innerText = gameState.love;
    
    localStorage.setItem('game_stats', JSON.stringify({ mood: gameState.mood, love: gameState.love }));
}
let gameActiveDeck = [];  
let gameFlippedCards = [];  
let pendingGameInput = "";    
function startGameDrawing() {
    const modal = document.getElementById('game-card-table-modal');
    const area = document.getElementById('game-card-area');
    area.innerHTML = ''; 
    gameActiveDeck = [];
    gameFlippedCards = [];
    document.getElementById('game-flipped-count').innerText = '0';
    let fullDeck = [];
    for(let i=0; i<=77; i++) fullDeck.push({ type: 'tarot', id: i, isReversed: Math.random() < 0.3 }); 
    for(let i=1; i<=36; i++) fullDeck.push({ type: 'lenormand', id: i, isReversed: false }); 
    fullDeck.sort(() => Math.random() - 0.5);
    gameActiveDeck = fullDeck;
    const deskW = window.innerWidth;
    const cardWidth = 60, cardHeight = 90, gapX = 10, gapY = 15;       
    let columns = Math.floor((deskW - 20) / (cardWidth + gapX));
    if (columns < 4) columns = 4;
    
    const startX = Math.max(0, (deskW - (columns * cardWidth + (columns - 1) * gapX)) / 2);
    const startY = 60;
    gameActiveDeck.forEach((card, index) => {
        const el = document.createElement('div');
        el.className = 'playing-card'; 
        
        const colIndex = index % columns;
        const rowIndex = Math.floor(index / columns);
        
        el.style.left = (startX + colIndex * (cardWidth + gapX)) + 'px';
        el.style.top = (startY + rowIndex * (cardHeight + gapY)) + 'px';
        el.style.transform = `rotate(${Math.random() * 6 - 3}deg)`; 
        el.onclick = () => flipGameCard(el, card);
        
        const front = document.createElement('div');
        front.className = 'playing-card-front';
        el.appendChild(front);
        
        area.appendChild(el);
    });
    
    const totalRows = Math.ceil(gameActiveDeck.length / columns);
    area.style.height = (startY + totalRows * (cardHeight + gapY) + 120) + 'px';

    modal.style.display = 'flex';
    applyGameTableTheme();
}

function closeGameCardTable() {
    document.getElementById('game-card-table-modal').style.display = 'none';
    showGameInput(); 
}
async function flipGameCard(el, cardData) {

    if(el.classList.contains('flipped')) {
        el.classList.remove('flipped');
        gameFlippedCards = gameFlippedCards.filter(c => !(c.type === cardData.type && c.id === cardData.id));
        setTimeout(() => {
            const frontEl = el.querySelector('.playing-card-front');
            if(frontEl) {
                frontEl.style.backgroundImage = ''; 
                frontEl.style.transform = ''; 
                frontEl.innerText = '';
            }
        }, 300);
    } else {
        el.classList.add('flipped');
        gameFlippedCards.push(cardData);
        
        const dbName = cardData.type === 'tarot' ? 'tarot_deck' : 'lenormand_deck';
        
        try {
            const item = await idb.get(dbName, cardData.id);
            const frontEl = el.querySelector('.playing-card-front');
            
            if (item && item.data) {
                frontEl.style.backgroundImage = `url(${item.data})`;
                frontEl.style.backgroundSize = 'cover'; 
                frontEl.style.backgroundPosition = 'center';
                frontEl.innerText = ''; 
                if(cardData.type === 'tarot' && cardData.isReversed) {
                    frontEl.style.transform = "rotateY(180deg) rotate(180deg)"; 
                } else {
                    frontEl.style.transform = "rotateY(180deg)";
                }
            } else {
                frontEl.style.backgroundColor = '#0984e3';
                frontEl.style.color = '#fff';
                frontEl.style.display = 'flex';
                frontEl.style.alignItems = 'center';
                frontEl.style.justifyContent = 'center';
                frontEl.style.fontSize = '0.7rem';
                frontEl.innerText = `${cardData.type}\n#${cardData.id}`;
                frontEl.style.transform = "rotateY(180deg)";
            }
        } catch(e) {
            console.error("加载图片失败:", e);
        }
    }
    const countEl = document.getElementById('game-flipped-count');
    if(countEl) countEl.innerText = gameFlippedCards.length;
}
async function finishGameDrawing() {
    if(gameFlippedCards.length === 0) return alert("请至少翻一张牌！");
    document.getElementById('game-card-table-modal').style.display = 'none';
    await processGameTurn(pendingGameInput, gameFlippedCards);
}
async function applyGameTableTheme() {
    const res = await idb.get('settings_heavy', 'tarot_table');
    if(res && res.data) {
        document.getElementById('game-card-table-desk').style.backgroundImage = `url(${res.data})`;
        document.getElementById('game-card-table-desk').style.backgroundSize = 'cover';
    }
}

// 4. 新的触发函数 (链接到上面的新逻辑)
function triggerGameDraw() {
    const inputEl = document.getElementById('game-user-input');
    const text = inputEl.value;
    
    if(!text) return alert("请输入行动/对话内容");
    pendingGameInput = text;
    hideGameInput();
    startGameDrawing();
}
// === 3. 游戏机逻辑修改：原版提示词风格 + Line名字 + 强牌意数值 ===
async function processGameTurn(userInput, cards) {
    // 1. 设置系统正在输入状态
    rpgTypeWriter("System", "正在解析牌意能量并生成回应...", "Loading...");
    toggleHalfBodies('char'); 
    
    // 2. 准备基础数据
    const cardsDesc = cards.map(c => (c.type==='tarot'?TAROT_NAMES[c.id]:LENORMAND_NAMES[c.id]) + (c.isReversed?"(逆)":"")).join(", ");
    const wb = window.getWBData();
    const globalCtx = (wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    const msgCtx = (wb['5.传讯'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    
    // 获取历史记录用于上下文
    const history = (window.BIG_MEMORY.game_history || []).slice(0, 5); // 取最近5条即可，避免token过多
    const historyText = history.map(h => `User: ${h.user}\nChar: ${h.reply}`).join("\n");

    // 🔥【关键修改1】获取 Line (聊天APP) 的设置名字
    const chatSettings = window.getChatSettings(); 
    const charName = chatSettings.title || "Target"; // 如果没设置，默认叫 Target

    // 3. API Key 检查
    let apiKey = document.getElementById('api-key').value;
    let apiUrl = document.getElementById('api-url').value;
    let model = document.getElementById('model-select').value;
    
    if(!apiKey) {
        try { const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}'); apiKey=s.key; apiUrl=s.url; model=s.model; } catch(e){}
    }
    if(!apiKey) return alert("请先配置 API Key");

    // 4. 构建提示词 (原版风格 + 数值强化)
    const prompt = `
你现在正在进行一个 RPG 角色扮演游戏。
【世界观/人设】：
${globalCtx}
${msgCtx}
【当前扮演角色名】：${charName}

【当前状态】：
- 心情值：${gameState.mood}/100
- 好感度：${gameState.love}/100
- 刚刚抽到的命运牌：${cardsDesc}

【对话历史】：
${historyText}

【用户输入】：
${userInput}

【任务】：
1. **解牌**：首先根据【命运牌】的含义和正逆位，决定角色当下的情绪、语气和潜意识反应。这是最重要的依据。
2. **状态变更 (必须严格基于牌意)**：
   - 牌意积极/结合/快乐 (如圣杯、恋人、太阳) -> 数值必须增加 (+)。
   - 牌意消极/分离/痛苦 (如宝剑3、高塔、死神) -> 数值必须减少 (-)。
   - 范围：-10 到 +10。
3. **回复**：以【${charName}】的口吻回复用户。
   - 字数限制：简短，不超过 100 字。
   - **绝对禁止**在回复文本中直接出现牌的名字（如“因为抽到了死神牌...”），要将牌意转化为自然的对话。

【输出格式】：
严格 JSON：
{
  "interpretation": "简短的解牌思路（用于展示给用户看牌意）",
  "reply": "角色的回复内容...",
  "mood_change": 5,
  "love_change": 2
}
`;

    try {
        const res = await fetch(`${apiUrl || "https://api.openai.com/v1"}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model || "gpt-3.5-turbo",
                messages: [{role: "system", content: "You are a roleplay engine. Output JSON only."}, {role: "user", content: prompt}],
                temperature: 0.8
            })
        });
        const json = await res.json();
        let raw = json.choices[0].message.content.replace(/```json/g,"").replace(/```/g,"").trim();
        const result = JSON.parse(raw);
        
        // 更新数值
        gameState.mood = Math.min(100, Math.max(0, gameState.mood + result.mood_change));
        gameState.love = Math.min(100, Math.max(0, gameState.love + result.love_change));
        window.updateGameStatsUI(); // 保存到无限存储
        
        const cardDisplayStr = `[${cardsDesc}] ${result.interpretation}`;
        
        // 🔥【关键修改2】使用获取到的 Line 名字显示
        rpgTypeWriter(charName, result.reply, cardDisplayStr);
        
        // 保存历史
        window.saveGameHistory(userInput, result.reply, cardDisplayStr);
        
        document.getElementById('game-user-input').value = '';

    } catch(e) {
        console.error(e);
        rpgTypeWriter("System", "连接中断... (API Error)", "");
    }
}
function rpgTypeWriter(name, text, subInfo) {
    const nameEl = document.getElementById('rpg-name');
    const contentEl = document.getElementById('rpg-content');
    const infoEl = document.getElementById('rpg-cards-info');
    
    nameEl.innerText = name;
    infoEl.innerText = subInfo;
    contentEl.innerHTML = '';
    
    if(gameTypeWriterTimer) clearInterval(gameTypeWriterTimer);
    
    let i = 0;
    gameTypeWriterTimer = setInterval(() => {
        contentEl.innerText += text.charAt(i);
        i++;
        if(i >= text.length) {
            clearInterval(gameTypeWriterTimer);
            contentEl.innerHTML += '<span class="rpg-cursor"></span>';
        }
    }, 50);
}

function toggleGameHistory() {
    const p = document.getElementById('game-history-panel');
    p.classList.toggle('open');
    if(p.classList.contains('open')) renderGameHistory();
}
async function loadGameWidgetTheme() {
    try {
        const cover = await idb.get('settings_heavy', 'game_cover');
        if(cover && cover.data) {
            const el = document.getElementById('widget-game-bg');
            if(el) { 
                el.src = cover.data; 
                el.style.display='block'; 
                const ph = document.querySelector('.game-console-widget .tv-placeholder');
                if(ph) ph.style.display='none'; 
            }
        }
    } catch(e) {
        console.log("游戏机封面加载跳过");
    }
}
window.BIG_MEMORY = {
    world_book: {},
    letters: [],
    finance: [],
    study: null,
    period: { records: [], isBleeding: false, lastAnalysis: null },
    memo: ""
};
async function loadAllBigData() {
    console.log("🚀 正在启动无限容量引擎 (全量版)...");
    
    // 1. 定义所有需要无限存储的 Key (包括词库、记账、经期等)
    const keys = [
        // 核心数据
        { dbKey: 'world_book', localKey: 'world_book_data', def: {} },
        { dbKey: 'letters',    localKey: 'letter_history',  def: [] },
        // 之前遗漏的功能
        { dbKey: 'thesaurus_data', localKey: 'thesaurus_data', def: {reply:[], note:[], expense:[], income:[]} }, // 词库
        { dbKey: 'finance',    localKey: 'finance_data',    def: [] },    // 记账
        { dbKey: 'period',     localKey: 'period_data',     def: { records: [], isBleeding: false } }, // 经期
        { dbKey: 'forum_data', localKey: 'forum_history_list', def: [] }, // 论坛体历史
        { dbKey: 'theater_data', localKey: 'theater_list', def: [] },     // 小剧场历史
        // 其他 App
        { dbKey: 'study',      localKey: 'study_plan_data', def: null },
        { dbKey: 'memo',       localKey: 'desktop_memo',    def: "" },
        { dbKey: 'game_history', localKey: 'game_history_log', def: [] },
        { dbKey: 'game_stats',   localKey: 'game_stats',       def: { mood: 50, love: 50 } },
        { dbKey: 'tarot_history', localKey: 'tarot_history', def: [] },
        { dbKey: 'his_phone_history', localKey: 'his_phone_history', def: [] },
        { dbKey: 'dream_history', localKey: 'dream_history', def: [] },
        { dbKey: 'pickup_history', localKey: 'pickup_data_history', def: [] }, // 捡手机
        { dbKey: 'diary_history', localKey: 'diary_history', def: [] },
        { dbKey: 'pet_data',      localKey: 'pet_data',      def: { config:{}, stats:{}, inventory:{coins:0, items:{}} } },
        { dbKey: 'lofter_data',   localKey: 'lofter_data',   def: [] },
        { dbKey: 'pain_data',     localKey: 'pain_data',     def: { his:[], my:[] } },
        { dbKey: 'shadow_data',   localKey: 'shadow_data',   def: [] },
        { dbKey: 'gashapon_history', localKey: 'gashapon_history', def: [] },
        { dbKey: 'rpg_data',      localKey: 'rpg_data',      def: { history:[], chat_history:[] } },
        { dbKey: 'chat_settings', localKey: 'chat_settings', def: {} },
        { dbKey: 'summary_data',  localKey: 'summary_data',  def: [] }
    ];

    // 2. 遍历加载，如果数据库没数据，就吸取 localStorage 的老数据
    for (let item of keys) {
        try {
            let res = await idb.get('universal_store', item.dbKey);
            
            if (res) {
                // 数据库有数据，直接用
                window.BIG_MEMORY[item.dbKey] = res.data;
            } else {
                // 数据库没数据，尝试迁移老版本 LocalStorage
                let oldStr = localStorage.getItem(item.localKey);
                if (oldStr) {
                    try {
                        let oldVal = (item.dbKey === 'memo') ? oldStr : JSON.parse(oldStr);
                        window.BIG_MEMORY[item.dbKey] = oldVal;
                        // 存入无限数据库
                        await idb.put('universal_store', { id: item.dbKey, data: oldVal });
                        console.log(`✅ 已迁移 ${item.dbKey} 到无限存储`);
                        // 迁移成功后可选：localStorage.removeItem(item.localKey); 
                    } catch(e) { window.BIG_MEMORY[item.dbKey] = item.def; }
                } else {
                    window.BIG_MEMORY[item.dbKey] = item.def;
                }
            }
        } catch (e) { 
            console.error(`加载 ${item.dbKey} 失败`, e); 
            window.BIG_MEMORY[item.dbKey] = item.def;
        }
    }
    
    // 3. 刷新所有界面 (确保数据加载后立即显示)
    if(typeof renderLetterList === 'function') renderLetterList();
    if(typeof renderFinanceUI === 'function') renderFinanceUI();
    if(typeof updateGameStatsUI === 'function') updateGameStatsUI();
    
    console.log("✅ 无限存储加载完毕，所有功能已就绪。");
}
function saveToBigDB(key, data) {
    window.BIG_MEMORY[key] = data;
    idb.put('universal_store', { id: key, data: data });
}
// === 最终整合版：日记系统 (原版生成逻辑 + 历史/删除功能) ===

let diaryDeck = [];
let diaryFlipped = [];
let currentDiaryIndex = -1; // -1 表示查看最新/正在生成，>=0 表示查看历史

// 1. 历史记录辅助函数
function getDiaryHistory() { 
    return window.BIG_MEMORY.diary_history || []; 
}

function saveDiaryHistoryToList(record) {
    const list = getDiaryHistory();
    // 逻辑：如果今天已经生成过，覆盖今天的记录；如果是新的一天，插入头部
    const today = new Date().toLocaleDateString();
    
    // 检查最新的记录是否是今天的
    if (list.length > 0 && list[0].date === today) {
        list[0] = { ...record, date: today }; // 覆盖
    } else {
        list.unshift({ ...record, date: today }); // 新增
    }
    
    // 限制历史数量（例如保留最近100天）
    if(list.length > 100) list.pop(); 
    
    // 存入无限数据库
    saveToBigDB('diary_history', list);
}

// 2. 打开日记 APP
async function openDiaryApp() {
    document.getElementById('diary-app-modal').style.display = 'flex';
    
    const list = getDiaryHistory();
    
    // 如果有历史，默认显示最新的一篇（即 list[0]）
    if(list.length > 0) {
        renderDiaryUI(list[0]);
        currentDiaryIndex = 0;
    } else {
        // 没有任何记录时的初始状态
        document.getElementById('d-date-display').innerText = new Date().toLocaleDateString();
        document.getElementById('diary-text-content').innerHTML = '<div class="skeleton-text" style="margin-top:50px;">点击下方按钮，开始书写第一篇日记...</div>';
        document.getElementById('bag-items-list').innerHTML = '';
        // 重置状态栏
        document.getElementById('d-mood').innerText = "--";
        document.getElementById('d-clean').innerText = "--";
        document.getElementById('d-food').innerText = "--";
        document.getElementById('d-money').innerText = "--";
        currentDiaryIndex = -1;
    }
    
    // 加载美化照片 (贴在日记中间的照片)
    try {
        const photo = await idb.get('settings_heavy', 'diary_photo');
        if(photo && photo.data) {
            const img = document.getElementById('diary-central-photo');
            img.src = photo.data;
            img.style.display = 'block';
        }
    } catch(e) {}
}

// 3. 开启抽牌 (保持游戏组件一样的逻辑)
function startDiaryDrawing() {
    const modal = document.getElementById('diary-card-table-modal');
    const area = document.getElementById('diary-card-area');
    area.innerHTML = '';
    diaryDeck = [];
    diaryFlipped = [];
    document.getElementById('diary-flipped-count').innerText = '0';

    // 混合牌库：78张塔罗 + 36张雷诺曼
    for(let i=0; i<=77; i++) diaryDeck.push({ type: 'tarot', id: i, isReversed: Math.random() < 0.3 });
    for(let i=1; i<=36; i++) diaryDeck.push({ type: 'lenormand', id: i, isReversed: false });
    diaryDeck.sort(() => Math.random() - 0.5);

    const deskW = window.innerWidth;
    const cardWidth = 60, cardHeight = 90, gap = 10;
    let cols = Math.floor((deskW - 20) / (cardWidth + gap)); if(cols<4) cols=4;
    const startX = (deskW - (cols * (cardWidth+gap))) / 2;

    diaryDeck.forEach((card, i) => {
        const el = document.createElement('div');
        el.className = 'playing-card';
        const col = i % cols, row = Math.floor(i / cols);
        el.style.left = (startX + col*(cardWidth+gap)) + 'px';
        el.style.top = (60 + row*(cardHeight+gap)) + 'px';
        el.style.transform = `rotate(${Math.random()*6-3}deg)`;
        
        const front = document.createElement('div');
        front.className = 'playing-card-front';
        el.appendChild(front);
        
        el.onclick = async () => {
            if(el.classList.contains('flipped')) {
                el.classList.remove('flipped');
                diaryFlipped = diaryFlipped.filter(c => !(c.type===card.type && c.id===card.id));
            } else {
                el.classList.add('flipped');
                diaryFlipped.push(card);
                const dbName = card.type==='tarot'?'tarot_deck':'lenormand_deck';
                const item = await idb.get(dbName, card.id);
                if(item && item.data) front.style.backgroundImage = `url(${item.data})`;
                else { front.style.backgroundColor='#ddd'; front.innerText=card.id; }
                if(card.isReversed) front.style.transform = "rotateY(180deg) rotate(180deg)";
                else front.style.transform = "rotateY(180deg)";
            }
            document.getElementById('diary-flipped-count').innerText = diaryFlipped.length;
        };
        area.appendChild(el);
    });
    
    // 应用牌桌皮肤
    idb.get('settings_heavy', 'tarot_table').then(res => {
        if(res && res.data) document.getElementById('diary-card-table-desk').style.backgroundImage = `url(${res.data})`;
    });
    
    modal.style.display = 'flex';
}

// 4. 【核心生成逻辑】 (这里完全保留了你想要的原版 Prompt)
async function finishDiaryDrawing() {
    if(diaryFlipped.length === 0) return alert("请至少翻一张牌！");
    document.getElementById('diary-card-table-modal').style.display = 'none';
    
    const contentDiv = document.getElementById('diary-text-content');
    contentDiv.innerHTML = '<div class="skeleton-text">正在根据牌意回溯记忆...</div>';

    // 准备 Prompt 数据
    const cardsDesc = diaryFlipped.map(c => (c.type==='tarot'?TAROT_NAMES[c.id]:LENORMAND_NAMES[c.id]) + (c.isReversed?"(逆)":"")).join(", ");
    const wb = getWBData();
    const globalCtx = (wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    const diaryCtx = (wb['14.日记'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n"); // 记得在世界书里加这个分类
    
    let apiKey = document.getElementById('api-key').value;
    let apiUrl = document.getElementById('api-url').value || "https://api.openai.com/v1";
    let model = document.getElementById('model-select').value || "gpt-3.5-turbo";
    if(!apiKey) return alert("API Key 未配置");

    // === 原版 Prompt ===
    const prompt = `
你现在正在以第一人称撰写日记。
【角色设定】: ${globalCtx}
【日记特别设定】: ${diaryCtx}
【今日命运牌 (必须完全基于牌意生成今日经历)】: ${cardsDesc}

【任务要求】
1. **生成状态值**：心情(Mood), 清洁度(Cleanliness), 饱食度(Hunger), 金钱(Money)。范围0-100或简短描述。
2. **生成日记正文**：
   - 第一人称 ("我")。
   - 字数**不少于500字**。
   - 必须包含今日发生的事件、心声、感受。
   - **绝对不要**在正文中直接提到“我抽到了XX牌”，而是将牌意转化为情节（例如抽到宝剑三写心痛的事，抽到星币写工作赚钱）。
   - 风格要像真实的私人日记，极具代入感。
3. **生成背包物品 (Bag Check)**：
   - 根据牌意推测他今天出门带了什么。
   - 需要物品名称 + **详细的样式描述**。
   - 每个物品必须有一个**不少于50字的注释**，解释为什么带这个（例如为了工作、为了防身、或是某人送的）。
4. **生成今日穿搭 (OOTD)**：
   - 根据牌意(如圣杯=温柔, 权杖=活力, 宝剑=干练)和天气/心情决定。
   - 描述风格、上装、下装、配饰。

【输出格式】
严格 JSON 格式：
{
  "stats": { "mood": "开心", "clean": "刚洗澡", "food": "80%", "money": "富裕" },
  "diary_text": "日记正文内容...",
"ootd": "今日穿搭描述文案...",
  "bag_items": [
    { "name": "物品名", "style": "详细样式描述...", "note": "不少于50字的注释..." },

    { "name": "...", "style": "...", "note": "..." }
  ]
}
`;

    try {
        const res = await fetch(`${apiUrl}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model,
                messages: [{role: "system", content: "You are a creative writer. Output JSON only."}, {role: "user", content: prompt}],
                temperature: 0.8
            })
        });
        
        const json = await res.json();
        let raw = json.choices[0].message.content.replace(/```json/g,"").replace(/```/g,"").trim();
        const result = JSON.parse(raw);
        
        // 【关键连接点】：生成完后，直接保存到历史记录列表
        saveDiaryHistoryToList(result);
        
        // 渲染 UI (视为查看最新的一条)
        renderDiaryUI(result);
        currentDiaryIndex = 0; 
        
        // 更新桌面预览文字
        document.getElementById('desktop-diary-preview').innerText = result.diary_text.substring(0, 100) + "...";

    } catch(e) {
        console.error(e);
        alert("生成失败: " + e.message);
    }
}

// 5. 渲染 UI 函数
function renderDiaryUI(data) {
    if(!data) return;
    
    // 渲染状态栏
    document.getElementById('d-mood').innerText = data.stats?.mood || "-";
    document.getElementById('d-clean').innerText = data.stats?.clean || "-";
    document.getElementById('d-food').innerText = data.stats?.food || "-";
    document.getElementById('d-money').innerText = data.stats?.money || "-";
    document.getElementById('d-date-display').innerText = "DATE: " + (data.date || new Date().toLocaleDateString());
    
    // 渲染正文
    document.getElementById('diary-text-content').innerHTML = (data.diary_text || "").replace(/\n/g, "<br>");
        // 渲染穿搭 (新增)
    const ootdEl = document.getElementById('diary-ootd-content');
    if(ootdEl) ootdEl.innerText = data.ootd || "今日随心搭配...";
    // 渲染背包
    const bagList = document.getElementById('bag-items-list');
    bagList.innerHTML = '';
    if(data.bag_items && Array.isArray(data.bag_items)) {
        data.bag_items.forEach(item => {
            const div = document.createElement('div');
            div.className = 'bag-item-box';
            div.innerHTML = `
                <div class="bag-item-name">${item.name}</div>
                <div style="font-size:0.8rem; color:#666;">${item.style}</div>
                <div class="bag-item-note">📝 ${item.note}</div>
            `;
            bagList.appendChild(div);
        });
    }
    
    // UI 重置：显示“查看背包”按钮，隐藏物品列表
    document.getElementById('bag-check-section').style.display = 'none';
    document.getElementById('bag-cover-section').style.display = 'flex';
}

function toggleBagCheck() {
    document.getElementById('bag-check-section').style.display = 'flex';
    document.getElementById('bag-cover-section').style.display = 'none';
}

// 6. 侧边栏历史记录列表
function toggleDiaryHistory() {
    const panel = document.getElementById('diary-history-panel');
    panel.classList.toggle('open');
    if(panel.classList.contains('open')) {
        renderDiaryHistoryList();
    }
}

function renderDiaryHistoryList() {
    const list = getDiaryHistory();
    const container = document.getElementById('diary-history-list');
    container.innerHTML = '';
    
    if(list.length === 0) {
        container.innerHTML = '<div style="text-align:center;color:#999; padding:20px;">暂无日记</div>';
        return;
    }

    list.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'morandi-card';
        div.style.padding = '10px';
        div.style.cursor = 'pointer';
        
        // 如果当前正在看这一篇，加个高亮边框
        if(index === currentDiaryIndex) div.style.border = "2px solid #8d6e63";
        
        const mood = item.stats ? item.stats.mood : '-';
        const preview = item.diary_text ? item.diary_text.substring(0, 20) + "..." : "无内容";
        
        div.innerHTML = `
            <div style="display:flex; justify-content:space-between;">
                <span style="font-weight:bold; font-size:0.9rem;">${item.date}</span>
                <span style="font-size:0.7rem; color:#888;">Mood: ${mood}</span>
            </div>
            <div style="font-size:0.8rem; color:#666; margin:5px 0;">${preview}</div>
            <div style="text-align:right;">
                <button class="m-btn small" onclick="event.stopPropagation(); deleteDiaryEntry(${index})" style="background:#ff6b6b; color:white; padding:2px 8px; font-size:0.7rem;">删除</button>
            </div>
        `;
        
        // 点击切换查看内容
        div.onclick = () => {
            currentDiaryIndex = index;
            renderDiaryUI(item);
            document.getElementById('diary-history-panel').classList.remove('open');
        };
        container.appendChild(div);
    });
}

// 7. 删除功能
function deleteDiaryEntry(index) {
    if(!confirm("🔥 确定要销毁这篇日记吗？（不可恢复）")) return;
    
    const list = getDiaryHistory();
    list.splice(index, 1);
    saveToBigDB('diary_history', list); // 保存更新
    
    // 如果删除了当前正在看的，清空界面
    if (index === currentDiaryIndex) {
        if (list.length > 0) {
            currentDiaryIndex = 0;
            renderDiaryUI(list[0]);
        } else {
            currentDiaryIndex = -1;
            document.getElementById('diary-text-content').innerHTML = '';
            document.getElementById('bag-items-list').innerHTML = '';
            document.getElementById('d-date-display').innerText = '--/--/--';
        }
    } else if (index < currentDiaryIndex) {
        // 如果删除了前面的索引，当前索引要减1
        currentDiaryIndex--;
    }
    
    renderDiaryHistoryList();
}
window.addEventListener('load', function() {
    
    console.log("页面元素加载完毕，开始启动系统...");
    idb.init().then(async () => {
        await loadAllBigData(); 
        loadTVContent(); 
        if(typeof loadGameWidgetTheme === 'function') {
            loadGameWidgetTheme();
        }

        try {
            await idb.get('settings_heavy', 'myAvatar'); 
        } catch(e) {
            console.log("预热数据库连接...");
        }
        
        console.log("系统启动完毕！所有组件已就绪。");
    });
});
    // === 新增：监听 Page 4 可见性，控制 Dock 栏显示/隐藏 ===
   // === 替换原有的 page4Observer 代码 ===// === 修复：Page 4 滑动监听 & 自动领养 ===
const page4Observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        const dock = document.querySelector('.dock-bar');
        
        if (entry.isIntersecting) {
            // 1. 隐藏 Dock 栏
            if(dock) dock.style.display = 'none';
            
            // 2. 获取数据 (确保从大内存获取)
            const data = window.BIG_MEMORY.pet_data;
            
            // 3. 强制渲染一次背景 (解决背景为空的问题)
            // 即使没有宠物，也要先渲染背景图
            if (typeof renderPetMain === 'function') {
                renderPetMain(); 
            }

            // 4. 检查是否需要领养
            if (!data || !data.config || !data.config.type) {
                console.log("检测到未领养，弹出窗口...");
                setTimeout(() => {
                    if(typeof openAdoptionModal === 'function') openAdoptionModal();
                }, 300); // 稍微延迟一点，体验更好
            } else {
                // 如果有宠物，启动循环
                if(typeof startPetLoop === 'function') startPetLoop();
            }
        } else {
            // 离开 Page 4，显示 Dock 栏
            if(dock) dock.style.display = 'flex';
        }
    });
}, { threshold: 0.5 }); // 阈值设为 0.5，滑到一半就触发

// 启动监听
setTimeout(() => {
    const page4El = document.getElementById('page4');
    if (page4El) page4Observer.observe(page4El);
}, 1000);
// === 修复：加载数据列表，加入 rpg_data ===// ==================== 🚀 核心：无限存储加载器 (修复版) ====================
// ==================== 🚀 核心：无限存储加载器 (修复版) ====================
async function loadAllBigData() {
    console.log("🚀 正在启动无限容量引擎...");
    
    // 1. 定义所有需要无限存储的 Key
    const keys = [
        'world_book', 'letters', 'finance', 'study', 'period', 'memo', 
        'game_history', 'game_stats', // 游戏数据
        'tarot_history', 'his_phone_history', 'dream_history', 'forum_history', 
        'pickup_history', 'diary_history', 'pet_data', 'lofter_data', 
        'pain_data', 'gashapon_history', 'shadow_data', 'rpg_data',
        'chat_settings', 'chat_history' // 聊天数据
    ];

    // 2. 初始化内存对象
    for (let key of keys) {
        try {
            let res = await idb.get('universal_store', key);
            if (res) {
                window.BIG_MEMORY[key] = res.data;
            } else {
                // 如果数据库没有，尝试从旧 localStorage 迁移一次
                let oldStr = localStorage.getItem(key);
                
                // 特殊处理默认值
                let defVal = [];
                if(key === 'game_stats') defVal = { mood: 50, love: 50 };
                else if(key === 'pet_data') defVal = { 
                    config: { name: "", type: "", img: "" },
                    stats: { hunger: 80, clean: 80, mood: 100, last_update: Date.now(), last_pat: 0 },
                    inventory: { coins: 0, items: {}, unlocked_bg: ['bg_default'], unlocked_decor: [] },
                    state: { bg: 'bg_default', active_decor: [] },
                    history: [],
                    tasks: { last_checkin: 0, chat_count: 0 }
                };
                else if(key.includes('data') || key.includes('settings')) defVal = {};

                if (oldStr) {
                    try {
                        let oldVal = JSON.parse(oldStr);
                        window.BIG_MEMORY[key] = oldVal;
                        // 迁移后存入数据库
                        idb.put('universal_store', { id: key, data: oldVal });
                    } catch(e) { window.BIG_MEMORY[key] = defVal; }
                } else {
                    // 默认空值
                    window.BIG_MEMORY[key] = defVal;
                }
            }
        } catch (e) { console.error(`加载 ${key} 失败`, e); }
    }
    
    console.log("✅ 无限存储加载完毕，宠物数据已就绪。");
}
window.getWBData = function() { return window.BIG_MEMORY.world_book || {}; };
window.saveWBData = function(data) { saveToBigDB('world_book', data); };
window.getLetters = function() { return window.BIG_MEMORY.letters || []; };
window.saveLetters = function(data) { saveToBigDB('letters', data); };

window.getFinanceData = function() { return window.BIG_MEMORY.finance || []; };
const _originalAddFinance = window.addFinanceRecord;// 注意：原 addFinanceRecord 可能在下面，直接覆盖整个函数
window.addFinanceRecord = function(category, type) {
    const amountIn = document.getElementById('finance-amount');
    const val = parseFloat(amountIn.value);
    
    if (!val || val <= 0) {
        alert("请先输入金额，再点击分类按钮入账。");
        return;
    }

    const thesaurus = getThesaurusData(); 
    const dictKey = type === 'expense' ? 'expense' : 'income';
    const words = thesaurus[dictKey] || [];
    const randomDesc = words.length > 0 
        ? words[Math.floor(Math.random() * words.length)] 
        : (type === 'expense' ? '今日支出' : '今日入账');

    const record = {
        id: Date.now(),
        date: new Date().toISOString(), 
        category: category,    
        type: type,
        amount: val,
        desc: randomDesc             
    };

    // 读取 -> 写入内存 -> 存入数据库
    const data = getFinanceData();
    data.unshift(record);
    
    window.BIG_MEMORY.finance = data;
    if(typeof idb !== 'undefined') idb.put('universal_store', { id: 'finance', data: data });

    amountIn.value = '';
    currentFinanceView = new Date().toISOString().slice(0, 7);
    renderFinanceUI();
}

window.deleteFinance = function(id) {
    if (confirm("确定删除这条账目？")) {
        let data = getFinanceData();
        data = data.filter(i => i.id !== id);
        
        window.BIG_MEMORY.finance = data;
        if(typeof idb !== 'undefined') idb.put('universal_store', { id: 'finance', data: data });
        
        renderFinanceUI();
    }
}

window.getStudyData = function() { return window.BIG_MEMORY.study; };
window.saveStudyData = function(data) { saveToBigDB('study', data); };
window.getPeriodData = function() { return window.BIG_MEMORY.period || { records: [], isBleeding: false, lastAnalysis: null }; };
window.savePeriodData = function(data) { saveToBigDB('period', data); };
window.loadMemoFromLocal = function() {
    const text = window.BIG_MEMORY.memo || "";
    if(document.getElementById('desktop-memo-text')) document.getElementById('desktop-memo-text').innerText = text || "点击编辑备忘录...";
    if(document.getElementById('memo-full-text')) document.getElementById('memo-full-text').value = text;
};
window.saveMemoToLocal = function() {
    const text = document.getElementById('memo-full-text').value;
    saveToBigDB('memo', text); 
    document.getElementById('desktop-memo-text').innerText = text || "点击编辑备忘录...";
};
window.updateGameStatsUI = function() {
    document.getElementById('bar-mood').style.width = gameState.mood + '%';
    document.getElementById('val-mood').innerText = gameState.mood;
    document.getElementById('bar-love').style.width = gameState.love + '%';
    document.getElementById('val-love').innerText = gameState.love;
    saveToBigDB('game_stats', { mood: gameState.mood, love: gameState.love });
};
window.saveGameHistory = function(user, reply, note) {
    const list = window.BIG_MEMORY.game_history || [];
    list.unshift({ id: Date.now(), date: new Date().toLocaleString(), user, reply, note });
    if(list.length > 50) list.pop();
    saveToBigDB('game_history', list);
};
// --- 开始复制 ---

// 1. 新增：彻底删除游戏记录的函数
window.deleteGameHistory = function(index) {
    if(!confirm("确定要永久删除这条剧情吗？")) return;
    
    // 从内存中获取当前列表
    const list = window.BIG_MEMORY.game_history || [];
    
    // 删除指定位置的记录
    list.splice(index, 1);
    
    // 保存更新后的列表到大数据库
    saveToBigDB('game_history', list);
    
    // 【核心修改】强制清除旧版 LocalStorage 缓存
    // 这就是“不能读取已删除内容”的关键，防止旧数据复活
    localStorage.removeItem('game_history_log'); 
    
    // 刷新界面
    renderGameHistory();
};

// 2. 修改：渲染函数（增加了删除按钮的 HTML）
window.renderGameHistory = function() {
    const list = window.BIG_MEMORY.game_history || [];
    const container = document.getElementById('game-history-list');
    container.innerHTML = '';
    
    if (list.length === 0) {
        container.innerHTML = '<div style="text-align:center;color:#999;padding:10px;">暂无冒险记录</div>';
        return;
    }

    list.forEach((item, idx) => {
        const div = document.createElement('div');
        div.className = 'morandi-card'; 
        div.style.padding = '10px';
        
        // 注意下面的 innerHTML 变化：增加了顶部的一排布局，包含时间和删除按钮
        div.innerHTML = `
            <div style="display:flex; justify-content:space-between; align-items:center; border-bottom:1px dashed #eee; padding-bottom:5px; margin-bottom:5px;">
                <span style="font-size:0.7rem; color:#888;">${item.date}</span>
                <button onclick="deleteGameHistory(${idx})" style="border:none; background:transparent; color:#ff6b6b; font-weight:bold; cursor:pointer; font-size:1.2rem; padding:0 5px;">×</button>
            </div>
            <div style="color:#555; font-size:0.9rem;"><strong>You:</strong> ${item.user}</div>
            <div style="margin-top:5px; color:#2c3e50; font-size:0.9rem;"><strong>Char:</strong> ${item.reply}</div>
            <div style="font-size:0.7rem; color:#97a89e; margin-top:5px; font-style:italic;">${item.note}</div>
        `;
        container.appendChild(div);
    });
};
window.saveDivinationResult = function() {
    if (!tarotState.lastResult) return alert("没有结果可保存");
    let history = window.BIG_MEMORY.tarot_history || [];
    history.unshift(tarotState.lastResult);
    if(history.length > 50) history = history.slice(0,50);
    saveToBigDB('tarot_history', history);
    alert("✅ 已保存到灵视档案");
    loadTarotHistory();
};

window.loadTarotHistory = function() {
    const list = document.getElementById('tarot-history-list'); list.innerHTML = '';
    const history = window.BIG_MEMORY.tarot_history || [];
    if(history.length === 0) { list.innerHTML = "<div style='padding:10px;text-align:center'>暂无记录</div>"; return; }
    history.forEach((h, i) => {
        const div = document.createElement('div'); div.className = 'morandi-card'; div.style.padding = '10px';
        div.innerHTML = `<div style="font-size:0.8rem; color:#888;">${new Date(h.date).toLocaleDateString()}</div><div style="font-weight:bold;">Q: ${h.question}</div><div style="font-size:0.75rem;">🎴 ${h.cardsText}</div><div style="text-align:right;"><button class="m-btn small" onclick="viewHistoryDetail_BigDB(${i})">查看</button></div>`;
        list.appendChild(div);
    });
};
window.viewHistoryDetail_BigDB = function(index) {
    const h = (window.BIG_MEMORY.tarot_history || [])[index];
    if(!h) return;
    document.getElementById('tarot-desk-area').style.display = 'none';
    document.getElementById('tarot-result-area').style.display = 'flex';
    document.getElementById('divination-output').style.display = 'block';
    const htmlText = h.rawText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>');
    document.getElementById('output-content').innerHTML = `<div class="divination-md">${htmlText}</div>`;
    document.getElementById('divine-question').value = h.question;
    const header = document.getElementById('selected-cards-header'); header.innerHTML = `<div style="padding:10px;">${h.cardsText}</div>`;
};
window.saveHisPhoneResult = function() {
    if(!hpCurrentResult) return;
    let list = window.BIG_MEMORY.his_phone_history || [];
    if(list.length>0 && list[0].date === hpCurrentResult.date) return alert("已保存");
    list.unshift(hpCurrentResult);
    if(list.length>20) list.pop();
    saveToBigDB('his_phone_history', list);
    alert("✅ 证据已保存");
};
window.renderHisPhoneHistory = function() {
    const list = window.BIG_MEMORY.his_phone_history || [];
    const container = document.getElementById('hp-history-list'); container.innerHTML = '';
    list.forEach((item, index) => {
        const div = document.createElement('div'); div.className = 'morandi-card'; div.style.padding = '10px';
        div.innerHTML = `<div style="font-weight:bold;">${new Date(item.date).toLocaleString()}</div><div>🃏 ${item.cards}</div>`;
        div.onclick = () => { hpCurrentResult = item; renderHisPhoneOS(item); document.getElementById('hp-history-panel').classList.remove('open'); document.getElementById('hp-intro-view').style.display='none'; };
        container.appendChild(div);
    });
};
window.saveDreamResultToHistory = function() {
    if(!currentDreamResult) return alert("无内容");
    let list = window.BIG_MEMORY.dream_history || [];
    list.unshift(currentDreamResult);
    if(list.length>50) list.pop();
    saveToBigDB('dream_history', list);
    alert("✅ 梦境报告已保存");
};
window.renderDreamHistory = function() {
    const list = window.BIG_MEMORY.dream_history || [];
    const container = document.getElementById('dream-history-list'); container.innerHTML = '';
    list.forEach((item) => {
        const div = document.createElement('div'); div.className = 'morandi-card'; div.style.padding='10px';
        div.innerHTML = `<div>${new Date(item.date).toLocaleString()}</div><div>🎴 ${item.cards}</div>`;
        div.onclick = () => { 
            document.getElementById('dream-result-area').style.display = 'block';
            document.getElementById('dream-analysis-content').innerHTML = item.htmlContent;
            document.getElementById('dream-history-panel').classList.remove('open');
        };
        container.appendChild(div);
    });
};
// === 找到这段代码 (大约在 3280行左右) ===
window.addEventListener('load', function() {
    console.log("正在初始化无限存储系统...");
    idb.init().then(async () => {
        await loadAllBigData();
        loadTVContent();
        if(typeof loadGameWidgetTheme === 'function') loadGameWidgetTheme();
        try { await idb.get('settings_heavy', 'myAvatar'); } catch(e){}
        
        // 🔴🔴🔴 删除或注释掉下面这几行 🔴🔴🔴
        /*
        if(typeof initPetSystem === 'function') {
            initPetSystem(); 
        }
        */
        // 🔴🔴🔴 删除结束 🔴🔴🔴
        
        console.log("✅ 无限容量系统已就绪！");
    });
});
// 全局变量用于存储打包好的文件，供 iOS 二次点击使用
let pendingBackupFile = null;

async function exportFullBackup() {
    const btn = event.target;
    
    // === 阶段二：如果文件已经准备好，直接触发分享/下载 (iOS 核心修复) ===
    if (pendingBackupFile) {
        if (navigator.canShare && navigator.canShare({ files: [pendingBackupFile] })) {
            try {
                await navigator.share({
                    files: [pendingBackupFile],
                    title: 'RetroOS 备份',
                    text: '这是您的全量备份数据'
                });
            } catch (err) {
                // 用户取消分享不报错
                if (err.name !== 'AbortError') alert("分享失败，请重试");
            }
        } else {
            // PC 端兜底
            const url = URL.createObjectURL(pendingBackupFile);
            const a = document.createElement('a');
            a.href = url;
            a.download = pendingBackupFile.name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            setTimeout(() => URL.revokeObjectURL(url), 1000);
        }
        
        // 重置按钮状态
        btn.innerText = "📤 导出备份 (.json)";
        btn.style.backgroundColor = "";
        btn.style.color = "";
        btn.removeAttribute('data-ready');
        pendingBackupFile = null;
        return;
    }

    // === 阶段一：开始打包数据 ===
    if(btn.getAttribute('data-processing')) return;
    btn.setAttribute('data-processing', 'true');
    const originalText = btn.innerText;

    btn.innerText = "⏳ 正在打包大数据 (请稍候)...";
    btn.style.opacity = "0.7";

    try {
        // 1. 确保内存是最新的 (从数据库拉取 Universal Store)
        const allUniversal = await idb.getAll('universal_store');
        const universalObj = {};
        allUniversal.forEach(item => { universalObj[item.id] = item.data; });
        
        // 合并当前内存
        const finalMemory = { ...window.BIG_MEMORY, ...universalObj };

        // 2. 获取图片等独立的大文件
        const albumData = await idb.getAll('album_data');
        const settingsHeavy = await idb.getAll('settings_heavy');
        const chatStickers = await idb.getAll('chat_stickers');
        const anniversaryData = await idb.getAll('anniversary_data');
        const tvData = await idb.getAll('tv');
        const chatHistory = await idb.getAll('chat_history'); 
        const tarotDeck = await idb.getAll('tarot_deck'); // 塔罗牌库
        const lenormandDeck = await idb.getAll('lenormand_deck'); // 雷诺曼牌库

        const backupData = {
            meta: {
                version: "5.0_iOS_Fixed",
                date: new Date().toLocaleString(),
                timestamp: Date.now(),
                app: "RetroOS_Full_Backup"
            },
            big_memory: finalMemory,
            chat_history: chatHistory,
            pickup_data: await idb.getAll('pickup_data'),
            
            // 包含了所有图片资源
            image_stores: {
                album_data: albumData,
                settings_heavy: settingsHeavy,
                chat_stickers: chatStickers,
                anniversary_data: anniversaryData,
                tv: tvData,
                tarot_deck: tarotDeck,
                lenormand_deck: lenormandDeck
            }
        };

        // 3. 生成文件对象
        const jsonStr = JSON.stringify(backupData);
        const blob = new Blob([jsonStr], { type: "application/json" });
        const fileName = `RetroOS_Backup_${new Date().toISOString().slice(0,10)}.json`;
        
        // 存入全局变量
        pendingBackupFile = new File([blob], fileName, { type: "application/json" });

        // 4. 改变按钮状态，引导用户进行“第二次点击”
        // 这是绕过 iOS 安全限制的唯一方法
        btn.removeAttribute('data-processing');
        btn.setAttribute('data-ready', 'true');
        btn.innerText = "✅ 打包完成！点击此处保存";
        btn.style.backgroundColor = "#06c755";
        btn.style.color = "white";
        btn.style.opacity = "1";
        btn.style.fontWeight = "bold";
        
        // 对于 PC，我们可以尝试直接触发一次
        if (!navigator.canShare) {
             const url = URL.createObjectURL(blob);
             const a = document.createElement('a');
             a.href = url;
             a.download = fileName;
             document.body.appendChild(a);
             a.click();
             document.body.removeChild(a);
             // PC端直接复原
             setTimeout(() => {
                 btn.innerText = originalText;
                 btn.style.backgroundColor = "";
                 btn.style.color = "";
                 pendingBackupFile = null;
             }, 2000);
        }

    } catch (e) {
        console.error(e);
        alert("备份失败 (可能数据量过大导致内存不足):\n建议删除一些相册或聊天图片再试。\n错误: " + e.message);
        btn.innerText = originalText;
        btn.removeAttribute('data-processing');
        btn.style.opacity = "1";
        pendingBackupFile = null;
    }
}
async function importFullRestore(input) {
    const file = input.files[0];
    if (!file) return;

    if (!confirm(`⚠️ 警告：这将覆盖当前的【所有】数据！\n包括相册、聊天记录、美化设置等。\n\n文件大小: ${(file.size/1024/1024).toFixed(2)}MB\n确定要恢复吗？`)) {
        input.value = '';
        return;
    }

    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = JSON.parse(e.target.result);
            
            if (!data.meta || !data.meta.app.includes("RetroOS")) {
                throw new Error("这不是有效的 RetroOS 备份文件");
            }

            console.log("开始恢复数据...");
            if (data.big_memory) {
                window.BIG_MEMORY = data.big_memory;
                for (let key in data.big_memory) {
                    await idb.put('universal_store', { id: key, data: data.big_memory[key] });
                }
            }
            const restoreListText = [
                { key: 'chat_history', source: data.chat_history },
                { key: 'pickup_data', source: data.pickup_data }
            ];
            
            for (let item of restoreListText) {
                if (item.source && Array.isArray(item.source)) {
                    await idb.clear(item.key);
                    const tx = idb.db.transaction([item.key], 'readwrite');
                    const store = tx.objectStore(item.key);
                    item.source.forEach(rec => store.put(rec));
                    await new Promise(resolve => tx.oncomplete = resolve);
                }
            }

            if (data.image_stores) {
                const imgMap = data.image_stores;
                const storesToRestore = ['album_data', 'settings_heavy', 'chat_stickers', 'anniversary_data', 'tv'];
                
                for (let storeName of storesToRestore) {
                    if (imgMap[storeName] && Array.isArray(imgMap[storeName])) {
                        await idb.clear(storeName); 
                        const tx = idb.db.transaction([storeName], 'readwrite');
                        const store = tx.objectStore(storeName);
                        
                        imgMap[storeName].forEach(rec => store.put(rec));
                        await new Promise(resolve => tx.oncomplete = resolve);
                        console.log(`✅ 已恢复图片库: ${storeName}`);
                    }
                }
            }
            if (data.local_storage) {
                for (let key in data.local_storage) {
                    if (data.local_storage[key]) {
                        localStorage.setItem(key, data.local_storage[key]);
                    }
                }
            }

            alert(`🎉 恢复成功！\n数据时间: ${data.meta.date}\n页面即将刷新以应用更改。`);
            location.reload();

        } catch (err) {
            console.error(err);
            alert("❌ 恢复失败: 文件格式错误或内存不足。\n" + err.message);
        }
    };
    reader.readAsText(file);
    input.value = ''; 
}
const NotificationManager = {
    requestPermission: async function() {
        if (!("Notification" in window)) return alert("此设备不支持系统通知");
        
        const permission = await Notification.requestPermission();
        if (permission === "granted") {
            this.send({ title: "通知已开启", body: "现在你可以在后台收到消息了！", icon: "🎉" });
        } else {
            alert("需要通知权限才能在后台接收消息。请在系统设置中允许。");
        }
    },
    send: function({ title, body, icon = "🔔", tag = "default", onClick = null }) {
        if (document.visibilityState === 'visible') {
            this.showToast(title, body, icon, onClick);
            return;
        }
        if (Notification.permission === "granted") {
            try {
                const noti = new Notification(title, {
                    body: body,
                    icon: "https://i.postimg.cc/Sstb57LV/065da10de10365d9519422da09e26142.jpg", // 你的App图标
                    tag: tag,
                    renotify: true
                });
                
                noti.onclick = function() {
                    window.focus(); // 尝试唤醒窗口
                    if (onClick) onClick();
                    noti.close();
                };
            } catch (e) {
                console.log("系统通知发送失败，转为Toast", e);
            }
        }
    },

    // 3. 显示 App 内美化弹窗
    showToast: function(title, body, icon, onClick) {
        const container = document.getElementById('sys-toast-container');
        container.classList.add('show');

        const el = document.createElement('div');
        el.className = 'sys-toast-card';
        el.innerHTML = `
            <div class="toast-icon">${icon}</div>
            <div class="toast-body">
                <div class="toast-title">${title}</div>
                <div class="toast-msg">${body}</div>
            </div>
        `;
        
        // 点击逻辑
        el.onclick = () => {
            if (onClick) onClick();
            el.remove();
            if(container.children.length === 0) container.classList.remove('show');
        };

        container.appendChild(el);

        // 5秒后自动消失
        setTimeout(() => {
            el.style.opacity = '0';
            setTimeout(() => { 
                el.remove(); 
                if(container.children.length === 0) container.classList.remove('show');
            }, 300);
        }, 5000);
    }
};
// === 🚑 修复补丁：学习计划删除功能 ===
window.deleteStudyPlan = function() {
    if(confirm("确定要放弃这个计划吗？所有进度将丢失。")) {
        // 1. 清空内存中的数据
        window.BIG_MEMORY.study = null;
        
        // 2. 清空无限数据库中的数据
        if (typeof idb !== 'undefined') {
            idb.put('universal_store', { id: 'study', data: null });
        }
        
        // 3. 清空旧缓存 (防止复活)
        localStorage.removeItem('study_plan_data');
        
        // 4. 刷新界面
        renderStudyApp(); 
    }
};
  </script>
<div id="card-table-modal" class="modal-overlay" style="background: rgba(0,0,0,0.6); backdrop-filter: blur(5px);">
    <div id="card-table-desk">
        <div id="card-area">
        </div>
        <div class="card-table-ui">
            <div style="color:white; text-shadow:0 1px 2px black;">请凭借直觉翻开几张牌... (<span id="flipped-count">0</span>)</div>
            <button class="m-btn primary" onclick="finishReadingAndGenerate()">🔮 感知能量并生成新闻</button>
            <button class="m-btn secondary" onclick="closeCardTable()">取消</button>
        </div>
    </div>
</div>
<div id="newspaper-modal" class="modal-overlay" onclick="closeNewspaper()">
    <div class="paper-full-view" onclick="event.stopPropagation()">
        <div class="paper-full-head">
            <div class="paper-brand">The Daily Prophecy</div> 
            <div class="paper-meta-row">
                <span id="news-location-display">Earth</span>
                <span id="news-date-display">DATE: 2026-01-25</span>
                <span>Price: 1 Soul</span>
            </div>
        </div>
        <div class="paper-split-body">
            <div class="paper-col left-col">
                <div class="col-header">
                    <span class="col-tag">OTHER SIDE</span>
                    <h3>ECHOES FROM THE VOID</h3>
                </div>
                <div id="news-cards-display" class="news-cards-strip"></div>
                <div class="news-article" id="dream-news-content">
                    <div class="skeleton-text">正在根据星象与牌意解析彼岸的能量流动...</div>
                </div>
            </div>

            <div class="vertical-divider"></div>

            <div class="paper-col right-col">
                <div class="col-header">
                    <span class="col-tag">REALITY</span>
                    <h3>LOCAL CHRONICLES</h3>
                </div>
                <div class="news-article" id="real-news-content">
                    <div class="skeleton-text">正在检索你所在维度的今日头条...</div>
                </div>
            </div>
        </div>
        <div style="margin-top:20px; text-align:center; font-size:0.6rem; border-top:1px solid #333; padding-top:5px;">
            Printed by RetroOS Press • All Realities Reserved
        </div>
    </div>
</div>

<div id="tarot-app-modal" class="modal-overlay" style="background: linear-gradient(to bottom, #1a1a2e, #16213e);">
    <div class="modal-header" style="background: rgba(0,0,0,0.3); color: #e2c2b3; border-bottom: 1px solid rgba(255,255,255,0.1);">
        <div style="display:flex; align-items:center; gap:10px;">
            <span>🔮 灵魂占卜</span>
            <select id="divination-mode" onchange="switchTarotMode()" style="background:rgba(255,255,255,0.1); color:#fff; border:none; border-radius:4px; padding:2px;">
             <!-- 替换原有的 options -->
<option value="tarot">塔罗牌 (78张)</option>
<option value="lenormand">雷诺曼 (36张)</option>
<option value="liuyao">六爻 (金钱卦)</option>
<option value="meihua">梅花易数 (时间/数字)</option>
            </select>
        </div>
        <div style="display:flex; gap:15px;">
            <button class="m-btn small" onclick="toggleTarotHistory()" style="background:transparent; color:#e2c2b3;">📜 历史</button>
            <button class="close-btn" onclick="closeTarotApp()" style="color:#fff;">×</button>
        </div>
    </div>
    <div id="tarot-history-panel" class="chat-settings-panel">
        <h3>🔮 灵视记录</h3>
        <button class="m-btn small" onclick="toggleTarotHistory()" style="margin-bottom:10px; background:#e8d7d7;">关闭侧边栏</button>
        <div id="tarot-history-list" style="display:flex; flex-direction:column; gap:10px;"></div>
    </div>

    <div class="modal-body">
        <div id="tarot-desk-area">
            <div style="text-align:center; padding: 10px; color:#a29bfe; font-size:0.9rem; text-shadow:0 0 5px #000; background:rgba(0,0,0,0.2); flex-shrink:0;">
                请集中意念，点击抽牌 (已选: <span id="tarot-picked-count">0</span>)
            </div>
            <div id="tarot-card-spread">
            </div>
            <div class="tarot-bottom-bar">
                <button class="m-btn small" onclick="confirmShuffle()" style="background:rgba(255,255,255,0.15); color:#fff; border:1px solid rgba(255,255,255,0.3);">
                    🌪️ 重洗 / 打乱
                </button>
                <button class="m-btn primary" id="btn-tarot-finish" onclick="finishTarotSelection()" style="background:#a29bfe; color:#1a1a2e; border:none; display:none; box-shadow: 0 0 15px rgba(162, 155, 254, 0.6);">
                    ✨ 完成抽牌
                </button>
            </div>
        </div>
<!-- 新增：易学桌面 (六爻/梅花) -->
<div id="iching-desk-area" style="display:none; flex:1; flex-direction:column; align-items:center; justify-content:center; color:#e2c2b3;">
    
    <!-- 六爻区域 -->
    <div id="liuyao-ui" style="display:none; flex-direction:column; align-items:center; width:100%;">
        <div style="font-size:1.2rem; margin-bottom:20px;">请诚心默念问题，掷出六次</div>
        <div id="hexagram-lines" style="display:flex; flex-direction:column-reverse; gap:10px; margin-bottom:20px; min-height:180px;">
            <!-- 卦爻线将在这里生成 -->
        </div>
        <div class="coin-container" style="display:flex; gap:15px; margin-bottom:20px;">
            <div class="coin">🪙</div><div class="coin">🪙</div><div class="coin">🪙</div>
        </div>
        <button class="m-btn primary" onclick="tossLiuyaoCoins()" style="background:#d4af37; color:#000;">🎲 掷硬币</button>
    </div>

    <!-- 梅花易数区域 -->
    <div id="meihua-ui" style="display:none; flex-direction:column; align-items:center; width:80%;">
        <div class="morandi-card" style="width:100%; text-align:center; padding:20px;">
            <h3>🌸 梅花心易</h3>
            <p style="font-size:0.8rem; color:#666;">输入数字或使用当前时间起卦</p>
            <div class="input-group">
                <input type="number" id="meihua-n1" placeholder="上卦数" style="width:48%; display:inline-block;">
                <input type="number" id="meihua-n2" placeholder="下卦数" style="width:48%; display:inline-block;">
            </div>
            <div style="margin:10px 0; color:#888;">- 或 -</div>
            <button class="m-btn secondary" onclick="useCurrentTimeForMeihua()">⏰ 使用当前时间起卦</button>
        </div>
        <button class="m-btn primary" onclick="finishMeihua()" style="margin-top:20px; width:100%; background:#e67e22;">生成卦象</button>
    </div>

    <!-- 底部重置按钮 -->
    <div style="margin-top:30px;">
        <button class="m-btn small" onclick="resetIching()" style="background:rgba(255,255,255,0.1);">🔄 重置</button>
    </div>
</div>
        <div id="tarot-result-area">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                <h3 style="margin:0; color:#2c3e50;">解读圣坛</h3>
                <button class="m-btn small" onclick="backToDesk()" style="background:#ddd; color:#333;">🔙 返回牌桌</button>
            </div>
            <div id="selected-cards-header" style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-bottom:20px; padding-bottom:15px; border-bottom:1px dashed #ccc;"></div>
            <div id="divination-form">
                <div class="input-group">
                    <label>心中所惑 (Question)</label>
                    <input type="text" id="divine-question" placeholder="例如：他对我的真实想法？/这周运势？">
                </div>
                
                <details style="margin-bottom:10px; font-size:0.8rem; color:#666;">
                    <summary>📝 补充背景信息</summary>
                    <div style="margin-top:10px; padding:10px; background:#eee; border-radius:8px;">
                        <div class="input-group"><label>目标人物</label><input type="text" id="divine-target" placeholder="Ta的名字"></div>
                        <div class="input-group"><label>当前关系</label><input type="text" id="divine-status" placeholder="现状..."></div>
                    </div>
                </details>
<div class="morandi-card" style="padding:10px; margin-bottom:15px; border:1px solid #e0d0d0;">
    <label style="font-size:0.8rem; color:#8b0000; font-weight:bold; display:block; margin-bottom:8px;">🔗 链接世界书 (勾选以注入API)</label>
    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px; font-size:0.85rem;">
        <label style="display:flex; align-items:center;">
            <input type="checkbox" id="wb-ctx-global" checked> 
            <span style="margin-left:4px;">1.全局设定</span>
        </label>
        
        <label style="display:flex; align-items:center;">
            <input type="checkbox" id="wb-ctx-tarot" checked> 
            <span style="margin-left:4px;">3.塔罗牌</span>
        </label>
        <label style="display:flex; align-items:center;">
            <input type="checkbox" id="wb-ctx-lenormand"> 
            <span style="margin-left:4px;">4.雷诺曼</span>
        </label>
<!-- 追加在 checkbox 列表末尾 -->
<label style="display:flex; align-items:center;">
    <input type="checkbox" id="wb-ctx-iching" checked> 
    <span style="margin-left:4px;">六爻/梅花设定</span>
</label>
        <label style="display:flex; align-items:center;">
            <input type="checkbox" id="wb-ctx-char"> 
            <span style="margin-left:4px;">信件</span>
        </label>
    </div>
</div>

                <div class="input-group">
                    <label>解读方式</label>
                    <select id="divine-method" onchange="toggleDivineInput(this.value)">
                        <option value="ai_dream">🔮 AI 梦占 (潜意识连接)</option>
                        <option value="ai_trad">📖 AI 传统牌义解析</option>
                        <option value="manual">✍️ 自行输入解牌</option>
                    </select>
                </div>

                <div id="manual-divine-box" style="display:none;" class="input-group">
                    <label>你的解读</label>
                    <textarea id="manual-interpretation" class="editor-textarea" style="height:150px;"></textarea>
                </div>

                <button class="m-btn primary" onclick="startDivination()" style="width:100%; margin-top:10px; background:#2c3e50;">👁️ 开始洞察</button>
            </div>
            <div id="divination-output" style="display:none; margin-top:20px;">
                <div class="receipt-header" style="border-bottom:2px solid #2c3e50;">
                    <div class="receipt-title">SOUL MESSAGE</div>
                </div>
                <div id="output-content" style="font-family:'Georgia', serif; line-height:1.8; color:#333; white-space: pre-wrap; margin-top:15px;"></div>
                
                <div style="margin-top:30px; display:flex; gap:10px;">
                    <button class="m-btn small" onclick="confirmShuffle()" style="background:#eee;">🔄 重新抽牌</button>
                    <button class="m-btn small" onclick="saveDivinationResult()" style="background:#a29bfe; color:white;">💾 保存记录</button>
                </div>
            </div>
        </div>
    </div>
</div>
<div id="finance-modal" class="modal-overlay">
    <div class="modal-header">
        <span>记账本</span>
        <div style="display:flex; gap:10px;">
            <button class="m-btn small" onclick="toggleHistorySelector()" style="background:transparent; color:#555; font-size:1.2rem;">📅</button>
            <button class="close-btn" onclick="document.getElementById('finance-modal').style.display='none'" style="padding:0;">×</button>
        </div>
    </div>
    <div id="history-selector" class="history-selector">
        <div style="text-align:center; font-weight:bold; margin-bottom:5px;">切换月份</div>
        <input type="month" id="finance-month-picker" onchange="changeFinanceDate(this.value)" style="padding:5px;">
    </div>

    <div class="modal-body" style="background:#fdfdfd;"><!-- 新增：总资产栏 -->
<div style="background:#fff; padding:12px; margin-bottom:15px; border-radius:12px; box-shadow:0 2px 5px rgba(0,0,0,0.05); display:flex; justify-content:space-between; align-items:center;">
    <div>
        <div style="font-size:0.7rem; color:#888;">目前总资产 (含初始)</div>
        <div style="font-size:1.4rem; font-weight:bold; color:#2c3e50;" id="finance-total-display">0.00</div>
    </div>
    <button class="m-btn small" onclick="setInitialFunds()" style="background:#eee; color:#555;">⚙️ 设初始</button>
</div>
<!-- 原代码 finance-nav 在这里... -->
        <div class="finance-nav">
            <button onclick="navFinanceDate(-1)">◀</button>
            <span id="finance-current-date-display">2026-01</span>
            <button onclick="navFinanceDate(1)">▶</button>
        </div>

        <div class="morandi-card" style="background:#7d8c7c; color:white; text-align:center; padding:15px;">
            <div style="font-size:0.8rem; opacity:0.8;">本月结余</div>
            <div style="font-size:2.2rem; font-weight:bold;" id="finance-month-balance">0.00</div>
            <div style="display:flex; justify-content:space-around; margin-top:5px; font-size:0.85rem; opacity:0.9;">
                <div>收: <span id="finance-month-in">0</span></div>
                <div>支: <span id="finance-month-out">0</span></div>
            </div>
        </div>
        <div id="finance-chart-area" class="finance-chart-container">
        </div>
        <div class="morandi-card">
            <input type="number" id="finance-amount" placeholder="输入金额..." class="editor-textarea" style="padding:10px; width:100%; margin-bottom:10px; font-size:1.2rem; text-align:center;">
            
            <div style="font-size:0.75rem; color:#888; margin-bottom:5px;">支出分类：</div>
            <div class="cat-grid">
                <div class="cat-btn expense" onclick="addFinanceRecord('吃饭', 'expense')">吃饭</div>
                <div class="cat-btn expense" onclick="addFinanceRecord('工作', 'expense')">工作</div>
                <div class="cat-btn expense" onclick="addFinanceRecord('其它', 'expense')">其它</div>
                <div class="cat-btn expense" onclick="addFinanceRecord('买谷', 'expense')">买谷</div>
                <div class="cat-btn expense" onclick="addFinanceRecord('约稿', 'expense')">约稿</div>
                <div class="cat-btn expense" onclick="addFinanceRecord('传讯', 'expense')">传讯</div>
                <div class="cat-btn expense" onclick="addFinanceRecord('衣服', 'expense')">衣服</div>
                <div class="cat-btn expense" onclick="addFinanceRecord('约会', 'expense')">约会</div>
            </div>

            <div style="font-size:0.75rem; color:#888; margin:10px 0 5px 0;">收入分类：</div>
            <div class="cat-grid">
                <div class="cat-btn income" onclick="addFinanceRecord('工资', 'income')">工资</div>
                <div class="cat-btn income" onclick="addFinanceRecord('副业', 'income')">副业</div>
                <div class="cat-btn income" onclick="addFinanceRecord('红包', 'income')">红包</div>
                <div class="cat-btn income" onclick="addFinanceRecord('意外', 'income')">意外收入</div>
            </div>
        </div>
        <h4 style="margin: 15px 0 5px 0; color:#888; font-size:0.9rem;">账单明细</h4>
        <div id="finance-list" style="display:flex; flex-direction:column; gap:10px; padding-bottom:50px;">
        </div>
    </div>
</div>
<div id="theater-modal" class="modal-overlay theater-theme-day">
    <div id="theater-container">
        <div class="theater-header">
            <button class="m-btn small" onclick="closeTheaterApp()" style="background:transparent; font-size:1.2rem;">🔙</button>
            <div class="th-title">小剧场 · Light Novel</div>
            <div style="display:flex; gap:10px;">
                <button class="m-btn small" onclick="toggleTheaterTheme()" style="background:rgba(0,0,0,0.1);">🌓</button>
                <button class="m-btn small" onclick="toggleTheaterHistory()" style="background:rgba(0,0,0,0.1);">📜 历史</button>
            </div>
        </div>
        <div id="theater-scroll-area">
            <div id="theater-content-list">
                <div style="text-align:center; margin-top:50vh; transform:translateY(-50%); color:opacity:0.5;">
                    <div style="font-size:3rem; opacity:0.2;">🎭</div>
                    <p style="opacity:0.6;">链接世界书，开启你的故事。</p>
                </div>
            </div>
        </div>
        <div class="theater-footer">
            <div style="display:flex; gap:15px; font-size:0.75rem; opacity:0.8; overflow-x:auto;">
                <label><input type="checkbox" id="th-use-global" checked> 引用世界书(全局)</label>
                <label><input type="checkbox" id="th-use-theater" checked> 引用世界书(小剧场)</label>
            </div>
            
            <div class="th-input-row">
                <textarea id="th-input" class="th-textarea" placeholder="输入剧情走向、对话或动作 (你)..."></textarea>
                <button class="th-btn" onclick="generateTheaterSegment()" id="btn-th-gen">续写 ✨</button>
            </div>
        </div>
    </div>
    <div id="theater-history-panel" class="chat-settings-panel">
        <h3>📚 剧本历史</h3>
        <div style="display:flex; gap:10px; margin-bottom:15px;">
            <button class="m-btn small" onclick="toggleTheaterHistory()" style="background:rgba(128,128,128,0.2);">关闭</button>
            <button class="m-btn small" onclick="startNewTheater()" style="background:var(--th-accent); color:white;">+ 新剧本</button>
        </div>
        <div id="theater-history-list" style="display:flex; flex-direction:column; gap:10px;"></div>
    </div>
</div>
<div id="period-modal" class="modal-overlay period-theme">
    <div class="modal-header" style="background:#f8bbd0; color:#880e4f;">
        <span>Red Moon Cycle</span>
        <button class="close-btn" onclick="document.getElementById('period-modal').style.display='none'" style="color:#880e4f;">×</button>
    </div>
    <div class="modal-body">
        <div class="cycle-dashboard" style="overflow: visible; height: auto; min-height: 150px;">
            <div style="font-size:0.8rem; text-transform:uppercase; letter-spacing:1px; opacity:0.7;">Body Status</div>
                    
            <div class="cycle-status-text" id="p-status-display" style="font-size: 1.8rem; font-weight: bold; margin: 10px 0;">等待记录...</div>
            <div class="cycle-sub-text" id="p-prediction-display">请记录开始时间</div>
                <button id="p-toggle-btn" class="period-toggle-btn" onclick="togglePeriodStatus()" style="margin-top:15px; padding:8px 20px; border-radius:20px; background:white; color:#d81b60; border:1px solid #d81b60;">
                ⚪ 未在经期
            </button>
        </div>
        <div id="p-ai-section" style="display:none;">
            <div class="ai-care-card">
                <div style="font-weight:bold; margin-bottom:5px; color:#d81b60;">💌 爱人传来的信息</div>
                <div id="p-care-msg" style="white-space: pre-wrap; line-height:1.6;">正在接收短信...</div>
            </div>

            <div class="morandi-card" style="padding:15px;">
                <h4 style="margin:0 0 10px 0;">🥣 推荐食谱</h4>
                <div id="p-recipe-title" style="font-weight:bold; color:#444;"></div>
                <div class="recipe-box" id="p-recipe-content">Loading...</div>
            </div>
        </div>
        <div class="morandi-card">
            <h3>📝 记录日志</h3>
            <div class="input-group">
                <label>开始时间</label>
                <input type="date" id="p-start-date">
            </div>
            <div class="input-group">
                <label>结束时间 (可选)</label>
                <input type="date" id="p-end-date">
            </div>
            
            <div style="display:flex; gap:10px; margin-top:10px;">
                <button class="m-btn primary" onclick="addPeriodRecord()" style="background:#d81b60;">保存记录</button>
                <button class="m-btn secondary" onclick="analyzeCycleWithAI()" style="background:#fce4ec; color:#d81b60;">🔮 AI 分析身体 & 推荐</button>
            </div>
        </div>
        <div class="morandi-card">
            <h3>📅 历史周期</h3>
            <div id="p-history-list"></div>
        </div>
    </div>
</div>
<div id="forum-modal" class="modal-overlay">
    <div class="forum-container">
        <div class="modal-header" style="background:#fff; color:#333; border-bottom:1px solid #ddd;">
            <button class="m-btn small" onclick="closeForumApp()" style="background:transparent; color:#333; font-size:1.2rem;">🔙</button>
            <span style="font-weight:bold;">匿名论坛</span>
            <button class="m-btn small" onclick="toggleForumHistory()" style="background:transparent; color:#00d2d3;">📂 历史</button>
        </div>
        <div id="forum-scroll-area" class="forum-scroll-area">
            <div id="forum-content-container">
                <div style="text-align:center; margin-top:100px; color:#999;">
                    <div style="font-size:3rem; opacity:0.3;">💬</div>
                    <p>输入关键词，生成论坛体小说<br>支持超长上下文与续写</p>
                </div>
            </div>
        </div>
        <div class="forum-footer-bar">
            <div class="forum-input-settings">
                <label><input type="checkbox" id="forum-use-global" checked> 引用世界书(全局)</label>
                <label><input type="checkbox" id="forum-use-forum" checked> 引用世界书(论坛体)</label>
                <select id="forum-role-select" style="border:1px solid #ddd; padding:2px;">
                    <option value="npc">路人/NPC发帖</option>
                    <option value="user">主角/我发帖</option>
                </select>
            </div>
            <div style="display:flex; gap:10px;">
                <textarea id="forum-input" class="th-textarea" style="height:50px;" placeholder="输入标题、梗概或关键词..."></textarea>
                <button class="m-btn primary" onclick="generateForumThread()" id="btn-forum-gen" style="background:#00d2d3; width:80px;">发帖 / 续写</button>
            </div>
        </div>
    </div>
    <div id="forum-history-panel" class="chat-settings-panel">
        <h3>📂 帖子历史</h3>
        <div style="display:flex; gap:10px; margin-bottom:15px;">
            <button class="m-btn small" onclick="toggleForumHistory()" style="background:#eee;">关闭</button>
            <button class="m-btn small" onclick="startNewForum()" style="background:#00d2d3; color:white;">+ 新帖子</button>
        </div>
        <div id="forum-history-list" style="display:flex; flex-direction:column; gap:10px;"></div>
    </div>
</div>
<div id="fridge-modal" class="modal-overlay" style="background: #f2f4f6;">
    <div class="fridge-app-container" style="position:relative; width:100%; height:100%; display:flex; flex-direction:column; overflow:hidden;">
        <div class="fridge-header-clean">
            <button class="fh-btn" onclick="closeFridgeApp()">❮ 返回</button>
            <span class="fh-title">智能冰箱 · Smart Fridge</span>
            <div class="fh-icon" onclick="toggleFridgeHistory()" style="cursor:pointer; font-size:1.5rem;">🕒</div>
        </div>
        <div class="fridge-scroll-body" style="flex:1; overflow-y:auto; padding:15px; padding-bottom:100px;">
            
            <div class="section-title">调料区 (点击切换)</div>
            <div class="condiments-grid" id="new-shelf-condiments" style="min-height:80px; display:flex; gap:10px; overflow-x:auto;">
            </div>

            <div class="section-title">主食区</div>
            <div class="staples-row" id="new-shelf-staples" style="min-height:80px; display:flex; justify-content:space-around;">
            </div>

            <div class="section-title">蔬菜区</div>
            <div class="tags-container" id="new-shelf-veg" style="min-height:50px;">
            </div>

            <div class="section-title">肉类冷冻区</div>
            <div class="tags-container" id="new-shelf-meat" style="min-height:50px;">
            </div>
            
        </div>
        <div class="fridge-footer-fixed" style="position:absolute; bottom:30px; left:20px; right:20px; z-index:10;">
            <button class="big-call-btn" onclick="startWeChatCall()">
                <span>📞</span>
                <span>喂？教我做饭</span>
            </button>
        </div>
        <div id="fridge-history-panel">
            <h3 style="color:#5d4037; border-bottom:1px solid #ddd; padding-bottom:10px; margin-top:0;">
                📝 历史便签
                <span onclick="toggleFridgeHistory()" style="float:right; cursor:pointer; color:#999;">×</span>
            </h3>
            <div id="fridge-history-list" style="display:flex; flex-direction:column; gap:15px; padding-top:10px;">
            </div>
        </div>

    </div>
</div>
<div id="wechat-call-overlay">
    <div class="wx-minimize" onclick="endWeChatCall()">⌄</div>
    
    <div class="wx-avatar" id="wx-call-avatar"></div>
    <div class="wx-name" id="wx-call-name">Chef Bot</div>
    <div class="wx-status" id="wx-call-status">等待对方接听...</div>
    <div id="wx-call-subtitle" class="wx-subtitle-box" style="display:none;"></div>

    <div class="wx-footer-btns">
        <div class="wx-btn-col">
            <div class="wx-round-btn wx-btn-normal">🔇</div>
            <span class="wx-btn-label">麦克风已开</span>
        </div>
        <div class="wx-btn-col">
            <div class="wx-round-btn wx-btn-hangup" onclick="endWeChatCall()">📞</div>
            <span class="wx-btn-label">挂断</span>
        </div>
        <div class="wx-btn-col">
            <div class="wx-round-btn wx-btn-normal">🔊</div>
            <span class="wx-btn-label">免提</span>
        </div>
    </div>
</div>
<div id="sticky-note-modal" class="modal-overlay" onclick="document.getElementById('sticky-note-modal').style.display='none'">
    <div class="big-sticky-note" onclick="event.stopPropagation()">
        <div class="note-pin">📌</div>
        <div id="note-detail-date" style="text-align:right; font-size:0.8rem; color:#888; margin-bottom:10px;"></div>
        <h2 id="note-detail-title" style="margin:0 0 15px 0; border-bottom:2px dashed #a1887f; padding-bottom:10px;"></h2>
        <div id="note-detail-content" style="white-space: pre-wrap; line-height: 1.6; font-size: 1.1rem; flex:1;"></div>
        <div style="margin-top:20px; text-align:center; font-size:0.8rem; opacity:0.6;">- 来自你的私家大厨 -</div>
    </div>
</div>
<div id="pickup-modal" class="modal-overlay">
    <div class="pickup-header">
        <button class="m-btn small" onclick="closePickupApp()" style="background:transparent; color:#333; font-size:1.2rem;">🔙</button>
        <div style="text-align:center;">
            <div style="font-weight:bold; font-size:1rem;">捡手机文学</div>
            <div style="font-size:0.7rem; color:#666;" id="pickup-char-name">Target</div>
        </div>
        <button class="m-btn small" onclick="togglePickupHistory()" style="background:transparent; color:#333;">📜 历史</button>
    </div>
    <div id="pickup-chat-area">
        <div style="text-align:center; margin-top:50px; color:#fff; text-shadow:0 1px 2px rgba(0,0,0,0.3);">
            <p>输入情节关键词<br>生成你们的私密聊天记录</p>
        </div>
    </div>
    <div class="pickup-footer">
        <div style="display:flex; justify-content:space-between; font-size:0.8rem; color:#666; margin-bottom:5px;">
            <span>📚 调用：全局 + 捡手机文学</span>
            <span onclick="clearPickupChat()" style="color:red; cursor:pointer;">清空当前</span>
        </div>
        <div class="pickup-input-group">
            <textarea id="pickup-input" class="pup-textarea" placeholder="例如：吵架后他来求和 / 发现他手机里的备忘录..."></textarea>
            <button class="m-btn primary" onclick="generatePickupChat()" id="btn-pickup-gen" style="width:80px; background:#f1c40f; color:#000;">生成<br></button>
        </div>
    </div>
    <div id="pickup-history-panel" class="chat-settings-panel">
        <h3>📱 存档记录</h3>
        <div style="display:flex; gap:10px; margin-bottom:15px;">
            <button class="m-btn small" onclick="togglePickupHistory()" style="background:#eee;">关闭</button>
            <button class="m-btn small" onclick="startNewPickup()" style="background:#f1c40f; color:#000;">+ 新对话</button>
        </div>
        <div id="pickup-history-list" style="display:flex; flex-direction:column; gap:10px;"></div>
    </div>
</div>
<div id="album-app-modal" class="modal-overlay" style="background:#f5f5f5;">
    <div id="album-shelf-view" style="width:100%; height:100%; display:flex; flex-direction:column;">
        <div class="modal-header" style="background:#fff;">
            <span>我的相册</span>
            <div style="display:flex; gap:10px;">
                <button class="m-btn small" onclick="createNewAlbum()">+ 新建相册</button>
                <button class="close-btn" onclick="closeAlbumApp()">×</button>
            </div>
        </div>
        <div id="album-list-container" class="album-shelf-grid" style="overflow-y:auto; flex:1;">
        </div>
    </div>
    <div id="album-detail-view" style="display:none; width:100%; height:100%; flex-direction:column;">
        <div class="modal-header" style="background:#fff;">
            <button class="m-btn small" onclick="backToShelf()">🔙</button>
            <span id="album-title-display" onclick="editAlbumName()" style="border-bottom:1px dashed #999;">相册名</span>
            <div style="display:flex; gap:10px;">
                <input type="file" id="photo-import-input" multiple accept="image/*" style="display:none" onchange="handlePhotoImport(this)">
                <button class="m-btn small" onclick="document.getElementById('photo-import-input').click()">📷 导入</button>
                <button class="m-btn small" style="color:red;" onclick="deleteCurrentAlbum()">🗑️</button>
            </div>
        </div>
        <div id="photo-grid-container" class="album-photo-grid" style="overflow-y:auto; flex:1;">
        </div>

    </div>
</div>
<div id="diary-app-modal" class="modal-overlay" style="background:#333;">
    <div class="modal-header" style="background:rgba(0,0,0,0.5); color:#fff; position:absolute; top:0; width:100%; z-index:20; backdrop-filter:blur(5px);">
        <span>Private Diary</span>
        <div style="display:flex; gap:10px;">
            <button class="m-btn small" onclick="toggleDiaryHistory()" style="background:rgba(255,255,255,0.2); color:#fff;">📜 往事</button>
            <button class="close-btn" onclick="document.getElementById('diary-app-modal').style.display='none'" style="color:white;">×</button>
        </div>
    </div>
    
    <!-- 历史记录侧边栏 -->
    <div id="diary-history-panel" class="chat-settings-panel">
        <h3>📜 尘封的日记</h3>
        <button class="m-btn small" onclick="toggleDiaryHistory()" style="margin-bottom:10px; background:#e8d7d7;">关闭</button>
        <div id="diary-history-list" style="display:flex; flex-direction:column; gap:10px;"></div>
    </div>

    <div class="diary-book-container">
        <!-- 左页 -->
        <div class="diary-page left">
            <div class="diary-status-bar">
                <div class="d-stat">Mood: <span id="d-mood">--</span></div>
                <div class="d-stat">Clean: <span id="d-clean">--</span></div>
                <div class="d-stat">Food: <span id="d-food">--</span></div>
                <div class="d-stat">Money: <span id="d-money">--</span></div>
            </div>
            <div class="diary-date" id="d-date-display">DATE: --/--/--</div>
            
            <div class="diary-photo-frame">
                <img id="diary-central-photo" src="" style="display:none; width:100%; height:100%; object-fit:cover;">
                <div class="photo-pin">📍</div>
            </div>

            <div id="diary-text-content" class="diary-text-body">
                <div class="skeleton-text" style="margin-top:50px;">点击右下角按钮，抽取命运牌生成今日记录...</div>
            </div>
        </div>

        <!-- 右页 -->
        <div class="diary-page right">
          <div id="bag-check-section" style="display:none; height:100%; flex-direction:column;">
    <!-- 新增：今日穿搭区域 Start -->
    <div style="background:rgba(255,255,255,0.5); padding:10px; margin-bottom:15px; border-radius:4px; border:1px dashed #8d6e63;">
        <div style="font-weight:bold; color:#5d4037; font-size:0.9rem; margin-bottom:5px;">👗 OOTD (今日穿搭)</div>
        <div id="diary-ootd-content" style="font-size:0.85rem; color:#4e342e; line-height:1.4;"></div>
    </div>
    <!-- 新增：今日穿搭区域 End -->

    <div style="border-bottom:2px double #8d6e63; padding-bottom:10px; margin-bottom:15px; text-align:center; font-weight:bold; color:#5d4037;">
        👜 BAG CHECK
    </div>
    <div id="bag-items-list" style="flex:1; overflow-y:auto;"></div>
</div>
            
            <div id="bag-cover-section" style="height:100%; display:flex; align-items:center; justify-content:center; flex-direction:column;">
                <button class="m-btn small" onclick="toggleBagCheck()" style="background:#8d6e63; color:white; padding:10px 20px;">
                    🔍 查看他当时携带物品
                </button>
            </div>
        </div>
    </div>

    <div style="position:absolute; bottom:30px; width:100%; display:flex; justify-content:center; gap:15px; z-index:10;">
        <button class="m-btn primary" onclick="startDiaryDrawing()" style="box-shadow:0 5px 15px rgba(0,0,0,0.5);">🎲 抽取今日命运 (生成)</button>
    </div>
</div>
    </div>

<!-- 新增：日记专用牌桌 (完全复制游戏牌桌逻辑) -->
<div id="diary-card-table-modal" class="modal-overlay" style="background: rgba(30, 30, 30, 0.95); backdrop-filter: blur(5px);">
    <div id="diary-card-table-desk" style="width: 100%; height: 100%; position: relative; overflow-y: auto; overflow-x: hidden; padding-bottom: 100px;">
        <div id="diary-card-area" style="width: 100%; height: 100%; position: relative; transform-style: preserve-3d; perspective: 1000px;"></div>
        <div class="card-table-ui">
            <div style="color:#fff; text-shadow:0 1px 5px #000; font-weight:bold;">
                请抽取几张牌来决定他今天经历了什么... (<span id="diary-flipped-count">0</span>)
            </div>
            <button class="m-btn primary" onclick="finishDiaryDrawing()">✍️ 开始书写日记</button>
            <button class="m-btn secondary" onclick="document.getElementById('diary-card-table-modal').style.display='none'">取消</button>
        </div>
    </div>
</div>
</div>
<div id="photo-viewer-modal" class="modal-overlay" onclick="closePhotoViewer()">
    <div id="held-photo" class="held-photo-card" onclick="event.stopPropagation()">
        <img id="held-photo-img" class="held-photo-img">
        <div style="margin-top:15px; display:flex; justify-content:space-between; align-items:center;">
            <span style="font-family:'Courier New'; color:#555;" id="photo-date-str">2026-01-25</span>
            <button class="m-btn small" style="background:#ffcdd2; color:#c62828;" onclick="deleteCurrentPhoto()">撕毁照片</button>
        </div>
    </div>
</div>
<div id="anniversary-modal" class="modal-overlay">
    <div class="modal-header" style="background:#cba8a8; color:white;">
        <span>Days Matter · 纪念日</span>
        <div style="display:flex; gap:10px;">
            <button class="m-btn small" onclick="openAddAnniversaryView()" style="background:white; color:#8d6e63;">+ 新建</button>
            <button class="close-btn" onclick="document.getElementById('anniversary-modal').style.display='none'" style="color:white;">×</button>
        </div>
    </div>
    <div id="anniversary-list-view" class="modal-body" style="padding:15px; gap:15px;">
    </div>
    <div id="anniversary-add-view" class="modal-body" style="display:none; background:#fff;">
        <div class="morandi-card">
            <h3>新建纪念日</h3>
            <div class="input-group">
                <label>事件名称</label>
                <input type="text" id="ann-title" placeholder="例如: 恋爱纪念日 / 也是生日">
            </div>
            <div class="input-group">
                <label>目标日期</label>
                <input type="date" id="ann-date">
            </div>
            
            <div class="input-group">
                <label>自定义背景图</label>
                <input type="file" id="ann-bg-input" accept="image/*">
            </div>

            <div class="input-group">
                <label>重复与提醒</label>
                <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
                    <input type="checkbox" id="ann-repeat" style="width:auto;"> 
                    <span>每年重复 (按公历)</span>
                </div>
                <select id="ann-remind-type">
                    <option value="none">不提醒</option>
                    <option value="same">当天提醒</option>
                    <option value="before">提前1天提醒</option>
                </select>
            </div>

            <div style="display:flex; gap:10px; margin-top:20px;">
                <button class="m-btn secondary" onclick="closeAddAnniversaryView()">取消</button>
                <button class="m-btn primary" onclick="saveAnniversary()" style="background:#cba8a8;">保存</button>
            </div>
        </div>
    </div>
</div>
<div id="dream-app-modal" class="modal-overlay" style="background:#f3e5f5;">
    <div class="modal-header" style="background:#fff; color:#6a1b9a;">
        <span style="font-family: 'Ma Shan Zheng', cursive; font-size: 1.2rem;">梦境解析</span>
        <div style="display:flex; gap:10px;">
            <button class="m-btn small" onclick="toggleDreamHistory()" style="background:transparent; color:#6a1b9a;">📜 历史</button>
            <button class="close-btn" onclick="closeDreamApp()" style="color:#6a1b9a;">×</button>
        </div>
    </div>
    <div id="dream-history-panel" class="chat-settings-panel">
        <h3>🦄 分析记录</h3>
        <button class="m-btn small" onclick="toggleDreamHistory()" style="margin-bottom:10px; background:#e1bee7;">关闭</button>
        <div id="dream-history-list" style="display:flex; flex-direction:column; gap:10px;"></div>
    </div>

    <div class="modal-body" style="padding:20px; display:flex; flex-direction:column; align-items:center;">
        <div class="morandi-card" style="width:100%; text-align:center; padding:30px 20px; margin-bottom:20px; background:rgba(255,255,255,0.8);">
            <div style="font-size:3rem; margin-bottom:15px;">💭</div>
            <h2 style="font-size:1.1rem; color:#4a148c; margin-bottom:10px; line-height:1.4;">
                想知道ta做你的梦男/梦女时<br>会发生什么吗？
            </h2>
            <p style="font-size:0.9rem; color:#7b1fa2; margin-bottom:20px;">
                请在心中默念这个问题，<br>然后点击下方按钮抽牌。
            </p>
            <button class="m-btn primary" onclick="startDreamDrawing()" style="background:linear-gradient(45deg, #ab47bc, #7b1fa2); border:none; padding:12px 30px; font-size:1rem; box-shadow:0 4px 15px rgba(123, 31, 162, 0.3);">
                🎴 开始抽牌解析
            </button>
        </div>
        <div id="dream-result-area" style="width:100%; display:none;">
            <div class="morandi-card" style="width:100%; padding:0; overflow:hidden;">
                <div style="background:#6a1b9a; color:white; padding:10px; text-align:center; font-weight:bold;">
                    解析报告
                </div>
                <div id="dream-analysis-content" style="padding:15px; font-size:0.9rem; overflow-x:auto;">
                    <div class="skeleton-text">正在连接梦境潜意识...</div>
                </div>
            </div>
<button id="btn-dream-save" class="m-btn small" onclick="saveDreamResultToHistory()" style="width:100%; margin-top:10px; background:#d1c4e9; color:#4a148c;">💾 保存这份报告</button>
        </div>

    </div>
</div>
<div id="dream-card-table-modal" class="modal-overlay" style="background: rgba(40, 10, 60, 0.85); backdrop-filter: blur(5px);">
    <div id="dream-card-table-desk">
        <div id="dream-card-area">
        </div>
        <div class="card-table-ui">
            <div style="color:#e0c3fc; text-shadow:0 1px 5px #4a148c; font-size:1.1rem; font-weight:bold;">
                默念“如果他是我的梦角...”并抽牌 (<span id="dream-flipped-count">0</span>)
            </div>
            <button class="m-btn primary" onclick="finishDreamDrawing()" style="background:linear-gradient(45deg, #ab47bc, #7b1fa2); border:none; box-shadow:0 0 15px rgba(123, 31, 162, 0.5);">
                🦄 生成梦境解析
            </button>
            <button class="m-btn secondary" onclick="closeDreamCardTable()" style="background:rgba(255,255,255,0.2); color:white;">
                取消
            </button>
        </div>
    </div>
</div>
<div id="his-phone-modal" class="modal-overlay" style="background: #000;">
    <div id="hp-intro-view" style="width:100%; height:100%; display:flex; flex-direction:column; justify-content:center; align-items:center; color:white; animation: fadeIn 1s;">
        <div style="font-size:4rem; margin-bottom:20px;">📵</div>
        <h2 style="font-weight:normal; letter-spacing:2px; text-align:center;">你今天捡到了ta的手机<br><span style="font-size:1rem; opacity:0.7;">静心查看...</span></h2>
        <button class="m-btn primary" onclick="startHisPhoneDrawing()" style="margin-top:40px; border:1px solid white; background:transparent;">开始破解密码 (抽牌)</button>
        <button class="m-btn small" onclick="toggleHisPhoneHistory()" style="margin-top:20px; color:#999; background:transparent;">查看历史记录</button>
    </div>
    <div id="hp-history-panel" class="chat-settings-panel">
        <h3>📵 拾取记录</h3>
        <button class="m-btn small" onclick="toggleHisPhoneHistory()" style="margin-bottom:10px;">关闭</button>
        <div id="hp-history-list" style="display:flex; flex-direction:column; gap:10px;"></div>
    </div>
    <div id="hp-card-view" style="display:none; width:100%; height:100%; flex-direction:column; background:radial-gradient(circle, #2c3e50, #000);">
        <div id="hp-card-desk" style="flex:1; overflow-y:auto; position:relative;">
            <div id="hp-card-area" style="width:100%; height:100%; position:relative;"></div>
        </div>
        <div class="card-table-ui" style="background:rgba(0,0,0,0.8); width:100%; padding:20px; position:static;">
            <div style="color:white; margin-bottom:10px;">请抽取能够揭示他内心的牌 (<span id="hp-flipped-count">0</span>)</div>
            <button class="m-btn primary" onclick="finishHisPhoneReading()">🔓 解锁手机 (生成内容)</button>
            <button class="m-btn secondary" onclick="closeHisPhoneApp()">放弃</button>
        </div>
    </div>
    <div id="hp-os-view" style="display:none; width:100%; height:100%; background: #111; flex-direction:column; position:relative; overflow:hidden;">
        <div style="height:30px; display:flex; justify-content:space-between; padding:5px 15px; color:white; font-size:0.8rem; background:rgba(0,0,0,0.2);">
            <span>4G</span>
            <span id="hp-clock">12:00</span>
            <span>🔋 88%</span>
        </div>
        <div id="hp-home-screen" style="flex:1; display:grid; grid-template-columns:repeat(4, 1fr); grid-template-rows:repeat(5, 1fr); padding:20px; gap:15px; align-content:start;">
        </div>
        <div style="height:80px; background:rgba(255,255,255,0.1); backdrop-filter:blur(10px); display:flex; justify-content:space-around; align-items:center; padding:10px; border-radius:20px; margin:10px;">
             <div class="hp-app-icon" onclick="openFakeApp('wechat')">💬</div>
             <div class="hp-app-icon" onclick="openFakeApp('browser')">🧭</div>
             <div class="hp-app-icon" onclick="openFakeApp('memo')">📝</div>
        </div>
        <!-- 修改 top 的值为 calc(var(--safe-top) + 20px) -->
<div style="position:absolute; top:calc(var(--safe-top) + 20px); right:10px; z-index:100;">
     <button class="m-btn small" onclick="closeHisPhoneApp()" style="background:rgba(0,0,0,0.5); color:white;">关机</button>
     <button class="m-btn small" id="btn-hp-save" onclick="saveHisPhoneResult()" style="background:rgba(255,255,255,0.2); color:white;">💾 保存证据</button>
</div>
        </div>
        <div id="hp-app-detail-modal" style="position:absolute; top:0; left:0; width:100%; height:100%; background:white; z-index:200; display:none; flex-direction:column; animation: slideUp 0.3s;">
            <div class="hp-app-header" id="hp-app-header" style="height:50px; background:#eee; display:flex; align-items:center; padding:0 10px;">
                <button onclick="closeFakeApp()" style="border:none; background:none; font-size:1.2rem;">❮ 返回</button>
                <span id="hp-app-title" style="margin-left:10px; font-weight:bold;">应用名</span>
            </div>
            <div id="hp-app-content" style="flex:1; overflow-y:auto; padding:15px; background:#f5f5f5;"></div>
        </div>
    </div>
</div>
<div id="study-modal" class="modal-overlay" style="background: #f0f4f8;">
    <div class="modal-header" style="background: #fff; color: #37474f; border-bottom: 1px solid #cfd8dc;">
        <span style="font-weight:bold;">学习计划 · Study With Me</span>
        <button class="close-btn" onclick="closeStudyApp()" style="color:#37474f;">×</button>
    </div>

    <div class="modal-body" style="padding: 15px;">
        <div id="study-create-view" style="display:none; flex-direction:column; gap:15px;">
            <div class="morandi-card" style="text-align:center; padding:30px 20px;">
                <div style="font-size:3rem; margin-bottom:10px;">🎓</div>
                <h3 style="color:#455a64; margin-bottom:10px;">开启新的学习旅程</h3>
                <p style="font-size:0.9rem; color:#78909c;">告诉Ta你的目标，让Ta为你制定专属计划。</p>
            </div>

            <div class="morandi-card">
                <div class="input-group">
                    <label>学习目标 / 内容</label>
                    <input type="text" id="study-goal" placeholder="例如：背考研单词、学习Python基础...">
                </div>
                <div class="input-group">
                    <label>周期 / 时间</label>
                    <input type="text" id="study-period" placeholder="例如：30天，每天1小时">
                </div>
                <div class="input-group">
                    <label>目前情况 / 难点</label>
                    <textarea id="study-status" class="editor-textarea" style="height:80px;" placeholder="例如：零基础，容易分心..."></textarea>
                </div>
                
                <div class="input-group" style="margin-top:10px;">
                     <label style="display:flex; align-items:center;">
                        <input type="checkbox" id="study-use-wb" checked style="width:auto; margin-right:5px;"> 
                        <span>引用世界书人设 (生成角色语气的鼓励)</span>
                    </label>
                </div>

                <button class="m-btn primary" id="btn-study-gen" onclick="generateStudyPlan()" style="width:100%; margin-top:15px; background:#546e7a;">生成计划 ✨</button>
            </div>
        </div>
        <div id="study-list-view" style="display:none; flex-direction:column; height:100%;">
            <div class="morandi-card" style="background: linear-gradient(135deg, #607d8b 0%, #455a64 100%); color:white; margin-bottom:15px;">
                <div style="font-size:1.1rem; font-weight:bold;" id="study-plan-title">我的计划</div>
                <div style="font-size:0.8rem; opacity:0.8; margin-top:5px;" id="study-plan-meta">周期: --</div>
                <div style="margin-top:15px; font-size:0.9rem;">
                    进度: <span id="study-progress-text">0/0</span>
                </div>
                <div style="background:rgba(255,255,255,0.2); height:6px; border-radius:3px; margin-top:5px; overflow:hidden;">
                    <div id="study-progress-bar" style="width:0%; height:100%; background:#80cbc4; transition:width 0.3s;"></div>
                </div>
            </div>
            <div id="study-tasks-container" style="flex:1; overflow-y:auto; padding-bottom:50px;">
            </div>
            <div style="margin-top:10px; text-align:center;">
                <button class="m-btn small" onclick="deleteStudyPlan()" style="background:#ffcdd2; color:#c62828; border:none;">🗑️ 删除当前计划</button>
            </div>
        </div>

    </div>
</div>
<div id="theme-modal" class="modal-overlay">
    <div class="modal-header" style="background:#fff;">
        <span style="font-weight:bold;">系统美化中心</span>
        <button class="close-btn" onclick="document.getElementById('theme-modal').style.display='none'">×</button>
    </div>
    <div class="modal-body" style="background:#f9f9f9;">
        <div style="display:flex; gap:10px; margin-bottom:15px; overflow-x:auto; padding-bottom:5px;">
    <button class="m-btn small" onclick="switchThemeTab('icons')">图标</button>
    <button class="m-btn small" onclick="switchThemeTab('covers')">通用背景</button>
    <button class="m-btn small" onclick="switchThemeTab('appbgs')">软件独立背景</button> <!-- 新增 -->
    <button class="m-btn small" onclick="switchThemeTab('fonts')">字体</button>
    <button class="m-btn small" onclick="switchThemeTab('css')">全局CSS</button> <!-- 新增 -->
    <button class="m-btn small" onclick="switchThemeTab('stamps')">回信印章</button>
</div>
        <div id="theme-tab-icons" class="theme-tab-content">
            <div class="morandi-card">
                <h3>更改应用图标</h3>
                <p style="font-size:0.8rem; color:#888;">点击下方应用名上传新图标 (支持PNG透明)</p>
                <div id="app-icon-list" style="display:grid; grid-template-columns:repeat(3, 1fr); gap:10px; margin-top:10px;">
                </div>
            </div>
        </div>
        <div id="theme-tab-covers" class="theme-tab-content" style="display:none;">
            <div class="morandi-card">
                <h3>组件与背景</h3>
        <div class="input-group">
            <label style="color:#d81b60; font-weight:bold;">🏠 主页壁纸 (Main Wallpaper)</label>
            <input type="file" onchange="uploadThemeImage('main_bg', this)">
        </div>
                <div class="input-group"><label>塔罗牌-牌背</label><input type="file" onchange="uploadThemeImage('tarot_back', this)"></div>
                <div class="input-group"><label>塔罗牌-牌桌背景</label><input type="file" onchange="uploadThemeImage('tarot_table', this)"></div>
                <div class="input-group"><label>冰箱组件封面</label><input type="file" onchange="uploadThemeImage('fridge_cover', this)"></div>
<div class="input-group"><label>游戏机-待机画面</label><input type="file" onchange="uploadThemeImage('game_cover', this)"></div>
<div class="input-group"><label>游戏机-内部背景</label><input type="file" onchange="uploadThemeImage('game_bg', this)"></div>
<!-- 在美化弹窗的 HTML 中找地方插入这个 -->
<div class="input-group"><label>日记组件-桌面外观</label><input type="file" onchange="uploadThemeImage('diary_cover', this)"></div>
<div class="input-group"><label>日记本-内页贴的照片</label><input type="file" onchange="uploadThemeImage('diary_photo', this)"></div>
<div class="input-group"><label>游戏机-角色半身(左)</label><input type="file" onchange="uploadThemeImage('game_char_half', this)"></div>
<div class="input-group"><label>游戏机-用户半身(右)</label><input type="file" onchange="uploadThemeImage('game_user_half', this)"></div>
<div class="input-group"><label>老福特-卡片封面图</label><input type="file" onchange="uploadThemeImage('lofter_cover', this)"></div>
                <div class="input-group"><label>报纸组件封面/背景</label><input type="file" onchange="uploadThemeImage('news_cover', this)"></div>
                <div class="input-group"><label>备忘录组件背景</label><input type="file" onchange="uploadThemeImage('memo_cover', this)"></div>
                <div class="input-group"><label>回信信纸背景 (Reply)</label><input type="file" onchange="uploadThemeImage('letter_paper', this)"></div><!-- 在 <div id="theme-tab-covers"> 内部，原有内容的末尾添加 -->
<hr style="margin:15px 0; border:0; border-top:1px dashed #ccc;">
<h4 style="margin-bottom:10px; color:#555;">🎮 RPG 角色皮肤设置</h4>
<div class="input-group"><label>玩家-待机 (Idle)</label><input type="file" onchange="uploadThemeImage('rpg_user_idle', this)"></div>
<div class="input-group"><label>玩家-正面行走 (Down)</label><input type="file" onchange="uploadThemeImage('rpg_user_front', this)"></div>
<div class="input-group"><label>玩家-背面行走 (Up)</label><input type="file" onchange="uploadThemeImage('rpg_user_back', this)"></div>
<div class="input-group"><label>玩家-向右行走 (Right)</label><input type="file" onchange="uploadThemeImage('rpg_user_right', this)"></div>
<div class="input-group"><label>玩家-向左行走 (Left)</label><input type="file" onchange="uploadThemeImage('rpg_user_left', this)"></div>

<div class="input-group"><label>爱人-待机图</label><input type="file" onchange="uploadThemeImage('rpg_npc_idle', this)"></div>
<!-- 新增 NPC 行走皮肤设置 -->
<div class="input-group"><label>爱人-正面行走 (Down)</label><input type="file" onchange="uploadThemeImage('rpg_npc_front', this)"></div>
<div class="input-group"><label>爱人-背面行走 (Up)</label><input type="file" onchange="uploadThemeImage('rpg_npc_back', this)"></div>
<div class="input-group"><label>爱人-向右行走 (Right)</label><input type="file" onchange="uploadThemeImage('rpg_npc_right', this)"></div>
<div style="font-size:0.7rem; color:#888; margin-bottom:10px;">(注: NPC向左走会自动使用向右图的镜像翻转)</div>
<!-- 如果需要NPC行走图也可以照着上面加 -->
                <button class="m-btn secondary" onclick="resetThemeImages()" style="margin-top:10px;">重置所有背景</button>
            </div>
        </div>
        <div id="theme-tab-fonts" class="theme-tab-content" style="display:none;">
            <div class="morandi-card">
                <h3>软件字体设置</h3>
                <p style="font-size:0.8rem; color:#888;">请输入字体文件的 URI 链接 (如 .ttf, .woff2)</p>
                <div id="font-config-list" style="display:flex; flex-direction:column; gap:10px;">
                </div>
            </div>
        </div>
<!-- 新增：软件独立背景设置页 -->
<div id="theme-tab-appbgs" class="theme-tab-content" style="display:none;">
    <div class="morandi-card">
        <h3>软件独立背景</h3>
        <p style="font-size:0.8rem; color:#888;">为每个APP设置不同的背景图 (覆盖通用背景)</p>
        <!-- 这里会由 JS 自动生成列表 -->
        <div id="app-bg-config-list" style="display:flex; flex-direction:column; gap:10px; margin-top:10px;"></div>
    </div>
</div>

<!-- 新增：全局 CSS 设置页 -->
<div id="theme-tab-css" class="theme-tab-content" style="display:none;">
    <div class="morandi-card">
        <h3>全局自定义 CSS</h3>
        <p style="font-size:0.8rem; color:#888;">高级玩家专用。可修改字体颜色、隐藏元素等。</p>
        <textarea id="global-css-input" class="editor-textarea" style="height:200px; font-family:monospace;" placeholder="/* 在此输入 CSS 代码 */ body { ... }"></textarea>
        <button class="m-btn primary" onclick="saveGlobalCSS()" style="width:100%; margin-top:10px;">💾 保存并生效</button>
    </div>
</div>
        <div id="theme-tab-stamps" class="theme-tab-content" style="display:none;">
            <div class="morandi-card">
                <h3>随信礼物印章</h3>
                <p style="font-size:0.8rem; color:#888;">上传多个图片，回信时随机抽取一个盖在信纸上，点击该印章即可打开礼物。</p>
                <input type="file" multiple accept="image/*" id="stamp-upload-input" style="display:none;" onchange="handleStampUpload(this)">
                <button class="m-btn primary" onclick="document.getElementById('stamp-upload-input').click()">+ 上传印章图片</button>
                
                <div id="stamp-preview-grid" style="display:grid; grid-template-columns:repeat(4, 1fr); gap:10px; margin-top:15px;">
                </div>
            </div>
        </div>

    </div>
</div>
<div id="game-modal" class="modal-overlay">
    <div id="game-container" class="game-interface">
        <div class="game-stats-panel">
            <div id="game-char-avatar" class="game-avatar"></div>
            <div class="game-bars">
                <div class="g-bar-row">
                    <span>心情</span>
                    <div class="g-bar-bg"><div id="bar-mood" class="g-bar-fill" style="width:50%; background:#00cec9;"></div></div>
                    <span id="val-mood" class="g-val">50</span>
                </div>
                <div class="g-bar-row">
                    <span>好感</span>
                    <div class="g-bar-bg"><div id="bar-love" class="g-bar-fill" style="width:50%; background:#e84393;"></div></div>
                    <span id="val-love" class="g-val">50</span>
                </div>
            </div>
        </div>
        <button class="game-history-btn" onclick="toggleGameHistory()">📜 LOG</button>
        <button class="game-history-btn" onclick="closeGameApp()" style="right: 70px;">EXIT</button>
        <img id="game-img-char" class="half-body hb-char" src="" style="display:none">
        <img id="game-img-user" class="half-body hb-user" src="" style="display:none">
        <div class="rpg-dialog-box" onclick="showGameInput()">
            <div id="rpg-name" class="rpg-name">您</div>
            <div id="rpg-content" class="rpg-text">点击此处开始输入对话...</div>
            <div id="rpg-cards-info" class="card-meaning-display"></div>
        </div>
        <div id="game-input-layer" class="game-input-overlay">
            <div style="color:#fff; font-size:0.8rem;">请输入你的行动/对话 (随后抽取命运牌):</div>
            <div class="game-input-row">
                <input type="text" id="game-user-input" class="game-input" placeholder="...">
                <button class="m-btn primary" onclick="triggerGameDraw()" style="width:80px;">🎲 抽牌</button>
            </div>
            <button class="m-btn small" onclick="hideGameInput()" style="background:#333; color:#ccc;">取消</button>
        </div>

    </div>
    <div id="game-history-panel" class="chat-settings-panel">
        <h3>💾 冒险日志</h3>
        <button class="m-btn small" onclick="toggleGameHistory()" style="margin-bottom:10px;">关闭</button>
        <div id="game-history-list" style="display:flex; flex-direction:column; gap:10px;"></div>
    </div>
</div>
<div id="game-card-table-modal" class="modal-overlay" style="background: rgba(20, 20, 30, 0.9); backdrop-filter: blur(5px);">
    <div id="game-card-table-desk" style="width: 100%; height: 100%; position: relative; overflow-y: auto; overflow-x: hidden; box-shadow: inset 0 0 100px rgba(0,0,0,0.8); padding-bottom: 100px;">
        <div id="game-card-area" style="width: 100%; height: 100%; position: relative; transform-style: preserve-3d; perspective: 1000px;">
        </div>
        <div class="card-table-ui">
            <div style="color:#00cec9; text-shadow:0 1px 5px #000; font-size:1.1rem; font-weight:bold;">
                RPG 命运判定中... (已选: <span id="game-flipped-count">0</span>)
            </div>
            <button class="m-btn primary" onclick="finishGameDrawing()" style="background:#0984e3; border:none; box-shadow:0 0 15px rgba(9, 132, 227, 0.5);">
                🎲 确认命运并生成剧情
            </button>
            <button class="m-btn secondary" onclick="closeGameCardTable()" style="background:rgba(255,255,255,0.2); color:white;">
                取消
            </button>
        </div>
    </div>
</div>
<script>
window.BIG_MEMORY = window.BIG_MEMORY || {};
Object.assign(window.BIG_MEMORY, {
    fridge: null,           
    fridge_history: [],     
    api_profiles: [],     
    theme_fonts: {},     
    chat_settings: {}    
});
async function migrateAllRestrictedData() {
    console.log("♻️ 正在执行全系统数据迁移...");
    const migrationMap = [
        ['fridge',          'fridge_data',     'fridge_data',     {condiments:{}, staples:{}, vegetables:[], meat:[]}],
        ['fridge_history',  'fridge_history',  'fridge_history',  []],
        ['api_profiles',    'api_profiles',    'api_profiles',    []],
        ['theme_fonts',     'theme_fonts',     'theme_fonts',     {}],
        ['chat_settings',   'chat_settings',   'chat_settings',   {}],
['diary_data', 'diary_data', 'diary_data', null]
    ];

    for (let [memKey, dbKey, localKey, defVal] of migrationMap) {
        try {
            let res = await idb.get('universal_store', dbKey);
            
            if (res) {
                window.BIG_MEMORY[memKey] = res.data;
            } else {
                let raw = localStorage.getItem(localKey);
                if (raw) {
                    try {
                        let parsed = JSON.parse(raw);
                        window.BIG_MEMORY[memKey] = parsed;
                        await idb.put('universal_store', { id: dbKey, data: parsed });
                        console.log(`✅ [迁移成功] ${localKey} 已移入无限存储`);
            localStorage.removeItem(localKey); 
                    } catch(e) { window.BIG_MEMORY[memKey] = defVal; }
                } else {
                    window.BIG_MEMORY[memKey] = defVal;
                }
            }
        } catch (e) {
            console.error(`加载 ${memKey} 失败`, e);
            window.BIG_MEMORY[memKey] = defVal;
        }
    }
    if(typeof renderFridgeContent === 'function' && document.getElementById('fridge-modal').style.display === 'flex') {
        renderFridgeContent();
    }
    if(typeof renderProfiles === 'function' && document.getElementById('settings-modal').style.display === 'flex') {
        renderProfiles();
    }
    if(typeof applyAllThemeSettings === 'function') applyAllThemeSettings();
    
    console.log("🎉 所有受限数据已解放！系统现已完全运行在无限存储模式。");
}
window.getFridgeData = function() {
    return window.BIG_MEMORY.fridge || {
        condiments: {}, staples: {}, vegetables: [], meat: []
    };
};
window.saveFridgeData = function(data) {
    window.BIG_MEMORY.fridge = data;
    idb.put('universal_store', { id: 'fridge_data', data: data });
};
window.getFridgeHistory = function() { return window.BIG_MEMORY.fridge_history || []; };
window.saveFridgeHistory = function(record) {
    const list = window.getFridgeHistory();
    list.unshift({ date: Date.now(), ...record });
    if(list.length > 50) list.pop();
    window.BIG_MEMORY.fridge_history = list;
    idb.put('universal_store', { id: 'fridge_history', data: list });
};
window.deleteFridgeHistory = function(index) {
    if(!confirm("删除这条记录？")) return;
    const list = window.getFridgeHistory();
    list.splice(index, 1);
    window.BIG_MEMORY.fridge_history = list;
    idb.put('universal_store', { id: 'fridge_history', data: list });
    if(typeof renderFridgeHistory === 'function') renderFridgeHistory();
};
window.getProfiles = function() {
    return window.BIG_MEMORY.api_profiles || [];
};
window.saveProfiles = function(data) {
    window.BIG_MEMORY.api_profiles = data;
    idb.put('universal_store', { id: 'api_profiles', data: data });
};
window.saveAppFont = function(appId, url) {
    const fonts = window.BIG_MEMORY.theme_fonts || {};
    fonts[appId] = url;
    window.BIG_MEMORY.theme_fonts = fonts;
    idb.put('universal_store', { id: 'theme_fonts', data: fonts });
    if(typeof injectCustomFont === 'function') injectCustomFont(appId, url);
};
window.renderThemeFontsList = function() {
    const list = document.getElementById('font-config-list');
    list.innerHTML = '';
    const fonts = window.BIG_MEMORY.theme_fonts || {};
    if(typeof APP_MAP !== 'undefined') {
        APP_MAP.forEach(app => {
            const val = fonts[app.id] || "";
            const div = document.createElement('div');
            div.className = 'font-setting-item';
            div.innerHTML = `
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <label style="margin:0;">${app.name}</label>
                    <button class="m-btn small" onclick="testFont('${app.id}')" style="font-size:0.7rem; padding:2px 8px; background:#eee; color:#666;">测试</button>
                </div>
                <input type="text" value="${val}" 
                    placeholder="粘贴字体链接 (https://...)" 
                    style="width:100%; padding:8px; border:1px solid #ddd; border-radius:6px; margin-top:8px; font-size:0.85rem;"
                    onblur="saveAppFont('${app.id}', this.value)"
                >
            `;
            list.appendChild(div);
        });
    }
};
window.getChatSettings = function() {
    const def = {
        myFrame: '', botFrame: '', myCss: '', botCss: '', 
        delayMin: 1, delayMax: 5, countMin: 1, countMax: 3,
        passiveMin: 1, passiveMax: 60, title: "私密聊天", isOnline: false,
        nudgeList: "发呆\n睡觉\n数钱\n干饭\n摸鱼"
    };
    return { ...def, ...window.BIG_MEMORY.chat_settings };
};

window.saveChatSettings = function(extraData = {}) {
    let s = window.getChatSettings();
    const uiData = {
        myFrame: document.getElementById('set-my-frame')?.value,
        botFrame: document.getElementById('set-bot-frame')?.value,
        myCss: document.getElementById('set-my-css')?.value,
        botCss: document.getElementById('set-bot-css')?.value,
        delayMin: parseInt(document.getElementById('set-delay-min')?.value) || 1,
        delayMax: parseInt(document.getElementById('set-delay-max')?.value) || 5,
        countMin: parseInt(document.getElementById('set-count-min')?.value) || 1,
        countMax: parseInt(document.getElementById('set-count-max')?.value) || 3,
        passiveMin: parseInt(document.getElementById('set-passive-min')?.value) || 1,
        passiveMax: parseInt(document.getElementById('set-passive-max')?.value) || 60,
        title: document.getElementById('chat-title-input')?.value,
        nudgeList: document.getElementById('set-nudge-list')?.value
    };
    const finalData = { ...s, ...uiData, ...extraData };
    window.BIG_MEMORY.chat_settings = finalData;
    idb.put('universal_store', { id: 'chat_settings', data: finalData });
    
    if(typeof applyChatSettings === 'function') applyChatSettings();
};

const bootCheck = setInterval(() => {
    if (typeof idb !== 'undefined' && idb.db) {
        clearInterval(bootCheck);
        migrateAllRestrictedData();
    }
}, 500);
    // ============================================================
    // 🛡️ 全局安全卫士：所有 APP 的强制删除补丁 (修复数据复活Bug)
    // ============================================================

    // 1. 【小剧场】彻底删除
    window.deleteTheaterBook = async function(index) {
        if(!confirm("⚠️ 彻底销毁这本剧本？(含所有章节)")) return;
        const list = await getTheaterHistory();
        if(!list[index]) return;
        
        const id = list[index].id;
        // 步骤A: 删正文内容
        await idb.delete('theater_data', `content_${id}`);
        localStorage.removeItem(`theater_content_${id}`); // 清缓存
        
        // 步骤B: 删目录索引
        list.splice(index, 1);
        await saveTheaterHistory(list);
        
        if (id === currentTheaterId) {
            currentTheaterId = null;
            document.getElementById('theater-content-list').innerHTML = '';
        }
        await renderTheaterHistoryList();
    };

    window.deleteTheaterSegment = async function(index) {
        if (!confirm("删除这段内容？")) return;
        const content = await getTheaterContent(currentTheaterId);
        content.splice(index, 1);
        // 强制同步保存
        await saveTheaterContent(currentTheaterId, content); 
        await renderTheaterContent();
    };

    // 2. 【捡手机】彻底删除
    window.deletePickup = async function(index) {
        if(!confirm("🗑️ 删除这段对话记录？")) return;
        const list = await getPickupHistory();
        if(!list[index]) return;
        
        const id = list[index].id;
        await idb.delete('pickup_data', `chat_${id}`); // 删内容
        
        list.splice(index, 1);
        await savePickupHistory(list); // 删索引
        
        if(id === currentPickupId) startNewPickup();
        else togglePickupHistory(); 
    };

    // 3. 【信件】彻底删除
    window.deleteCurrentLetter = function() {
        if (!currentLetterId) return;
        if (!confirm("🔥 烧毁这封信？(不可恢复)")) return;
        
        let letters = window.BIG_MEMORY.letters || [];
        // 从内存中移除
        const newLetters = letters.filter(l => l.id !== currentLetterId);
        
        // 强制同步到大数据库
        saveToBigDB('letters', newLetters);
        
        backToLetterList();
    };

    // 4. 【塔罗牌】历史记录彻底删除
    window.deleteTarotHistory = function(index) {
        if(!confirm("🔮 遗忘这段占卜记忆？")) return;
        
        const list = window.BIG_MEMORY.tarot_history || [];
        list.splice(index, 1);
        
        saveToBigDB('tarot_history', list); // 存入数据库
        localStorage.removeItem('tarot_history'); // 清除旧缓存
        
        loadTarotHistory();
    };

    // 5. 【梦App】历史记录彻底删除
    window.deleteDreamHistory = function(index) {
        if(!confirm("🦄 删除这个梦境解析？")) return;
        
        const list = window.BIG_MEMORY.dream_history || [];
        list.splice(index, 1);
        
        saveToBigDB('dream_history', list);
        localStorage.removeItem('dream_history'); // 清除旧缓存
        
        renderDreamHistory();
    };

    // 6. 【Ta的手机】证据彻底删除
    window.deleteHisPhoneHistory = function(index) {
        if(!confirm("📵 销毁这条手机证据？")) return;
        
        const list = window.BIG_MEMORY.his_phone_history || [];
        list.splice(index, 1);
        
        saveToBigDB('his_phone_history', list);
        localStorage.removeItem('his_phone_history'); // 清除旧缓存
        
        renderHisPhoneHistory();
    };

    // 7. 【冰箱】便签彻底删除
    window.deleteFridgeHistory = function(index) {
        if(!confirm("🥣 撕掉这张便签？")) return;
        
        const list = window.BIG_MEMORY.fridge_history || [];
        list.splice(index, 1);
        
        saveToBigDB('fridge_history', list);
        localStorage.removeItem('fridge_history'); // 清除旧缓存
        
        renderFridgeHistory();
    };

    // 8. 【记账】账目彻底删除
    window.deleteFinance = function(id) {
        if (!confirm("💰 删除这笔账目？")) return;
        
        let data = window.BIG_MEMORY.finance || [];
        data = data.filter(i => i.id !== id);
        
        saveToBigDB('finance', data);
        localStorage.removeItem('finance_data'); // 清除旧缓存
        
        renderFinanceUI();
    };

    // 9. 【经期】记录彻底删除
    window.deletePeriodRecord = function(index) {
        if(!confirm("📅 删除这条周期记录？")) return;
        
        const data = window.BIG_MEMORY.period;
        if(data && data.records) {
            data.records.sort((a, b) => new Date(b.start) - new Date(a.start));
            data.records.splice(index, 1);
            
            saveToBigDB('period', data);
            localStorage.removeItem('period_data'); // 清除旧缓存
            
            renderPeriodUI();
        }
    };
function toggleBagCheck() {
    const list = document.getElementById('bag-check-section');
    const btnDiv = document.getElementById('bag-cover-section');
    list.style.display = 'flex';
    btnDiv.style.display = 'none';
}
// === 🚑 补丁：修复剩余功能的无限存储与删除 ===

// 1. 修复学习计划删除
window.deleteStudyPlan = function() {
    if(confirm("确定要放弃这个计划吗？所有进度将丢失。")) {
        window.BIG_MEMORY.study = null; // 清空内存
        if (typeof idb !== 'undefined') {
            idb.put('universal_store', { id: 'study', data: null }); // 清空大数据库
        }
        renderStudyApp(); 
    }
};

// 2. 修复经期记录删除
window.deletePeriodRecord = function(index) {
    if(!confirm("📅 删除这条周期记录？")) return;
    const data = window.getPeriodData();
    if(data && data.records) {
        data.records.sort((a, b) => new Date(b.start) - new Date(a.start));
        data.records.splice(index, 1);
        
        // 关键：保存回无限存储
        window.savePeriodData(data); 
        renderPeriodUI();
    }
};

// 3. 修复日记删除 (确保同步)
window.deleteDiaryEntry = function(index) {
    if(!confirm("🔥 确定要销毁这篇日记吗？")) return;
    const list = window.getDiaryHistory(); // 从 BigDB 获取
    list.splice(index, 1);
    
    // 保存回 BigDB
    saveToBigDB('diary_history', list); 
    
    // 刷新界面逻辑
    if (index === currentDiaryIndex) {
        currentDiaryIndex = -1;
        document.getElementById('diary-text-content').innerHTML = '';
        document.getElementById('d-date-display').innerText = '--/--/--';
    } else if (index < currentDiaryIndex) {
        currentDiaryIndex--;
    }
    renderDiaryHistoryList();
};
// === 老福特 (Lofter) APP 逻辑 ===

// 1. 获取/保存数据 (无限存储)
function getLofterData() { return window.BIG_MEMORY.lofter_data || []; }
function saveLofterData(data) { 
    window.BIG_MEMORY.lofter_data = data;
    if(typeof idb !== 'undefined') idb.put('universal_store', { id: 'lofter_data', data: data });
}

// 2. 打开 APP
function openLofterApp() {
    document.getElementById('lofter-modal').style.display = 'flex';
    const list = getLofterData();
    if(list.length === 0) {
        document.getElementById('lofter-feed-list').innerHTML = `
            <div style="text-align:center; padding:50px; color:#999;">
                <div style="font-size:3rem; margin-bottom:10px;">🥦</div>
                <p>粮仓空空如也...<br>点击右上角 [产粮] 召唤太太</p>
            </div>`;
    } else {
        renderLofterFeed();
    }
}
function renderLofterFeed() {
    const list = getLofterData(); // 自动读取无限存储
    const container = document.getElementById('lofter-feed-list');
    container.innerHTML = '';
    
    if(list.length === 0) {
        container.innerHTML = `<div style="column-span:all; text-align:center; padding:50px; color:#999;">首页空空如也<br>快点击右上角产粮吧</div>`;
        return;
    }

    list.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'lofter-card-new';
        
        // 随机高度模拟瀑布流图片的错落感
        const randomHeight = Math.floor(Math.random() * 60) + 100; 
        const coverStyle = `height:${randomHeight}px; background-color: #${Math.floor(Math.random()*16777215).toString(16)}20;`; // 随机浅色背景

        div.innerHTML = `
            <div class="lof-cover-placeholder" style="${coverStyle}"></div>
            <div class="lof-del" onclick="event.stopPropagation(); deleteLofterItem(${index})">×</div>
            
            <div class="lof-body" onclick="readLofterFic(${index})">
                <div class="lof-title">${item.title || '无标题'}</div>
                <div class="lof-preview">${item.preview || '...'}</div>
            </div>
            
            <div class="lof-footer">
                <div class="lof-user-row">
                    <div class="lof-avatar">${(item.author||"User")[0]}</div>
                    <div class="lof-author">${item.author || '太太'}</div>
                </div>
                <div class="lof-hot">❤️ ${item.hot || Math.floor(Math.random()*500)}</div>
            </div>
        `;
        container.appendChild(div);
    });
}
// === 2. 删除单条历史 ===
function deleteLofterItem(index) {
    // 简单的确认防止误触
    if(!confirm("确定删除这篇粮吗？")) return;
    
    const list = getLofterData();
    list.splice(index, 1); // 从数组移除
    saveLofterData(list);  // 保存到无限存储
    renderLofterFeed();    // 刷新界面
}

// === 3. 清空所有历史 ===
function clearLofterHistory() {
    if(!confirm("⚠️ 确定清空所有历史生成的文章？不可恢复。")) return;
    saveLofterData([]);
    renderLofterFeed();
}
async function generateLofterFeed() {
    const inputEl = document.getElementById('lofter-user-req');
    const userReq = inputEl.value.trim();
    const btn = document.querySelector('.lofter-toolbar button');
    const oldText = btn.innerText;
    
    btn.disabled = true; btn.innerText = "产粮中...";

    // 1. 获取世界观配置
    const wb = getWBData();
    const globalCtx = (wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    
    // 2. 获取 API Key
    let apiKey = document.getElementById('api-key').value;
    let apiUrl = document.getElementById('api-url').value || "https://api.openai.com/v1";
    let model = document.getElementById('model-select').value || "gpt-3.5-turbo";
    
    if(!apiKey) { 
        try { const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}'); apiKey = s.key; } catch(e){} 
    }
    if(!apiKey) { btn.disabled = false; btn.innerText = oldText; return alert("请先配置 API Key"); }

    // 3. 构建 Prompt (强制第三人称 + 减少数量防止截断)
    const prompt = `
你是一位资深同人作者。请基于以下设定创作：
【世界观】: ${globalCtx}
【用户要求】: ${userReq || "随机生成甜/虐/车梗"}

【重要规则】
1. **视角**：必须严格使用**第三人称**（他/她/名字），禁止使用“我”或“你”。
2. **风格**：仿Lofter同人文风，或是推文风格。
3. **数量**：一次生成 2 个高质量的大纲。

【输出格式】
严格 JSON 数组，不要Markdown标记：
[
  {
    "title": "文章标题",
    "author": "作者昵称",
    "preview": "50字左右的摘要，必须是第三人称视角，例如：‘他看着她的背影...’",
    "tags": ["Tag1", "Tag2"],
    "hot": "1.5w"
  }
]`;

    try {
        const res = await fetch(`${apiUrl}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({ model: model, messages: [{role:"user", content:prompt}], temperature: 0.7 })
        });
        const json = await res.json();
        
        // 4. 强力容错解析 (解决 JSON Parse Error)
        let raw = json.choices[0].message.content.trim();
        // 去除 markdown
        raw = raw.replace(/```json/gi, "").replace(/```/g, "").trim();
        // 尝试找到数组的头尾
        const start = raw.indexOf('[');
        const end = raw.lastIndexOf(']');
        
        let newList = [];
        if (start !== -1 && end !== -1) {
            try {
                newList = JSON.parse(raw.substring(start, end + 1));
            } catch (e) { console.error("JSON Parse 1 failed", e); }
        }
        
        // 兜底：如果解析失败，手动构造一个报错卡片，不让程序崩溃
        if (newList.length === 0) {
            newList = [{
                title: "生成格式异常",
                author: "System",
                preview: "API 返回了非标准 JSON，请重试。\n原始返回: " + raw.substring(0, 50),
                hot: "0"
            }];
        }

        // 5. 无限存储保存 (添加到头部)
        const currentData = getLofterData();
        const finalData = newList.concat(currentData);
        saveLofterData(finalData); // 使用已有的无限存储函数
        
        renderLofterFeed();
        inputEl.value = ''; 

    } catch(e) { 
        alert("生成失败: " + e.message); 
    } finally { 
        btn.disabled = false; btn.innerText = oldText; 
    }
}
async function readLofterFic(index) {
    const list = getLofterData();
    const item = list[index];
    const modal = document.getElementById('lofter-detail-modal');
    const bodyEl = document.getElementById('lofter-article-body');
    
    modal.style.display = 'flex'; // 确保窗口先打开
    
    // 1. 如果已经生成过，直接显示（省钱）
    if(item.full_generated && item.content) {
        renderFicContent(item, bodyEl);
        return;
    }

    // 2. 显示加载动画
    bodyEl.innerHTML = `<div class="skeleton-text" style="margin-top:50px;">正在根据梗概扩写全文...<br>太太正在激情码字中...</div>`;
    
    const wb = getWBData();
    const globalCtx = (wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    
    // 获取 API 设置
    let apiKey = document.getElementById('api-key').value;
    let apiUrl = document.getElementById('api-url').value || "https://api.openai.com/v1";
    let model = document.getElementById('model-select').value || "gpt-3.5-turbo";
    
    // 尝试从缓存读取 API
    if(!apiKey) {
        try { const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}'); apiKey = s.key; apiUrl = s.url; model = s.model; } catch(e){}
    }
    if(!apiKey) {
        bodyEl.innerHTML = `<div style="text-align:center; padding:20px;">❌ 请先在桌面【设置】里配置 API Key</div>`;
        return;
    }

    const prompt = `
你是一位文笔极好的同人作者（老福特风格）。
【CP原型/世界观】：${globalCtx}
【文章标题】：${item.title}
【标签】：${item.tags ? item.tags.join('/') : '无'}
【梗概预览】：${item.preview}

【任务】：
1. **撰写正文**：请把这个梗概扩写成一篇完整的同人文。
   - **字数要求：不少于 600 字**（细节要足）。
   - 文笔风格：细腻、有张力。
   - 必须基于给定的预览进行扩写，不要偏题。
2. **生成评论**：生成 3-5 条读者的热评。

【输出格式】：
严格 JSON 格式，不要包含 Markdown 代码块：
{
  "content": "长篇正文内容（支持换行）...",
  "comments": [ {"user": "路人A", "text": "评论1"}, ... ]
}
`;

    try {
        const res = await fetch(`${apiUrl}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model, 
                messages: [{role:"system", content:"You are a creative writer. Output JSON only."}, {role:"user", content:prompt}], 
                temperature: 0.8
            })
        });
        const json = await res.json();
        
        // --- 修复点：增强的 JSON 解析 ---
        let raw = json.choices[0].message.content;
        raw = raw.replace(/```json/gi, "").replace(/```/g, "").trim();
        
        // 寻找 JSON 的头尾，防止 AI 在前后说废话导致解析失败
        const start = raw.indexOf('{');
        const end = raw.lastIndexOf('}');
        if (start !== -1 && end !== -1) {
            raw = raw.substring(start, end + 1);
        }

        const result = JSON.parse(raw);
        
        // 更新数据并保存
        item.content = result.content;
        item.comments = result.comments;
        item.full_generated = true;
        
        saveLofterData(list); // 保存到无限存储
        renderFicContent(item, bodyEl);

    } catch(e) {
        console.error(e);
        bodyEl.innerHTML = `<div style="text-align:center; color:red; padding:20px;">
            太太弃坑了 (生成失败)<br>原因: ${e.message}<br>请检查网络或 API Key
        </div>`;
    }
}

function renderFicContent(item, container) {
    const cmtHtml = (item.comments || []).map(c => `
        <div class="lofter-cmt-row">
            <div class="lofter-cmt-avatar"></div>
            <div>
                <div style="color:#666; font-size:0.8rem;">${c.user}</div>
                <div>${c.text}</div>
            </div>
        </div>
    `).join('');

    container.innerHTML = `
        <h2 style="margin-bottom:10px; color:#2c6e49;">${item.title}</h2>
        <div style="font-size:0.8rem; color:#999; margin-bottom:20px;">
            BY ${item.author} &nbsp;&nbsp; ${item.tag1} / ${item.tag2}
        </div>
        <div style="white-space: pre-wrap; font-size:1.05rem; text-align:justify;">${item.content}</div>
        <div style="margin-top:40px; text-align:center; color:#ccc;">---------- END ----------</div>
        <div class="lofter-comment-section">
            <h4 style="margin:0 0 15px 0;">热门评论</h4>
            ${cmtHtml}
        </div>
        <div style="margin-top:20px; padding:10px; background:#f0f0f0; text-align:center; color:#888; border-radius:20px;">
            说点什么吧...
        </div>
    `;
}

function closeLofterDetail() {
    document.getElementById('lofter-detail-modal').style.display = 'none';
}
// 迁移逻辑：确保 lofter_data 被初始化
if(!window.BIG_MEMORY.lofter_data) window.BIG_MEMORY.lofter_data = [];
// === 关于痛苦 APP 核心逻辑 ===

let painDeck = [], painFlipped = [], currentPainMode = 'his';

// 1. 数据管理 (无限存储)
function getPainData() { return window.BIG_MEMORY.pain_data || { his: [], my: [] }; }
function savePainData(data) { 
    window.BIG_MEMORY.pain_data = data;
    if(typeof idb !== 'undefined') idb.put('universal_store', { id: 'pain_data', data: data });
}

// 2. 初始化与打开
function openPainApp() {
    document.getElementById('pain-app-modal').style.display = 'flex';
    renderPainHistory();
    // 恢复我的痛苦草稿
    const draft = localStorage.getItem('pain_my_draft');
    if(draft) {
        const d = JSON.parse(draft);
        document.getElementById('my-pain-source').value = d.source||"";
        document.getElementById('my-pain-feeling').value = d.feeling||"";
        document.getElementById('my-pain-thought').value = d.thought||"";
        document.getElementById('my-pain-plan').value = d.plan||"";
        document.getElementById('my-pain-help').value = d.help||"";
    }
}

function switchPainTab(tab) {
    document.getElementById('pain-tab-his').style.display = tab==='his'?'block':'none';
    document.getElementById('pain-tab-my').style.display = tab==='my'?'block':'none';
    document.getElementById('btn-tab-his').style.background = tab==='his'?'#2f3640':'#dfe4ea';
    document.getElementById('btn-tab-his').style.color = tab==='his'?'#fff':'#333';
    document.getElementById('btn-tab-my').style.background = tab==='my'?'#2f3640':'#dfe4ea';
    document.getElementById('btn-tab-my').style.color = tab==='my'?'#fff':'#333';
}

function saveMyPainDraft() {
    const data = {
        source: document.getElementById('my-pain-source').value,
        feeling: document.getElementById('my-pain-feeling').value,
        thought: document.getElementById('my-pain-thought').value,
        plan: document.getElementById('my-pain-plan').value,
        help: document.getElementById('my-pain-help').value
    };
    localStorage.setItem('pain_my_draft', JSON.stringify(data));
    alert("草稿已保存");
}

// 3. 渲染历史记录 (关于他的痛苦)
function renderPainHistory() {
    const data = getPainData();
    const container = document.getElementById('pain-his-history');
    container.innerHTML = '';
    
    (data.his || []).forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'morandi-card';
        div.style.padding = '15px'; div.style.marginBottom = '10px';
        div.innerHTML = `
            <div style="font-size:0.8rem; color:#888; border-bottom:1px dashed #ccc; padding-bottom:5px; margin-bottom:10px; display:flex; justify-content:space-between;">
                <span>${new Date(item.date).toLocaleString()}</span>
                <span style="color:red; cursor:pointer;" onclick="deletePainHistory('his', ${index})">删除</span>
            </div>
            <div style="font-size:0.85rem; color:#6a1b9a; margin-bottom:10px;">🎴 牌意: ${item.cards}</div>
            <div style="white-space:pre-wrap; line-height:1.6; font-size:0.95rem;">${item.content}</div>
        `;
        container.appendChild(div);
    });
}

function deletePainHistory(type, index) {
    if(!confirm("确定删除这条记录？")) return;
    const data = getPainData();
    data[type].splice(index, 1);
    savePainData(data);
    if(type === 'his') renderPainHistory();
    else document.getElementById('pain-my-reply-area').innerHTML = ''; // My类型的简单处理
}
// === 4. 全功能抽牌逻辑 (修正版：114张全牌库) ===

// 启动抽牌：生成114张牌并铺满桌面
function startPainDraw(mode) {
    currentPainMode = mode;
    // 如果是“关于你的痛苦”，检查是否填了内容
    if(mode === 'my') {
        if(!document.getElementById('my-pain-source').value) return alert("请先填写痛苦的根源...");
    }
    
    // 打开全功能牌桌弹窗
    const modal = document.getElementById('pain-card-table-modal');
    const area = document.getElementById('pain-card-area');
    const desk = document.getElementById('pain-card-table-desk');
    
    // 应用美化背景 (如果有设置塔罗桌布，这里也会生效)
    idb.get('settings_heavy', 'tarot_table').then(res => {
        if(res && res.data) {
            desk.style.backgroundImage = `url(${res.data})`;
            desk.style.backgroundSize = 'cover';
        }
    });

    area.innerHTML = '';
    painDeck = []; 
    painFlipped = [];
    document.getElementById('pain-flipped-count').innerText = '0';

    // 1. 生成完整牌库 (0-77 塔罗, 1-36 雷诺曼)
    for(let i=0; i<=77; i++) painDeck.push({ type:'tarot', id:i, isReversed:Math.random()<0.3 });
    for(let i=1; i<=36; i++) painDeck.push({ type:'lenormand', id:i, isReversed: false });
    
    // 2. 洗牌
    painDeck.sort(()=>Math.random()-0.5);

    // 3. 计算网格布局 (和游戏机/信件一致的算法)
    const deskW = window.innerWidth;
    const cardWidth = 60, cardHeight = 90, gapX = 10, gapY = 15;
    // 计算一行能放几张
    let cols = Math.floor((deskW - 20) / (cardWidth + gapX));
    if(cols < 4) cols = 4; // 最小列数
    
    // 计算居中偏移
    const startX = Math.max(0, (deskW - (cols * cardWidth + (cols - 1) * gapX)) / 2);
    const startY = 60; // 顶部留空

    // 4. 渲染每一张牌
    painDeck.forEach((card, index) => {
        const el = document.createElement('div');
        el.className = 'playing-card'; // 复用全局卡牌样式
        
        const col = index % cols;
        const row = Math.floor(index / cols);
        
        el.style.left = (startX + col * (cardWidth + gapX)) + 'px';
        el.style.top = (startY + row * (cardHeight + gapY)) + 'px';
        // 随机微旋转，增加真实感
        el.style.transform = `rotate(${Math.random()*6-3}deg)`;
        
        const front = document.createElement('div');
        front.className = 'playing-card-front';
        el.appendChild(front);
        
        // 绑定点击事件
        el.onclick = () => flipPainCard(el, card);
        
        area.appendChild(el);
    });
    
    // 设置区域高度，保证能滚动到底部
    const totalRows = Math.ceil(painDeck.length / cols);
    area.style.height = (startY + totalRows * (cardHeight + gapY) + 150) + 'px';

    modal.style.display = 'flex';
}

// 翻牌动作 (支持加载图片)
async function flipPainCard(el, cardData) {
    if(el.classList.contains('flipped')) {
        // 取消选择
        el.classList.remove('flipped');
        painFlipped = painFlipped.filter(c => !(c.type === cardData.type && c.id === cardData.id));
        
        // 延迟清空内容 (视觉优化)
        setTimeout(() => {
            const front = el.querySelector('.playing-card-front');
            front.style.backgroundImage = '';
            front.innerText = '';
            front.style.transform = '';
        }, 300);
    } else {
        // 选中翻牌
        el.classList.add('flipped');
        painFlipped.push(cardData);
        
        const front = el.querySelector('.playing-card-front');
        const dbName = cardData.type === 'tarot' ? 'tarot_deck' : 'lenormand_deck';
        
        try {
            // 从 IndexedDB 获取真实图片
            const item = await idb.get(dbName, cardData.id);
            if(item && item.data) {
                front.style.backgroundImage = `url(${item.data})`;
                front.style.backgroundColor = 'transparent';
                front.innerText = '';
            } else {
                // 如果没图，显示文字兜底
                front.style.backgroundColor = '#ecf0f1';
                front.style.color = '#333';
                front.style.display = 'flex';
                front.style.alignItems = 'center';
                front.style.justifyContent = 'center';
                front.style.fontSize = '0.7rem';
                front.innerText = `${cardData.type === 'tarot' ? 'Tarot' : 'Lenormand'}\n#${cardData.id}`;
            }
            
            // 处理逆位旋转
            if(cardData.type === 'tarot' && cardData.isReversed) {
                front.style.transform = "rotateY(180deg) rotate(180deg)";
            } else {
                front.style.transform = "rotateY(180deg)";
            }
        } catch(e) { console.error(e); }
    }
    document.getElementById('pain-flipped-count').innerText = painFlipped.length;
}
// === 5. 核心 API 生成逻辑 (修正版：加入“意愿判定”逻辑) ===
async function finishPainAnalysis() {
    if(painFlipped.length === 0) return alert("请至少翻一张牌，让命运指引方向。");
    
    // 关闭牌桌
    document.getElementById('pain-card-table-modal').style.display = 'none';
    
    // 准备牌面数据
    const cardsDesc = painFlipped.map(c => {
        const name = (c.type === 'tarot') ? (TAROT_NAMES[c.id] || `Tarot ${c.id}`) : (LENORMAND_NAMES[c.id] || `Lenormand ${c.id}`);
        const status = (c.type === 'tarot' && c.isReversed) ? "(逆位)" : "(正位)";
        return `${name}${status}`;
    }).join(", ");

    const wb = getWBData();
    const globalCtx = (wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    
    // 获取API Key
    let apiKey = document.getElementById('api-key').value;
    let apiUrl = document.getElementById('api-url').value || "https://api.openai.com/v1";
    let model = document.getElementById('model-select').value;
    
    // 尝试读取缓存
    if(!apiKey) {
        try { 
            const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}'); 
            apiKey = s.key; apiUrl = s.url; model = s.model; 
        } catch(e){}
    }
    if(!apiKey) return alert("请先在桌面【设置】中配置 API Key！");

    if (currentPainMode === 'his') {
        // === 分支：关于他的痛苦 (加入意愿判定) ===
        const btn = document.querySelector('#pain-tab-his button');
        const oldText = btn.innerText;
        btn.innerText = "⏳ 正在感知他的内心..."; btn.disabled = true;
        
        // 🔥 修改点：Prompt 加入了“是否愿意透露”的判断逻辑
        const prompt = `
你是一位极其敏锐的角色心理侧写师。
【角色/世界观核心】: 
${globalCtx}

【抽到的命运牌组】: 
${cardsDesc}

【任务要求】
请根据**牌意**（结合正逆位）判断角色此刻的状态：
1. **判定意愿**：角色现在是否愿意让用户（你）看到他的痛苦？
   - **愿意 (revealed)**：牌意偏向依赖、信任、崩溃边缘、或渴望被理解（如圣杯、恋人、星星、审判）。
   - **不愿意 (hidden)**：牌意偏向逞强、封闭、保护欲、或是自尊心极强不想让你担心（如皇帝、力量、宝剑国王、隐士、钱币4）。

2. **生成内容**：
   - **情况A：愿意 (revealed)** -> 详细剖析他的痛苦（核心、感受、阶段、调节、渴望）。
   - **情况B：不愿意 (hidden)** -> **绝对不要**说出痛苦的细节！请生成一段**安慰用户的话**。语气要是“我没事，别担心”，用温柔或坚强来掩饰背后的伤痕。

【输出格式】
严格 JSON 格式：
{
  "status": "revealed" 或 "hidden",
  "comfort_message": "如果是 hidden，在此处写他安慰用户、掩饰痛苦的话（第一人称）；如果是 revealed，留空字符串",
  "analysis": { 
     "pain_point": "痛苦核心...",
     "feeling": "真实感受...",
     "stage": "当前阶段...",
     "coping": "调节手段...",
     "desire": "潜意识渴望..."
  } (如果是 hidden，analysis 对象里的字段全部填 null 或 "未知")
}
`;
        try {
            const res = await fetch(`${apiUrl}/chat/completions`, {
                method: 'POST', headers: {'Content-Type':'application/json', 'Authorization':`Bearer ${apiKey}`},
                body: JSON.stringify({ model: model || "gpt-3.5-turbo", messages: [{role:"system",content:"JSON only"},{role:"user",content:prompt}] })
            });
            const json = await res.json();
            const content = json.choices[0].message.content.replace(/```json|```/g, "").trim();
            const resObj = JSON.parse(content);
            
            let html = "";
            
            // 🔥 修改点：根据意愿渲染不同的界面
            if (resObj.status === 'hidden') {
                // 不愿意透露：显示安慰的话 + 牌意提示
                html = `
                    <div style="padding:15px; background:#f1f2f6; border-radius:8px; color:#2f3640;">
                        <h4 style="margin:0 0 10px 0; color:#2f3640;">🚫 他转过了身...</h4>
                        <div style="font-size:1rem; font-family:'Songti SC', serif; line-height:1.6;">
                            “${resObj.comfort_message}”
                        </div>
                        <div style="margin-top:15px; font-size:0.8rem; color:#7f8fa6; border-top:1px dashed #ccc; padding-top:5px;">
                            (牌意显示他此刻不想让你分担这份沉重，选择了独自消化)
                        </div>
                    </div>
                `;
            } else {
                // 愿意透露：显示原来的详细分析
                html = `
                    <div style="margin-bottom:8px;"><strong>🩸 痛苦核心:</strong> ${resObj.analysis.pain_point}</div>
                    <div style="margin-bottom:8px;"><strong>🌧️ 真实感受:</strong> ${resObj.analysis.feeling}</div>
                    <div style="margin-bottom:8px;"><strong>📉 当前阶段:</strong> ${resObj.analysis.stage}</div>
                    <div style="margin-bottom:8px;"><strong>🛡️ 调节手段:</strong> ${resObj.analysis.coping}</div>
                    <div style="color:#d63031; font-weight:bold;">🤲 对你的渴望: ${resObj.analysis.desire}</div>
                `;
            }
            
            // 无限存储保存
            const data = getPainData();
            if(!data.his) data.his = [];
            data.his.unshift({ date: Date.now(), cards: cardsDesc, content: html });
            savePainData(data);
            renderPainHistory();
            
        } catch(e) { 
            console.error(e); 
            alert("生成失败: " + e.message); 
        } finally { 
            btn.innerText = "🔮 抽取牌组并解析"; btn.disabled = false; 
        }

    } else {
        // === 分支：关于你的痛苦 (保持原样，无需改动) ===
        const btn = document.querySelector('#pain-tab-my .primary');
        const oldText = btn.innerText;
        btn.innerText = "⏳ 正在等待他的回应..."; btn.disabled = true;
        
        const userInput = {
            pain: document.getElementById('my-pain-source').value,
            feeling: document.getElementById('my-pain-feeling').value,
            thought: document.getElementById('my-pain-thought').value,
            plan: document.getElementById('my-pain-plan').value,
            help: document.getElementById('my-pain-help').value
        };
        
        const prompt = `
用户向角色发送了一份“关于痛苦的自白表”。
【角色设定】: 
${globalCtx}

【用户填写的自白】: 
${JSON.stringify(userInput)}

【命运牌组（判定依据）】: 
${cardsDesc}

【任务流程】
1. **判定是否已读**：
   - 牌意积极/沟通/敏锐（如宝剑国王、权杖8、审判） -> **已读 (read)**。
   - 牌意混乱/阻碍/封闭（如宝剑8、月亮、高塔逆位、圣杯4） -> **未读 (unread)**。

2. **生成回应**：
   - **如果未读**：生成一段简短的理由。
   - **如果已读**：请**逐条**回复用户的信息。语气必须完全符合角色人设。

【输出格式】
严格 JSON：
{
  "status": "read" 或 "unread",
  "unread_reason": "如果是未读，写原因；否则留空",
  "replies": {
     "pain_reply": "...",
     "feeling_reply": "...",
     "thought_reply": "...",
     "plan_reply": "...",
     "help_reply": "..."
  }
}
`;
        try {
            const res = await fetch(`${apiUrl}/chat/completions`, {
                method: 'POST', headers: {'Content-Type':'application/json', 'Authorization':`Bearer ${apiKey}`},
                body: JSON.stringify({ model: model || "gpt-3.5-turbo", messages: [{role:"system",content:"JSON only"},{role:"user",content:prompt}] })
            });
            const json = await res.json();
            const content = json.choices[0].message.content.replace(/```json|```/g, "").trim();
            const resObj = JSON.parse(content);
            
            const area = document.getElementById('pain-my-reply-area');
            if(resObj.status === 'unread') {
                area.innerHTML = `
                    <div class="morandi-card" style="background:#f1f2f6; text-align:center; padding:20px; color:#666;">
                        <h4 style="color:#636e72;">🚫 对方似乎没有回应</h4>
                        <p style="font-size:0.8rem; color:#a4b0be; margin-bottom:10px;">🔮 阻碍牌: ${cardsDesc}</p>
                        <p style="font-weight:bold;">${resObj.unread_reason}</p>
                    </div>`;
            } else {
                area.innerHTML = `
                    <div class="morandi-card" style="border-left:4px solid #2f3640; padding:20px;">
                        <h4 style="margin-bottom:15px; color:#2f3640;">📩 他的回复 (牌意: 已读)</h4>
                        <div style="font-size:0.95rem; line-height:1.8; color:#2d3436;">
                            <p><span style="background:#dfe6e9; padding:2px 6px; border-radius:4px; font-size:0.8rem;">关于痛点</span><br>${resObj.replies.pain_reply}</p>
                            <hr style="border:0; border-top:1px dashed #dcdde1; margin:10px 0;">
                            <p><span style="background:#dfe6e9; padding:2px 6px; border-radius:4px; font-size:0.8rem;">关于感受</span><br>${resObj.replies.feeling_reply}</p>
                            <hr style="border:0; border-top:1px dashed #dcdde1; margin:10px 0;">
                            <p><span style="background:#dfe6e9; padding:2px 6px; border-radius:4px; font-size:0.8rem;">关于想法</span><br>${resObj.replies.thought_reply}</p>
                            <hr style="border:0; border-top:1px dashed #dcdde1; margin:10px 0;">
                            <p><span style="background:#dfe6e9; padding:2px 6px; border-radius:4px; font-size:0.8rem;">关于方案</span><br>${resObj.replies.plan_reply}</p>
                            <hr style="border:0; border-top:1px dashed #dcdde1; margin:10px 0;">
                            <p><span style="background:#dfe6e9; padding:2px 6px; border-radius:4px; font-size:0.8rem;">关于求助</span><br>${resObj.replies.help_reply}</p>
                        </div>
                        <button class="m-btn small" style="margin-top:15px; width:100%; background:#dfe4ea; color:#2f3640;" onclick="startPainDraw('my')">🔄 重新生成回复</button>
                    </div>`;
            }
        } catch(e) { 
            console.error(e); 
            alert("生成失败: " + e.message); 
        } finally { 
            btn.innerText = oldText; btn.disabled = false; 
        }
    }
}
// === 🍬 平行世界扭蛋机 核心逻辑 ===

let gashaponDeck = [];
let gashaponFlipped = [];
let currentScenario = "";
let pendingStoryResult = null; // 暂存刚生成还没打开的故事

// 1. 初始化 & 数据管理 (无限存储)
// 确保 BIG_MEMORY 初始化
if (!window.BIG_MEMORY.gashapon_history) window.BIG_MEMORY.gashapon_history = [];

function getGashaponHistory() { return window.BIG_MEMORY.gashapon_history || []; }
function saveGashaponHistory(data) {
    const list = getGashaponHistory();
    list.unshift(data);
    saveToBigDB('gashapon_history', list);
}

// 2. 打开 APP
function openGashaponApp() {
    document.getElementById('gashapon-app-modal').style.display = 'flex';
    renderGashaponHistory();
}

function toggleGashaponHistory() {
    const list = document.getElementById('gashapon-history-list');
    list.classList.toggle('show');
}

// 3. 历史记录渲染 & 删除
function renderGashaponHistory() {
    const list = getGashaponHistory();
    const container = document.getElementById('gashapon-history-list');
    container.innerHTML = '';
    
    if(list.length === 0) {
        container.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">暂无收藏的故事</div>';
        return;
    }

    list.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'morandi-card';
        div.style.marginBottom = '10px'; div.style.padding = '15px';
        div.innerHTML = `
            <div style="font-size:0.8rem; color:#888; display:flex; justify-content:space-between;">
                <span>${new Date(item.date).toLocaleDateString()}</span>
                <span onclick="deleteGashaponItem(${index})" style="color:red; cursor:pointer;">删除</span>
            </div>
            <div style="font-weight:bold; color:#c2185b; margin:5px 0;">🌍 设定: ${item.scenario || '随机世界'}</div>
            <div style="font-size:0.85rem; color:#555; max-height:60px; overflow:hidden;">${item.story.substring(0, 50)}...</div>
            <button class="m-btn small" onclick="reviewGashaponStory(${index})" style="width:100%; margin-top:5px; background:#f8bbd0; color:#880e4f;">再次阅读</button>
        `;
        container.appendChild(div);
    });
}

function deleteGashaponItem(index) {
    if(!confirm("确定要丢弃这个平行世界的记忆吗？")) return;
    const list = getGashaponHistory();
    list.splice(index, 1);
    saveToBigDB('gashapon_history', list);
    renderGashaponHistory();
}

function reviewGashaponStory(index) {
    const list = getGashaponHistory();
    const item = list[index];
    showStoryPaper(item.story, item.date);
}

// 4. 流程开始：点击机器 -> 弹出输入框
function triggerGashaponStart() {
    const machine = document.querySelector('.gashapon-machine');
    machine.classList.add('shaking');
    
    setTimeout(() => {
        machine.classList.remove('shaking');
        // 显示输入弹窗
        document.getElementById('gashapon-input-modal').style.display = 'flex';
        document.getElementById('gashapon-scenario').value = ''; // 清空
    }, 600);
}

// 5. 进入牌桌 (复制游戏机逻辑)
function enterGashaponTable() {
    currentScenario = document.getElementById('gashapon-scenario').value.trim();
    document.getElementById('gashapon-input-modal').style.display = 'none';
    
    // 初始化牌桌
    const modal = document.getElementById('gashapon-card-table-modal');
    const area = document.getElementById('gashapon-card-area');
    area.innerHTML = '';
    gashaponDeck = [];
    gashaponFlipped = [];
    document.getElementById('gashapon-flipped-count').innerText = '0';

    // 生成114张牌
    for(let i=0; i<=77; i++) gashaponDeck.push({ type:'tarot', id:i, isReversed:Math.random()<0.3 });
    for(let i=1; i<=36; i++) gashaponDeck.push({ type:'lenormand', id:i, isReversed:false });
    gashaponDeck.sort(()=>Math.random()-0.5);

    // 布局计算
    const deskW = window.innerWidth;
    const cardWidth=60, cardHeight=90, gap=10;
    let cols = Math.floor((deskW-20)/(cardWidth+gap)); if(cols<4) cols=4;
    const startX = (deskW - (cols*(cardWidth+gap)))/2;

    gashaponDeck.forEach((card, i) => {
        const el = document.createElement('div');
        el.className = 'playing-card';
        const col = i % cols, row = Math.floor(i / cols);
        el.style.left = (startX + col*(cardWidth+gap)) + 'px';
        el.style.top = (60 + row*(cardHeight+gap)) + 'px';
        el.style.transform = `rotate(${Math.random()*6-3}deg)`;
        
        const front = document.createElement('div');
        front.className = 'playing-card-front';
        el.appendChild(front);
        
        el.onclick = async () => {
            if(el.classList.contains('flipped')) {
                el.classList.remove('flipped');
                gashaponFlipped = gashaponFlipped.filter(c => !(c.type===card.type && c.id===card.id));
            } else {
                el.classList.add('flipped');
                gashaponFlipped.push(card);
                // 加载图片
                const dbName = card.type==='tarot'?'tarot_deck':'lenormand_deck';
                const item = await idb.get(dbName, card.id);
                if(item && item.data) front.style.backgroundImage = `url(${item.data})`;
                else { front.style.backgroundColor='#ddd'; front.innerText=card.id; }
                if(card.isReversed) front.style.transform = "rotateY(180deg) rotate(180deg)";
                else front.style.transform = "rotateY(180deg)";
            }
            document.getElementById('gashapon-flipped-count').innerText = gashaponFlipped.length;
        };
        area.appendChild(el);
    });
    
    // 应用皮肤 (复用塔罗桌布)
    idb.get('settings_heavy', 'tarot_table').then(res => {
        if(res && res.data) document.getElementById('gashapon-card-table-desk').style.backgroundImage = `url(${res.data})`;
    });

    modal.style.display = 'flex';
}

// 6. 生成故事 API (柔软细腻文风)
async function finishGashaponDrawing() {
    if(gashaponFlipped.length === 0) return alert("请至少翻一张牌，为那个世界注入命运能量。");
    
    // UI 状态
    const btn = document.querySelector('#gashapon-card-table-modal .primary');
    const oldText = btn.innerText;
    btn.innerText = "正在穿越时空..."; btn.disabled = true;

    // 准备 Prompt
    const wb = getWBData();
    const globalCtx = (wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    const cardsDesc = gashaponFlipped.map(c => (c.type==='tarot'?TAROT_NAMES[c.id]:LENORMAND_NAMES[c.id]) + (c.isReversed?"(逆)":"")).join(", ");
    
    let apiKey = document.getElementById('api-key').value;
    let apiUrl = document.getElementById('api-url').value || "https://api.openai.com/v1";
    let model = document.getElementById('model-select').value || "gpt-3.5-turbo";
    
    // 缓存读取
    if(!apiKey) {
        try { const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}'); apiKey=s.key; apiUrl=s.url; model=s.model; } catch(e){}
    }
    if(!apiKey) { btn.innerText = oldText; btn.disabled = false; return alert("请先配置 API Key"); }

    const prompt = `
你是一位擅长写“柔软、细腻、唯美”风格小说的作家。
请为用户生成一个平行世界的小故事。

【基础设定】
- 角色/世界观：${globalCtx}
- 用户设定的平行世界梗概：${currentScenario || "随机一个温馨或宿命感的平行时空"}
- 命运卡牌（剧情指引）：${cardsDesc}

【写作要求】
1. **文风**：极度柔软、细腻、感性。多描写光影、气味、触感和微小的心理活动。
2. **内容**：
   - 必须包含具体的**世界背景**（简单的氛围描写）必须根据牌意生成。
   - 明确双方的**新身份**（基于用户设定（不基于世界书内容只基于用户输入）或牌意）。
   - 描写一件**具体发生的互动事件**。
3. **字数**：不少于 300 字。
4. **禁止**：不要像写大纲，要写成正文片段。不要直接出现“抽到了XX牌”这种出戏的话，把牌意融入剧情。
5.在最下面写上牌和牌意。以及世界背景简介，双方新身份简介。

请直接输出故事正文，不需要标题，不需要 Markdown 代码块。
`;

    try {
        const res = await fetch(`${apiUrl}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model,
                messages: [{role:"system", content:"You are a gentle creative writer."}, {role:"user", content:prompt}],
                temperature: 0.85
            })
        });
        const json = await res.json();
        const story = json.choices[0].message.content.trim();
        
        // 暂存结果
        pendingStoryResult = {
            date: Date.now(),
            scenario: currentScenario || "Unknown World",
            cards: cardsDesc,
            story: story
        };
        
        // 保存到历史
        saveGashaponHistory(pendingStoryResult);
        renderGashaponHistory();

        // 关闭牌桌，显示巨大扭蛋
        document.getElementById('gashapon-card-table-modal').style.display = 'none';
        showBigCapsule();

    } catch(e) {
        alert("时空隧道连接失败: " + e.message);
    } finally {
        btn.innerText = oldText; btn.disabled = false;
    }
}

// 7. 显示大扭蛋 -> 点击打开 -> 显示纸条
function showBigCapsule() {
    const modal = document.getElementById('gashapon-capsule-modal');
    const capsule = document.getElementById('big-capsule');
    const paper = document.getElementById('gashapon-story-paper');
    
    // 重置状态
    modal.style.display = 'flex';
    capsule.classList.remove('open');
    capsule.style.display = 'block';
    paper.style.display = 'none';
}

function openBigCapsule() {
    const capsule = document.getElementById('big-capsule');
    capsule.classList.add('open'); // 触发炸开动画
    
    // 延迟显示纸条
    setTimeout(() => {
        capsule.style.display = 'none'; // 彻底隐藏胶囊
        showStoryPaper(pendingStoryResult.story, pendingStoryResult.date);
    }, 400);
}

function showStoryPaper(text, date) {
    const modal = document.getElementById('gashapon-capsule-modal');
    modal.style.display = 'flex'; // 确保显示（如果是从历史记录进来的）
    document.getElementById('big-capsule').style.display = 'none'; // 确保胶囊不挡路
    
    const paper = document.getElementById('gashapon-story-paper');
    paper.style.display = 'flex';
    
    document.getElementById('sp-date').innerText = new Date(date).toLocaleDateString().toUpperCase();
    document.getElementById('gashapon-story-content').innerHTML = text.replace(/\n/g, '<br>');
}

function closeGashaponResult() {
    document.getElementById('gashapon-capsule-modal').style.display = 'none';
    // 回到主APP界面
    document.getElementById('gashapon-app-modal').style.display = 'flex';
}
// 将 gashapon_history 添加到大容量存储迁移列表
if (typeof loadAllBigData === 'function') {
    const originalLoad = loadAllBigData;
    loadAllBigData = async function() {
        if (!window.BIG_MEMORY.gashapon_history) window.BIG_MEMORY.gashapon_history = [];
        // 尝试从DB加载扭蛋历史
        try {
            let res = await idb.get('universal_store', 'gashapon_history');
            if(res) window.BIG_MEMORY.gashapon_history = res.data;
        } catch(e) {}
        
        await originalLoad();
    }
}
// ==================== 🐾 宠物陪伴系统核心逻辑 ====================

// --- 1. 数据配置 ---
const PET_CONFIG = {
    pets: [
        { id: 'cat_black', name: '黑猫', type: 'cat', img: 'https://i.postimg.cc/2S0qpxv9/IMG_0429.png' },
        { id: 'cat_white', name: '白猫', type: 'cat', img: 'https://i.postimg.cc/HLjrT79Y/IMG_0428.png' },
        { id: 'dog', name: '狗', type: 'dog', img: 'https://i.postimg.cc/RZg3rTf8/IMG_0427.png' },
        { id: 'fish', name: '鱼', type: 'fish', img: 'https://i.postimg.cc/g0rxG6Hm/IMG_0426.png' },
        { id: 'bird', name: '鸟', type: 'bird', img: 'https://i.postimg.cc/Gp94bsJ7/IMG_0425.png' }
    ],
    bg: [
        { id: 'bg_default', src: 'https://i.postimg.cc/Z5w9kL3B/IMG_0435.png', price: 0 },
        { id: 'bg_yellow', src: 'https://i.postimg.cc/rwfd69Wx/IMG_0434.png', price: 20 },
        { id: 'bg_redblack', src: 'https://i.postimg.cc/FHTftxcn/IMG_0433.png', price: 20 },
        { id: 'bg_pink', src: 'https://i.postimg.cc/3x8ybqy2/IMG_0432.png', price: 20 },
        { id: 'bg_blue', src: 'https://i.postimg.cc/ht2JF0x0/IMG_0431.png', price: 20 }
    ],
    decor: [
        { id: 'ac', src: 'https://i.postimg.cc/J7yds1Q5/IMG_0450.png', price: 20, name: '空调', style: 'top:0%; right:0%; width:100px;' },
        { id: 'clock_deco', src: 'https://i.postimg.cc/fW3gVwv3/IMG_0451.png', price: 0, name: '复古挂钟', style: 'top:0%; right:15%; transform:translateX(-50%); width:70px;' },
        { id: 'tub_deco', src: 'https://i.postimg.cc/14hFt0rW/IMG_0461.png', price: 20, name: '豪华浴缸', style: 'bottom:0%; right:80%; width:100px;' },
        { id: 'tub', src: 'https://i.postimg.cc/Rq5tF1LR/IMG_0462.png', price: 20, name: '浴缸', style: 'bottom:0%; right:80%; width:100px;' },
        { id: 'tv', src: 'https://i.postimg.cc/Y2xF1PzF/IMG_0463.png', price: 20, name: '电视', style: 'bottom:0%; right:10%; width:200px;' },
        { id: 'plant1', src: 'https://i.postimg.cc/DmkGZQc7/IMG_0452.png', price: 20, name: '盆栽1', style: 'bottom:0%; right:0%; width:70px;' },
        { id: 'plant2', src: 'https://i.postimg.cc/dQ7Shq9k/IMG_0453.png', price: 20, name: '盆栽2', style: 'top:20%; left:0%; width:100px;' },
        { id: 'lamp_night', src: 'https://i.postimg.cc/c6y3H7B5/IMG_0460.png', price: 20, name: '落地灯(夜)', style: 'top:10%; right:18%; width:100px;' },
        { id: 'lamp', src: 'https://i.postimg.cc/xqDmCG3g/IMG_0459.png', price: 20, name: '落地灯', style: 'top:10%; right:18%; width:100px;' },
{ id: 'win_night', src: 'https://i.postimg.cc/0rRSQGCx/IMG_0455.png', price: 20, name: '窗户(夜)', style: 'top:0%; left:0%; width:150px; ' },
{ id: 'win_day', src: 'https://i.postimg.cc/fW3gVwv9/IMG_0454.png', price: 20, name: '窗户(日)', style: 'top:0%; left:0%; width:150px; ' }, 
{ id: 'curtain', src: 'https://i.postimg.cc/gkqXsp2S/IMG_0438.png', price: 20, name: '窗帘', style: 'top:0; left:0%; width:100%; ' },
        { id: 'desk', src: 'https://i.postimg.cc/G3jDkfxy/IMG_0465.png', price: 20, name: '书桌', style: 'bottom:30%; left:0%; width:110px;' },
        { id: 'flower', src: 'https://i.postimg.cc/5ypFbHty/IMG_0464.png', price: 20, name: '花', style: 'top:20%; left:0%; width:80px;' }
    ],
    items: [
        { id: 'food_unk', name: '不知名食物', price: 1, type: 'food', target: 'custom', img: 'https://i.postimg.cc/d0DhJTjF/IMG_0421.png' },
        { id: 'food_cat', name: '猫粮', price: 1, type: 'food', target: 'cat', img: 'https://i.postimg.cc/vmD4G6L3/IMG_0412.png' },
        { id: 'food_dog', name: '狗粮', price: 1, type: 'food', target: 'dog', img: 'https://i.postimg.cc/VkKSyFMV/IMG_0413.png' },
        { id: 'food_fish', name: '鱼食', price: 1, type: 'food', target: 'fish', img: 'https://i.postimg.cc/R0qWvnLN/IMG_0414.png' },
        { id: 'food_seed', name: '瓜子', price: 1, type: 'food', target: 'bird', img: 'https://i.postimg.cc/R0qWvnLq/IMG_0415.png' },
        
        { id: 'bath_cat', name: '猫沐浴露', price: 1, type: 'bath', target: 'cat', img: 'https://i.postimg.cc/43MmyNW3/IMG_0416.png' },
        { id: 'bath_dog', name: '狗沐浴露', price: 1, type: 'bath', target: 'dog', img: 'https://i.postimg.cc/SKjnmzfR/IMG_0417.png' },
        { id: 'bath_fish', name: '鱼沐浴露', price: 1, type: 'bath', target: 'fish', img: 'https://i.postimg.cc/d0DhJTjV/IMG_0418.png' },
        { id: 'bath_bird', name: '鸟沐浴露', price: 1, type: 'bath', target: 'bird', img: 'https://i.postimg.cc/mrhPTFNn/IMG_0419.png' },
        { id: 'bath_unk', name: '不知名沐浴露', price: 1, type: 'bath', target: 'custom', img: 'https://i.postimg.cc/s21M3Z4R/IMG_0420.png' }
    ]
};

// --- 2. 初始化与存储 ---
if(!window.BIG_MEMORY.pet_data) {
    window.BIG_MEMORY.pet_data = {
        config: { name: "", type: "", img: "" },
        stats: { hunger: 80, clean: 80, mood: 100, last_update: Date.now(), last_pat: 0 },
        inventory: { coins: 0, items: {}, unlocked_bg: ['bg_default'], unlocked_decor: [] },
        state: { bg: 'bg_default', active_decor: [] }, // active_decor: ['ac', 'tv']
        history: [],
        tasks: { last_checkin: 0, chat_count: 0 }
    };
}

function getPetData() { return window.BIG_MEMORY.pet_data; }
function savePetData(data) { 
    window.BIG_MEMORY.pet_data = data;
    if(typeof idb !== 'undefined') idb.put('universal_store', { id: 'pet_data', data: data });
}

// 启动逻辑
function initPetSystem() {
    const data = getPetData();
    if (!data.config.type) {
        openAdoptionModal(); // 第一次进入
    } else {
        renderPetMain();
        startPetLoop();
    }
}
// ==================== 🤖 智能托管系统 (自动循环版) ====================

// 1. 开关切换函数
function toggleAutoCare() {
    const data = window.BIG_MEMORY.pet_data;
    if (!data || !data.config.type) return alert("请先领养宠物！");

    // 切换状态 (如果没有这个字段，默认为 false，取反即为开启)
    data.config.autoCareEnabled = !data.config.autoCareEnabled;
    
    // 保存并刷新界面
    window.savePetData(data);
    updateSettingsUI(); // 刷新按钮颜色
    
    // 提示用户
    if (data.config.autoCareEnabled) {
        alert("🤖 托管已开启！\n助手将每 10 秒检测一次状态，自动喂食/洗澡。");
        runAutoCareCheck(); // 立即执行一次
    } else {
        alert("🤖 托管已关闭。");
    }
}

// 2. 自动检测执行函数 (后台运行)
function runAutoCareCheck() {
    const data = window.BIG_MEMORY.pet_data;
    
    // 如果没开启，或者没宠物，直接退出
    if (!data || !data.config || !data.config.autoCareEnabled) return;

    let hasAction = false; // 标记是否有操作
    let logMsg = []; // 记录操作日志

    // --- 检测饱食度 < 89 ---
    if (data.stats.hunger < 89) {
        // 查找背包里适用的食物
        const targetType = data.config.type === 'custom' ? 'custom' : data.config.type;
        const validFoodId = PET_CONFIG.items.find(i => i.type === 'food' && i.target === targetType)?.id;
        
        if (validFoodId && data.inventory.items[validFoodId] > 0) {
            data.inventory.items[validFoodId]--; // 扣除物品
            data.stats.hunger = Math.min(100, data.stats.hunger + 20); // 增加数值
            data.stats.mood = Math.min(100, data.stats.mood + 2);
            hasAction = true;
            logMsg.push("自动喂食");
        }
    }

    // --- 检测清洁度 < 89 ---
    if (data.stats.clean < 89) {
        // 查找背包里适用的沐浴露
        const targetType = data.config.type === 'custom' ? 'custom' : data.config.type;
        const validBathId = PET_CONFIG.items.find(i => i.type === 'bath' && i.target === targetType)?.id;
        
        if (validBathId && data.inventory.items[validBathId] > 0) {
            data.inventory.items[validBathId]--; // 扣除物品
            data.stats.clean = Math.min(100, data.stats.clean + 20); // 增加数值
            data.stats.mood = Math.min(100, data.stats.mood + 2);
            hasAction = true;
            logMsg.push("自动洗澡");
        }
    }

    // --- 如果有操作，保存并通知 ---
    if (hasAction) {
        window.savePetData(data); // 保存数据
        
        // 如果界面开着，实时刷新数值
        if (document.getElementById('pet-settings-modal').style.display === 'flex') {
            updateSettingsUI();
        }
        if (document.getElementById('page4').style.display !== 'none') {
            renderPetMain(); // 刷新主界面状态
        }

        // 发送轻提示 (Toast)，不打扰用户
        const msg = `🤖 托管助手: ${logMsg.join(' & ')} (状态已恢复)`;
        if(typeof NotificationManager !== 'undefined') {
            NotificationManager.showToast("智能托管执行", msg, "🤖");
        } else {
            console.log(msg); // 兜底日志
        }
    }
}

// 3. 启动循环检测 (每 10 秒检查一次)
setInterval(runAutoCareCheck, 10000);
// --- 3. 领养逻辑 ---
function openAdoptionModal() {
    const modal = document.getElementById('pet-adopt-modal');
    modal.style.display = 'flex';
    const grid = document.getElementById('adopt-grid');
    grid.innerHTML = '';
    
    PET_CONFIG.pets.forEach(p => {
        const div = document.createElement('div');
        div.className = 'pet-item-card';
        div.innerHTML = `<img src="${p.img}" class="pet-item-img"><div style="font-size:0.8rem">${p.name}</div>`;
        div.onclick = () => selectPet(p);
        grid.appendChild(div);
    });
}

let selectedAdoptPet = null;
function selectPet(pet) {
    selectedAdoptPet = pet;
    document.querySelectorAll('#adopt-grid .pet-item-card').forEach(e=>e.style.border="1px solid #ddd");
    event.currentTarget.style.border = "2px solid #ff6b6b";
}
// === 4. 修复领养逻辑 ===
function confirmAdoption() {
    const name = document.getElementById('adopt-name').value;
    const customFile = document.getElementById('adopt-upload').files[0];
    
    // 🔴 增加明确的错误提示
    if(!name) {
        alert("⚠️ 请给你的小伙伴起个名字！");
        return;
    }
    
    // 如果没选预设，也没上传图片
    if(!selectedAdoptPet && !customFile) {
        alert("⚠️ 请选择一只宠物，或者上传一张照片！");
        return;
    }
    
    const data = getPetData();
    // 重置数据结构
    data.config.name = name;
    data.stats = { hunger: 80, clean: 80, mood: 100, last_update: Date.now(), last_pat: 0 };
    data.inventory = { coins: 100, items: {}, unlocked_bg: ['bg_default'], unlocked_decor: [] };
    data.state = { bg: 'bg_default', active_decor: [] };
    data.history = []; // 清空旧故事
    
    if(customFile) {
        const reader = new FileReader();
        reader.onload = (e) => {
            data.config.type = 'custom';
            data.config.img = e.target.result;
            savePetData(data); // 保存
            finalizeAdoption();
        };
        reader.readAsDataURL(customFile);
    } else {
        data.config.type = selectedAdoptPet.type;
        data.config.img = selectedAdoptPet.img;
        savePetData(data); // 保存
        finalizeAdoption();
    }
}
function finalizeAdoption() {
    document.getElementById('pet-adopt-modal').style.display = 'none';
    
    // 自动填入世界书
    const data = getPetData();
    const wb = getWBData();
    
    // 👇👇👇 修改这一行 👇👇👇
    const targetCategory = '18.宠物'; // 改成特定的分类
    
    if(!wb[targetCategory]) wb[targetCategory] = [];
    
    // 检查是否已经存在（防止重复添加）
    const exists = wb[targetCategory].find(i => i.title === "当前宠物设定");
    if (!exists) {
        wb[targetCategory].push({
            title: "当前宠物设定",
            content: `【宠物档案】\n名字：${data.config.name}\n种类：${data.config.type}\n设定：这是用户领养的${data.config.type === 'custom' ? '神秘生物' : data.config.name}。它性格可爱，会一直陪伴在用户身边。请在生成故事时，描写它与用户温馨互动的细节。`,
            enabled: true
        });
        saveWBData(wb);
        alert("🎉 领养成功！宠物档案已自动存入世界书【18.宠物】分类中。");
    } else {
        // 如果想更新，可以在这里写更新逻辑，或者保持不变
        saveWBData(wb);
    }
    
    renderPetMain();
    startPetLoop();
}
// === 修复：主界面渲染 (增加空数据保护) ===
function renderPetMain() {
    // 1. 获取数据，如果没有，使用默认结构，防止报错
    let data = window.BIG_MEMORY.pet_data;
    if (!data) {
        data = {
            config: { type: "" },
            state: { bg: 'bg_default', active_decor: [] },
            stats: { mood: 100 }
        };
    }
    
    // 2. 设置背景 (关键修复：确保背景始终有值)
    // 即使 data.state.bg 是空的，也强制用 PET_CONFIG.bg[0]
    const bgId = data.state && data.state.bg ? data.state.bg : 'bg_default';
    const bgObj = PET_CONFIG.bg.find(b => b.id === bgId) || PET_CONFIG.bg[0];
    
    const bgLayer = document.getElementById('pet-bg-layer');
    if (bgLayer && bgObj) {
        bgLayer.style.backgroundImage = `url(${bgObj.src})`;
    }
    
    // 3. 渲染装饰
    const decorLayer = document.getElementById('pet-decor-layer');
    if (decorLayer) {
        decorLayer.innerHTML = '';
        if (data.state && data.state.active_decor) {
            data.state.active_decor.forEach(did => {
                const conf = PET_CONFIG.decor.find(d => d.id === did);
                if(conf) {
                    const img = document.createElement('img');
                    img.src = conf.src;
                    img.className = 'pet-decor-obj';
                    img.style.cssText = `position:absolute; pointer-events:auto; ${conf.style}`;
                    img.onclick = (e) => {
                        e.stopPropagation();
                        triggerDecorStory(conf.name);
                    };
                    decorLayer.appendChild(img);
                }
            });
        }
    }
    
    // 4. 渲染宠物
    const sprite = document.getElementById('pet-sprite');
    const runawayMsg = document.getElementById('pet-runaway-msg');
    
    if (sprite && runawayMsg) {
        // 如果没有领养，或者心情<=0，隐藏宠物
        if (!data.config || !data.config.type) {
            sprite.style.display = 'none';
            runawayMsg.style.display = 'none'; // 没领养时不显示离家出走
        } else if (data.stats.mood <= 0) {
            sprite.style.display = 'none';
            runawayMsg.style.display = 'block';
        } else {
            sprite.style.display = 'block';
            sprite.style.backgroundImage = `url(${data.config.img})`;
            runawayMsg.style.display = 'none';
        }
    }
}

// 宠物移动逻辑
function startPetLoop() {
    // 移动循环
    setInterval(() => {
        const sprite = document.getElementById('pet-sprite');
        if(sprite.style.display === 'none') return;
        
        // 随机移动 (限制在 10% - 80% 宽度，底部 20% - 40%)
        const newLeft = 10 + Math.random() * 70;
        const currentLeft = parseFloat(sprite.style.left) || 50;
        
        // 根据移动方向翻转图片
        if (newLeft < currentLeft) {
            sprite.style.transform = "scaleX(1)"; // 向左
        } else {
            sprite.style.transform = "scaleX(-1)"; // 向右
        }
        
        sprite.style.left = newLeft + '%';
        // 偶尔跳一下
        if(Math.random() < 0.3) sprite.classList.add('pet-anim');
        else sprite.classList.remove('pet-anim');
        
    }, 5000); // 每5秒动一次

    // 状态衰减循环 (每分钟检查一次，按小时扣除)
    setInterval(updatePetStatsDecay, 60000);
}

function updatePetStatsDecay() {
    const data = getPetData();
    const now = Date.now();
    const hoursPassed = (now - data.stats.last_update) / (1000 * 60 * 60);
    
    if (hoursPassed >= 1) {
        const loss = Math.floor(hoursPassed); // 每小时掉1点
        data.stats.hunger = Math.max(0, data.stats.hunger - loss);
        data.stats.clean = Math.max(0, data.stats.clean - loss);
        
        // 心情计算
        if (data.stats.hunger >= 70 && data.stats.clean >= 70) {
            data.stats.mood = 100;
        } else if (data.stats.hunger === 0 && data.stats.clean === 0) {
            // 每天掉7点 -> 每小时掉 7/24
            data.stats.mood = Math.max(0, data.stats.mood - (loss * 7 / 24));
        }
        
        data.stats.last_update = now;
        savePetData(data);
        renderPetMain(); // 刷新状态（如离家出走）
        updateSettingsUI(); // 如果开着设置页，刷新数值
    }
}

function interactWithPet() {
    openPetSettings();
}
function patPetHead() {
    const data = window.BIG_MEMORY.pet_data;
    const today = new Date().toDateString();
    const lastPat = data.stats.last_pat ? new Date(data.stats.last_pat).toDateString() : "";

    if (today === lastPat) {
        return alert("👋 今天已经摸过头啦，不可以太贪心哦！\n(明天再来吧)");
    }

    // 执行摸头
    data.stats.mood = Math.min(100, data.stats.mood + 8); // 恢复 8%
    data.stats.last_pat = Date.now(); // 记录时间
    
    window.savePetData(data); // 保存
    if(typeof updateSettingsUI === 'function') updateSettingsUI(); // 刷新
    
    alert("👋 你轻轻摸了摸它的头...\n心情 +8% ❤️");
    
    // 50% 概率触发一个小故事
    if (Math.random() < 0.5) {
        generatePetStory("摸头", "手");
    }
}


function retrievePet() {
    const data = getPetData();
    if (data.inventory.coins < 15) return alert("积分不足 15，无法找回...");
    
    data.inventory.coins -= 15;
    data.stats.mood = 20; // 找回后恢复一点心情
    data.stats.hunger = 20;
    data.stats.clean = 20;
    savePetData(data);
    renderPetMain();
    alert("🎉 终于把它找回来了！快给它点吃的吧。");
}

// --- 5. 商店与背包 ---
let currentShopTab = 'food';

function openPetShop() {
    document.getElementById('pet-shop-modal').style.display = 'flex';
    renderShop();
}

function switchShopTab(tab) {
    currentShopTab = tab;
    document.querySelectorAll('.r-tab').forEach(e=>e.classList.remove('active'));
    event.target.classList.add('active');
    renderShop();
}

function renderShop() {
    const data = getPetData();
    document.getElementById('shop-coins').innerText = parseFloat(data.inventory.coins).toFixed(2);
    const grid = document.getElementById('shop-grid');
    grid.innerHTML = '';
    
    let list = [];
    if(currentShopTab === 'food') list = PET_CONFIG.items.filter(i=>i.type==='food');
    else if(currentShopTab === 'bath') list = PET_CONFIG.items.filter(i=>i.type==='bath');
    else if(currentShopTab === 'bg') list = PET_CONFIG.bg.filter(i=>i.price > 0); // 不显示默认
    else if(currentShopTab === 'decor') list = PET_CONFIG.decor;
    
    list.forEach(item => {
        const div = document.createElement('div');
        div.className = 'pet-item-card';
        // 检查是否已购买 (背景/装饰是一次性的)
        const isBought = (currentShopTab==='bg' && data.inventory.unlocked_bg.includes(item.id)) ||
                         (currentShopTab==='decor' && data.inventory.unlocked_decor.includes(item.id));
        
        let btnHtml = `<button class="m-btn small" style="width:100%;margin-top:5px;" onclick="buyPetItem('${item.id}', '${currentShopTab}')">${item.price}💰</button>`;
        if(isBought) btnHtml = `<button class="m-btn small" style="width:100%;margin-top:5px;background:#ccc;">已拥有</button>`;
        
        div.innerHTML = `
            <img src="${item.src || item.img}" class="pet-item-img">
            <div style="font-size:0.8rem; height:20px; overflow:hidden;">${item.name || item.id}</div>
            ${btnHtml}
        `;
        grid.appendChild(div);
    });
}
function buyPetItem(id, type) {
    const data = getPetData();
    
    // 查找物品
    let item = null;
    if(type==='bg') item = PET_CONFIG.bg.find(i=>i.id===id);
    else if(type==='decor') item = PET_CONFIG.decor.find(i=>i.id===id);
    else item = PET_CONFIG.items.find(i=>i.id===id);
    
    if(!item) return;

    // 背景和装饰品只能买1个
    if (type === 'bg' || type === 'decor') {
        if(data.inventory.coins < item.price) return alert("积分不足！");
        data.inventory.coins -= item.price;
        if(type === 'bg') {
            if(!data.inventory.unlocked_bg.includes(id)) data.inventory.unlocked_bg.push(id);
        } else {
            if(!data.inventory.unlocked_decor.includes(id)) data.inventory.unlocked_decor.push(id);
        }
        savePetData(data);
        renderShop();
        return alert("购买成功！");
    }

    // 🔴 消耗品：批量购买逻辑
    const numStr = prompt(`购买【${item.name}】的数量？\n单价: ${item.price}`, "1");
    if (numStr === null) return; // 取消
    const num = parseInt(numStr);
    if (isNaN(num) || num <= 0) return alert("请输入有效数量");

    const totalCost = item.price * num;
    if (data.inventory.coins < totalCost) {
        return alert(`积分不足！需要 ${totalCost}，余额 ${data.inventory.coins}`);
    }

    // 扣费入库
    data.inventory.coins -= totalCost;
    if(!data.inventory.items[id]) data.inventory.items[id] = 0;
    data.inventory.items[id] += num;
    
    savePetData(data); // 无限存储保存
    renderShop();
    alert(`成功购买 ${num} 个 ${item.name}！`);
}

function openPetBag() {
    document.getElementById('pet-bag-modal').style.display = 'flex';
    const data = getPetData();
    document.getElementById('bag-coins').innerText = parseFloat(data.inventory.coins).toFixed(2);
    const grid = document.getElementById('bag-grid');
    grid.innerHTML = '';
    
    // 渲染消耗品
    for(let [id, count] of Object.entries(data.inventory.items)) {
        if(count <= 0) continue;
        const conf = PET_CONFIG.items.find(i=>i.id===id);
        const div = document.createElement('div');
        div.className = 'pet-item-card';
        div.innerHTML = `
            <img src="${conf.img}" class="pet-item-img">
            <div class="pet-item-count">${count}</div>
            <div style="font-size:0.7rem;">${conf.name}</div>
            <button class="m-btn small" style="width:100%; margin-top:2px;" onclick="useConsumable('${id}')">使用</button>
        `;
        grid.appendChild(div);
    }
    
    // 渲染装饰/背景 (这里做个简单的切换入口)
    const toggleDiv = document.createElement('div');
    toggleDiv.className = 'pet-item-card';
    toggleDiv.innerHTML = `<div style="padding:10px; font-size:2rem;">🎨</div><div>布置</div>`;
    toggleDiv.onclick = openDecorationPanel;
    grid.appendChild(toggleDiv);
}
// === 2. 修复物品使用逻辑 ===
function useConsumable(id) {
    const data = getPetData();
    const item = PET_CONFIG.items.find(i => i.id === id);
    const petType = data.config.type; // 当前宠物的类型 (cat, dog, custom...)

    // 🔴 严格匹配逻辑
    if (petType === 'custom') {
        // 自定义宠物(如上传的图)只能用 target='custom' 的物品
        if (item.target !== 'custom') {
            return alert(`你的未知生物似乎对【${item.name}】不感兴趣... \n(请使用不知名系列物品)`);
        }
    } else {
        // 普通宠物：必须类型完全匹配
        if (item.target !== petType) {
            return alert(`我是${getSpeciesName(petType)}，我不吃这个！\n(请使用${getSpeciesName(petType)}专用物品)`);
        }
    }

    // 扣除物品
    data.inventory.items[id]--;
    
    // 增加数值
    if (item.type === 'food') {
        data.stats.hunger = Math.min(100, data.stats.hunger + 20);
        data.stats.mood = Math.min(100, data.stats.mood + 5);
    }
    if (item.type === 'bath') {
        data.stats.clean = Math.min(100, data.stats.clean + 20);
        data.stats.mood = Math.min(100, data.stats.mood + 5);
    }

    // 立即保存到无限存储
    savePetData(data);
    openPetBag(); // 刷新背包显示
    renderPetMain(); // 刷新主界面(去除离家出走状态)

    // 询问是否生成故事
    if(confirm(`使用了【${item.name}】，状态已恢复！\n\n✨ 是否生成一段温馨小故事？`)) {
        const actionName = item.type === 'food' ? '喂食' : '洗澡';
        generatePetStory(actionName, item.name);
    }
}

// 辅助函数：获取中文种族名
function getSpeciesName(type) {
    const map = { 'cat': '猫猫', 'dog': '狗狗', 'fish': '鱼', 'bird': '小鸟' };
    return map[type] || type;
}
function openDecorationPanel() {
    // 隐藏背包，为了复用弹窗逻辑，我们直接借用 pet-bag-modal 的容器来显示布置内容
    // 或者更简单的：清空背包的内容，渲染布置的内容
    
    const data = getPetData();
    const grid = document.getElementById('bag-grid');
    grid.innerHTML = ''; // 清空背包格子

    // 添加一个“返回背包”的按钮
    const backDiv = document.createElement('div');
    backDiv.className = 'pet-item-card';
    backDiv.style.background = '#eee';
    backDiv.innerHTML = `<div style="padding:5px; font-size:1.5rem;">🔙</div><div>返回物品</div>`;
    backDiv.onclick = openPetBag; // 点击返回背包
    grid.appendChild(backDiv);

    // 1. 渲染背景 (BG)
    data.inventory.unlocked_bg.forEach(bgId => {
        const conf = PET_CONFIG.bg.find(b => b.id === bgId);
        if(!conf) return;
        const isActive = data.state.bg === bgId;
        
        const div = document.createElement('div');
        div.className = 'pet-item-card';
        if(isActive) div.style.border = "2px solid #00cec9"; // 高亮当前背景
        
        div.innerHTML = `<img src="${conf.src}" class="pet-item-img"><div style="font-size:0.7rem">背景</div>`;
        div.onclick = () => equipBg(bgId);
        grid.appendChild(div);
    });

    // 2. 渲染装饰 (Decor) - 这就是之前不显示的地方
    data.inventory.unlocked_decor.forEach(decId => {
        const conf = PET_CONFIG.decor.find(d => d.id === decId);
        if(!conf) return;
        const isActive = data.state.active_decor.includes(decId);

        const div = document.createElement('div');
        div.className = 'pet-item-card';
        // 如果正在摆放中，显示绿色边框
        if(isActive) div.style.border = "2px solid #6c5ce7"; 

        div.innerHTML = `<img src="${conf.src}" class="pet-item-img"><div style="font-size:0.7rem">${conf.name}</div>`;
        div.onclick = () => toggleDecor(decId);
        grid.appendChild(div);
    });
}

function equipBg(id) {
    const data = getPetData();
    data.state.bg = id;
    savePetData(data);
    renderPetMain();
    alert("背景已更换");
}

function toggleDecor(id) {
    const data = getPetData();
    const idx = data.state.active_decor.indexOf(id);
    if(idx > -1) data.state.active_decor.splice(idx, 1);
    else data.state.active_decor.push(id);
    savePetData(data);
    renderPetMain();
    openDecorationPanel(); // 刷新选中状态
}
// === 🤖 宠物托管系统 ===
function autoCarePet() {
    const data = window.BIG_MEMORY.pet_data; // 读取无限存储
    if (!data || !data.config.type) return alert("请先领养宠物！");

    let usedFood = [];
    let usedBath = [];
    let moodBoost = 0;

    // 1. 检查是否需要喂食 (饱食度 < 89)
    if (data.stats.hunger < 89) {
        // 查找背包里对应种类的食物
        const targetType = data.config.type === 'custom' ? 'custom' : data.config.type;
        const validFoodId = PET_CONFIG.items.find(i => i.type === 'food' && i.target === targetType)?.id;
        
        if (validFoodId && data.inventory.items[validFoodId] > 0) {
            // 循环使用直到 >= 89 或 食物耗尽
            while (data.stats.hunger < 89 && data.inventory.items[validFoodId] > 0) {
                data.inventory.items[validFoodId]--;
                data.stats.hunger = Math.min(100, data.stats.hunger + 20);
                moodBoost += 2;
                if (!usedFood.includes(validFoodId)) usedFood.push(validFoodId);
            }
        }
    }

    // 2. 检查是否需要洗澡 (清洁度 < 89)
    if (data.stats.clean < 89) {
        const targetType = data.config.type === 'custom' ? 'custom' : data.config.type;
        const validBathId = PET_CONFIG.items.find(i => i.type === 'bath' && i.target === targetType)?.id;
        
        if (validBathId && data.inventory.items[validBathId] > 0) {
            while (data.stats.clean < 89 && data.inventory.items[validBathId] > 0) {
                data.inventory.items[validBathId]--;
                data.stats.clean = Math.min(100, data.stats.clean + 20);
                moodBoost += 2;
                if (!usedBath.includes(validBathId)) usedBath.push(validBathId);
            }
        }
    }

    // 3. 结算
    if (usedFood.length === 0 && usedBath.length === 0) {
        if (data.stats.hunger >= 89 && data.stats.clean >= 89) {
            alert("🤖 托管助手：\n宠物状态很好 (各项 > 89%)，不需要照顾哦！");
        } else {
            alert("🤖 托管助手：\n背包里没有适合的食物或沐浴露了...\n请去商店补充！");
        }
    } else {
        data.stats.mood = Math.min(100, data.stats.mood + moodBoost);
        window.savePetData(data); // 保存
        if(typeof updateSettingsUI === 'function') updateSettingsUI(); // 刷新UI
        
        let msg = "🤖 托管完成！\n";
        if (usedFood.length > 0) msg += "✅ 已自动喂食\n";
        if (usedBath.length > 0) msg += "✅ 已自动洗澡\n";
        msg += `当前饱食: ${data.stats.hunger}%, 清洁: ${data.stats.clean}%`;
        alert(msg);
    }
}
// --- 6. 设置与积分系统 ---
function openPetSettings() {
    document.getElementById('pet-settings-modal').style.display = 'flex';
    updateSettingsUI();
}
// === 替换原有的 updateSettingsUI 函数 ===
// === 修复后的界面刷新函数 ===
// === 2. 修复宠物托管按钮显示 ===
function updateSettingsUI() {
    // 1. 读取数据
    const data = window.BIG_MEMORY.pet_data; 
    if (!data || !data.config) return; 

    // 2. 更新顶部信息与摸头按钮
    const infoEl = document.getElementById('pet-info-display');
    if(infoEl) {
        const today = new Date().toDateString();
        const lastPat = data.stats.last_pat ? new Date(data.stats.last_pat).toDateString() : "";
        const canPat = (today !== lastPat);
        
        infoEl.innerHTML = `
            <div style="display:flex; align-items:center; justify-content:center; gap:10px;">
                <span>${data.config.name} <span style="font-size:0.8rem; font-weight:normal;">(${data.config.type || '未命名'})</span></span>
                <button onclick="patPetHead()" style="
                    border:none; border-radius:20px; padding:2px 8px; font-size:0.7rem; cursor:pointer;
                    background: ${canPat ? '#ff7675' : '#ccc'}; 
                    color: ${canPat ? 'white' : '#666'};">
                    ${canPat ? '👋 摸头' : '已摸过'}
                </button>
            </div>
        `;
    }

    // 3. 更新状态条
    const hunger = Math.floor(data.stats.hunger || 0);
    const clean = Math.floor(data.stats.clean || 0);
    const mood = Math.floor(data.stats.mood || 0);

    const elHunger = document.getElementById('stat-hunger'); if(elHunger) elHunger.innerText = hunger;
    const barHunger = document.getElementById('bar-hunger'); if(barHunger) barHunger.style.width = Math.min(100, hunger) + '%';
    const elClean = document.getElementById('stat-clean'); if(elClean) elClean.innerText = clean;
    const barClean = document.getElementById('bar-clean'); if(barClean) barClean.style.width = Math.min(100, clean) + '%';
    const elMood = document.getElementById('stat-mood'); if(elMood) elMood.innerText = mood;
    const barMood = document.getElementById('bar-mood'); if(barMood) barMood.style.width = Math.min(100, mood) + '%';
    
    // 4. 更新积分显示 (修复积分不刷新的问题)
    const coinDisplay = document.getElementById('setting-coin-display');
    if(coinDisplay) coinDisplay.innerText = parseFloat(data.inventory.coins || 0).toFixed(2);

    // 5. 更新任务进度
    if(data.tasks) {
        const chatTaskEl = document.getElementById('chat-task-progress');
        if(chatTaskEl) chatTaskEl.innerText = `(${data.tasks.chat_count || 0}/30)`;
    }

    // 6. 🔥【关键修复】渲染智能托管按钮
    // 寻找重新领养按钮作为定位点
    const resetBtn = document.querySelector('#pet-settings-modal .m-btn.secondary'); 
    
    // 移除旧按钮防止重复
    const oldBtn = document.getElementById('btn-auto-care-toggle');
    if(oldBtn) oldBtn.remove();

    if (resetBtn) {
        const isAuto = data.config.autoCareEnabled; 
        const autoBtn = document.createElement('button');
        autoBtn.id = 'btn-auto-care-toggle';
        autoBtn.className = 'm-btn secondary'; // 使用同样的样式类
        autoBtn.style.width = '100%';
        autoBtn.style.marginBottom = '10px';
        autoBtn.style.fontWeight = 'bold';
        
        if (isAuto) {
            autoBtn.style.background = '#06c755'; // 绿色开启
            autoBtn.style.color = 'white';
            autoBtn.innerHTML = '🤖 智能托管：已开启 (点击关闭)';
        } else {
            autoBtn.style.background = '#e0e0e0'; // 灰色关闭
            autoBtn.style.color = '#555';
            autoBtn.innerHTML = '🤖 智能托管：已关闭 (点击开启)';
        }
        
        autoBtn.onclick = toggleAutoCare; // 绑定功能
        // 插入到重新领养按钮的上面
        resetBtn.parentNode.insertBefore(autoBtn, resetBtn);
    }
}

function petDailyCheckIn() {
    const data = window.BIG_MEMORY.pet_data; // 确保读取最新数据
    const today = new Date().toDateString();
    const last = new Date(data.tasks.last_checkin).toDateString();
    
    if (today === last) return alert("今天已经签到过了哦！");
    
    data.tasks.last_checkin = Date.now();
    data.inventory.coins += 10;
    savePetData(data);
    
    // 👇 新增这一行：立刻刷新界面上的余额显示
    updateSettingsUI(); 
    
    alert("签到成功！获得 10 积分。");
}
// === 🎰 赌狗大转盘核心逻辑 ===
function spinGamblingWheel() {
    const data = window.BIG_MEMORY.pet_data; // 确保读取最新数据
    const cost = 0.25;

    // 1. 检查钱够不够
    if (data.inventory.coins < cost) {
        return alert(`❌ 积分不足！需要 ${cost} 积分，你只有 ${parseFloat(data.inventory.coins).toFixed(2)}。`);
    }

    // 2. 扣钱
    data.inventory.coins -= cost;

    // 3. 准备奖池 (导入商店和洗护的所有物品)
    const pool = PET_CONFIG.items; 

    // 4. 抽奖逻辑：10% 概率中奖
    const isWin = Math.random() < 0.9; 

    let resultMsg = "";

    if (isWin) {
        // 中奖了！
        const prize = pool[Math.floor(Math.random() * pool.length)];
        
        // 入库
        if (!data.inventory.items[prize.id]) data.inventory.items[prize.id] = 0;
        data.inventory.items[prize.id]++;
        
        resultMsg = `🎉 欧皇附体！\n你抽中了：【${prize.name}】！\n(已放入背包)`;
    } else {
        // 没中奖
        const failMsgs = ["谢谢惠顾", "下次一定", "一阵风吹过...", "什么也没发生", "再试一次？"];
        const randomFail = failMsgs[Math.floor(Math.random() * failMsgs.length)];
        resultMsg = `💨 ${randomFail}\n(失去了 0.25 积分)`;
    }

    // 5. 保存数据 & 刷新界面
    savePetData(data); 
    updateSettingsUI(); 
    
    setTimeout(() => alert(resultMsg), 100);
}
function openCheatInput() {
    const code = prompt("请输入作者通道密码:");
    if (code === "103609") {
        const amount = parseInt(prompt("增加多少积分？"));
        if (!isNaN(amount)) {
            const data = getPetData();
            data.inventory.coins += amount;
            savePetData(data);
            alert(`已增加 ${amount} 积分！当前: ${data.inventory.coins}`);
        }
    } else {
        alert("密码错误");
    }
}

// 监听 Chat App 的消息来增加积分 (Hook)
const _origAppendMsg = window.appendMessage;
window.appendMessage = function(content, isMe, type, quote) {
    _origAppendMsg(content, isMe, type, quote);
    
    // 只有自己发的消息才算
    if (isMe) {
        const data = getPetData();
        data.tasks.chat_count++;
        if (data.tasks.chat_count >= 30) {
            data.tasks.chat_count = 0; // 重置循环
            data.inventory.coins += 5;
            NotificationManager.send({ title:"任务完成", body:"达成30次对话，获得5积分！" });
        }
        savePetData(data);
    }
}
// 🔴 修改版：点击装饰物逻辑
async function triggerDecorStory(decorName) {
    // 只要改这里的 confirm 提示文案即可
    if(confirm(`你看着家里的【${decorName}】...\n\n✨ 要生成一段相关的日常小故事吗？`)) {
        generatePetStory('互动', decorName);
    } else {
        // 用户选不见，只改数据(如果有数据要改的话，这里纯互动，不涉及数值也可以不改)
    }
}
// === 3. 修复故事生成 & 无限存储 ===
async function generatePetStory(action, objectName) {
    const data = window.BIG_MEMORY.pet_data; // 直接读取大容量内存
    
    // 获取设定
    const wb = window.BIG_MEMORY.world_book || {};
    // 优先读取 "18.宠物" 分类的设定
    const petCtx = (wb['18.宠物'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    const globalCtx = (wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");

    // 检查 API
    let apiKey = document.getElementById('api-key').value;
    let apiUrl = document.getElementById('api-url').value;
    let model = document.getElementById('model-select').value;
    
    if(!apiKey) {
        try { const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}'); apiKey=s.key; apiUrl=s.url; model=s.model; } catch(e){}
    }
    if(!apiKey) return alert("❌ 请先在桌面【设置】中配置 API Key！");
    if (!apiUrl) apiUrl = "https://api.openai.com/v1";

    // 提示词
    const prompt = `
你是一个温馨治愈的小说家。
【世界观/角色】：${globalCtx}
【宠物档案】：${petCtx || `名字:${data.config.name}, 种类:${data.config.type}`}

【事件】：用户对宠物进行了【${action}】操作，使用了【${objectName}】。

【任务】：
请写一段 100-200 字的温馨日常片段。
请描写宠物的反应（根据它的物种特性），以及它对主人的依恋。
如果世界观里有其他角色（如CP），也可以让他们客串出场。
**直接输出纯文本故事，不要JSON，不要Markdown。**
`;

    try {
        const res = await fetch(`${apiUrl.replace(/\/$/, "")}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model || "gpt-3.5-turbo",
                messages: [{role:"user", content:prompt}],
                temperature: 0.8
            })
        });

        const json = await res.json();
        if (json.error) throw new Error(json.error.message);
        
        // 🔴 修复：不强制解析 JSON，直接获取文本，避免格式错误导致的失败
        let story = json.choices[0].message.content;

        // 保存逻辑 (无限存储)
        if(!data.history) data.history = [];
        data.history.unshift({
            date: Date.now(),
            action: `${action} ${objectName}`,
            text: story
        });
        
        // 限制历史数量防止卡顿
        if(data.history.length > 50) data.history.pop();

        // 存入 IndexedDB
        savePetData(data);
        
        alert("✅ 故事已生成！请在【宠物日记】中查看。");
        updateSettingsUI(); // 刷新界面

    } catch(e) {
        console.error(e);
        alert("❌ 生成失败: " + e.message + "\n可能是 API Key 无效或网络问题。");
    }
}
// === 🎰 赌狗大转盘核心逻辑 ===
function spinGamblingWheel() {
    const data = getPetData();
    const cost = 0.25;

    // 1. 检查钱够不够
    if (data.inventory.coins < cost) {
        return alert(`❌ 积分不足！需要 ${cost} 积分，你只有 ${data.inventory.coins.toFixed(2)}。`);
    }

    // 2. 扣钱
    data.inventory.coins -= cost;

    // 3. 准备奖池 (导入商店和洗护的所有物品)
    // 这里的 PET_CONFIG.items 包含了所有食物和沐浴露
    const pool = PET_CONFIG.items; 

    // 4. 抽奖逻辑：十个里面抽一个 (10% 概率中奖)
    const isWin = Math.random() < 0.9; // 0.1 就是 10%

    let resultMsg = "";

    if (isWin) {
        // 中奖了！从池子里随机拿一个
        const prize = pool[Math.floor(Math.random() * pool.length)];
        
        // 入库 (无限存储)
        if (!data.inventory.items[prize.id]) data.inventory.items[prize.id] = 0;
        data.inventory.items[prize.id]++;
        
        resultMsg = `🎉 欧皇附体！\n你抽中了：【${prize.name}】！\n(已放入背包)`;
    } else {
        // 没中奖
        const failMsgs = ["谢谢惠顾", "下次一定", "一阵风吹过...", "什么也没发生", "再试一次？"];
        const randomFail = failMsgs[Math.floor(Math.random() * failMsgs.length)];
        resultMsg = `💨 ${randomFail}\n(失去了 0.25 积分)`;
    }

    // 5. 保存数据 & 刷新界面
    savePetData(data); // 存入无限数据库
    updateSettingsUI(); // 刷新显示的积分
    
    // 稍微延迟一点弹出结果，体验更好
    setTimeout(() => alert(resultMsg), 100);
}
function deletePetStory(index) {
    if(!confirm("删除这个故事？")) return;
    const data = getPetData();
    data.history.splice(index, 1);
    savePetData(data);
    updateSettingsUI();
}

// ==================== ✅ 终极系统启动入口 ====================
window.addEventListener('load', function() {
    console.log("⚡ 系统正在初始化...");
    
    // 1. 初始化数据库
    idb.init().then(async () => {
        
        // 2. 等待无限存储加载所有数据 (包括宠物、日记、设置等)
        await loadAllBigData();
        
        // 3. 加载其他资源
        loadTVContent();
        if(typeof loadGameWidgetTheme === 'function') loadGameWidgetTheme();
        try { await idb.get('settings_heavy', 'myAvatar'); } catch(e){}
        
        // 4. 刷新各个 APP 的界面 (确保数据加载后立即显示)
        if(typeof renderLetterList === 'function') renderLetterList();
        if(typeof renderFinanceUI === 'function') renderFinanceUI();
        if(typeof updateGameStatsUI === 'function') updateGameStatsUI();
        if(typeof updateSettingsUI === 'function') updateSettingsUI(); // 刷新宠物设置页积分
        
        // 5. 预渲染宠物背景 (即使在第1页也要先渲染，防止滑过去是白的)
        if(typeof renderPetMain === 'function') renderPetMain();

        console.log("✅ 系统启动完毕！所有组件已就绪。");
    });
});
// ==================== 🐾 宠物日记 APP 独立逻辑 ====================

// 1. 打开 APP
function openPetDiaryApp() {
    document.getElementById('pet-diary-app-modal').style.display = 'flex';
    renderPetDiaryList();
}

// 2. 渲染列表 (从无限存储读取)
function renderPetDiaryList() {
    // 直接从大容量内存读取，确保是最新数据
    const data = window.BIG_MEMORY.pet_data; 
    const container = document.getElementById('pet-diary-full-list');
    container.innerHTML = '';

    // 容错处理：如果没有宠物数据或历史
    if (!data || !data.history || data.history.length === 0) {
        container.innerHTML = `
            <div style="text-align:center; color:#999; margin-top:50px;">
                <p>暂无日记...</p>
                <p style="font-size:0.8rem;">去给宠物喂食、洗澡或点击装饰物<br>生成你们的第一篇故事吧！</p>
            </div>`;
        return;
    }

    // 遍历历史记录 (倒序，最新的在上面)
    data.history.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'morandi-card';
        div.style.marginBottom = '15px';
        div.style.padding = '15px';
        div.style.background = '#fff';
        div.style.borderLeft = '4px solid #ffcc80'; // 装饰线
        
        div.innerHTML = `
            <div style="display:flex; justify-content:space-between; align-items:center; border-bottom:1px dashed #eee; padding-bottom:8px; margin-bottom:8px;">
                <span style="font-size:0.8rem; color:#888;">${new Date(item.date).toLocaleString()}</span>
                <span style="font-size:0.8rem; font-weight:bold; color:#d35400;">${item.action}</span>
            </div>
            <div style="font-size:0.95rem; color:#333; line-height:1.6; text-align:justify;">
                ${item.text.replace(/\n/g, '<br>')}
            </div>
            <div style="text-align:right; margin-top:10px;">
                <button class="m-btn small" onclick="deletePetDiaryEntry(${index})" style="background:#ffcdd2; color:#c62828; font-size:0.7rem; padding:4px 10px;">🗑️ 删除</button>
            </div>
        `;
        container.appendChild(div);
    });
}

// 3. 删除单条日记 (同步更新无限存储)
function deletePetDiaryEntry(index) {
    if(!confirm("确定要撕掉这一页日记吗？(无法恢复)")) return;
    
    const data = window.BIG_MEMORY.pet_data;
    if(data && data.history) {
        data.history.splice(index, 1); // 删除
        
        // 🔥 关键：保存回 IndexedDB (无限存储)
        window.savePetData(data);
        
        // 刷新列表
        renderPetDiaryList();
    }
}
// ==================== 😈 阴暗面 (Shadow Side) 核心逻辑 ====================

let shadowDeck = [];
let shadowFlipped = [];

// 1. 数据存取 (无限存储)
function getShadowData() { return window.BIG_MEMORY.shadow_data || []; }
function saveShadowData(list) {
    window.BIG_MEMORY.shadow_data = list;
    if(typeof idb !== 'undefined') idb.put('universal_store', { id: 'shadow_data', data: list });
}

// 2. 打开 APP
function openShadowApp() {
    document.getElementById('shadow-app-modal').style.display = 'flex';
    renderShadowHistory();
}

// 3. 渲染历史记录
function renderShadowHistory() {
    const list = getShadowData();
    const container = document.getElementById('shadow-history-list');
    container.innerHTML = '';

    if (list.length === 0) {
        container.innerHTML = `<div style="text-align:center; color:#636e72; padding:20px;">暂无记录...<br>他还隐藏得很好。</div>`;
        return;
    }

    list.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'morandi-card';
        div.style.background = '#2d3436'; // 深色卡片
        div.style.border = '1px solid #636e72';
        div.style.marginBottom = '15px';
        div.style.padding = '15px';
        div.style.color = '#dfe6e9';

        div.innerHTML = `
            <div style="display:flex; justify-content:space-between; font-size:0.8rem; color:#b2bec3; margin-bottom:10px; border-bottom:1px dashed #636e72; padding-bottom:5px;">
                <span>${new Date(item.date).toLocaleString()}</span>
                <span style="color:#d63031; cursor:pointer; font-weight:bold;" onclick="deleteShadowItem(${index})">销毁罪证</span>
            </div>
            <div style="font-size:0.8rem; color:#ff7675; margin-bottom:10px;">🔮 命运牌: ${item.cards}</div>
            
            <!-- 表格显示区域 -->
            <div style="background:#000; padding:10px; border-radius:4px; font-size:0.9rem; line-height:1.5;">
                ${item.tableHTML}
            </div>
        `;
        container.appendChild(div);
    });
}

// 4. 删除功能
function deleteShadowItem(index) {
    if(!confirm("确定要销毁这份阴暗档案吗？(不可恢复)")) return;
    const list = getShadowData();
    list.splice(index, 1);
    saveShadowData(list);
    renderShadowHistory();
}

// 5. 启动抽牌 (独立逻辑)
function startShadowDraw() {
    const modal = document.getElementById('shadow-card-table-modal');
    const area = document.getElementById('shadow-card-area');
    const desk = document.getElementById('shadow-card-table-desk');
    
    // 应用美化 (复用塔罗桌布设置)
    idb.get('settings_heavy', 'tarot_table').then(res => {
        if(res && res.data) {
            desk.style.backgroundImage = `url(${res.data})`;
            desk.style.backgroundSize = 'cover';
        }
    });

    area.innerHTML = '';
    shadowDeck = []; shadowFlipped = [];
    document.getElementById('shadow-flipped-count').innerText = '0';

    // 114张全牌库 (塔罗+雷诺曼)
    for(let i=0; i<=77; i++) shadowDeck.push({ type:'tarot', id:i, isReversed:Math.random()<0.3 });
    for(let i=1; i<=36; i++) shadowDeck.push({ type:'lenormand', id:i, isReversed:false });
    shadowDeck.sort(()=>Math.random()-0.5);

    // 布局计算
    const deskW = window.innerWidth;
    const cardWidth=60, cardHeight=90, gap=10;
    let cols = Math.floor((deskW-20)/(cardWidth+gap)); if(cols<4) cols=4;
    const startX = (deskW - (cols*(cardWidth+gap)))/2;

    shadowDeck.forEach((card, i) => {
        const el = document.createElement('div');
        el.className = 'playing-card';
        const col = i % cols, row = Math.floor(i / cols);
        el.style.left = (startX + col*(cardWidth+gap)) + 'px';
        el.style.top = (60 + row*(cardHeight+gap)) + 'px';
        el.style.transform = `rotate(${Math.random()*6-3}deg)`;
        
        const front = document.createElement('div');
        front.className = 'playing-card-front';
        el.appendChild(front);
        
        el.onclick = async () => {
            if(el.classList.contains('flipped')) {
                el.classList.remove('flipped');
                shadowFlipped = shadowFlipped.filter(c => !(c.type===card.type && c.id===card.id));
            } else {
                el.classList.add('flipped');
                shadowFlipped.push(card);
                // 加载图片
                const dbName = card.type==='tarot'?'tarot_deck':'lenormand_deck';
                const item = await idb.get(dbName, card.id);
                if(item && item.data) front.style.backgroundImage = `url(${item.data})`;
                else { front.style.backgroundColor='#b2bec3'; front.innerText=card.id; }
                if(card.isReversed) front.style.transform = "rotateY(180deg) rotate(180deg)";
                else front.style.transform = "rotateY(180deg)";
            }
            document.getElementById('shadow-flipped-count').innerText = shadowFlipped.length;
        };
        area.appendChild(el);
    });
    
    // 设置滚动高度
    const rows = Math.ceil(shadowDeck.length/cols);
    area.style.height = (60 + rows*(cardHeight+gap) + 150) + 'px';
    modal.style.display = 'flex';
}

// 6. 生成 API (核心 Prompt)
async function finishShadowAnalysis() {
    if(shadowFlipped.length === 0) return alert("请至少翻一张牌，这是进入他内心的钥匙。");
    
    // UI 锁定
    const btn = document.querySelector('#shadow-card-table-modal .m-btn.primary');
    const oldText = btn.innerText;
    btn.innerText = "🩸 正在解剖潜意识..."; btn.disabled = true;

    // 准备数据
    const cardsDesc = shadowFlipped.map(c => (c.type==='tarot'?TAROT_NAMES[c.id]:LENORMAND_NAMES[c.id]) + (c.isReversed?"(逆)":"")).join(", ");
    const wb = getWBData();
    const globalCtx = (wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    
    let apiKey = document.getElementById('api-key').value;
    let apiUrl = document.getElementById('api-url').value || "https://api.openai.com/v1";
    let model = document.getElementById('model-select').value || "gpt-3.5-turbo";
    
    // 缓存读取
    if(!apiKey) { try { const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}'); apiKey=s.key; apiUrl=s.url; model=s.model; } catch(e){} }
    if(!apiKey) { btn.innerText=oldText; btn.disabled=false; return alert("请配置 API Key"); }

    const prompt = `
你是一位精通暗黑心理学和病娇人格分析的大师。
【角色/世界观】：${globalCtx}
【抽到的命运牌 (必须完全基于牌意进行阴暗解读)】：${cardsDesc}

【任务要求】
请生成一个 **HTML 表格** (table)，剖析角色对 User (我) 的阴暗面。
语气要求：**阴暗、病娇、占有欲强、令人战栗**。
不要解释，直接给出结果。

【表格内容 (必须包含以下 10 项)】：
1. **对外人的阴暗面**：(他对别人有多冷酷/残忍？)
2. **对User未说过的阴暗面**：(内心深处压抑的想法)
3. **对User说过的阴暗面**：(哪怕是玩笑话里的真意)
4. **视奸倾向**：(会不会偷偷视奸？程度如何？)
5. **查岗倾向**：(会不会翻手机/监控？)
6. **占有欲等级**：(1-10级，写明等级并描述状态)
7. **隐瞒的阴暗追求**：(他在追求过程中做了什么不光彩的事？)
8. **最过分的性幻想**：(不敢让User知道的、尺度较大的幻想，描述要露骨但隐晦，充满张力)
9. **如果他是小三**：(会怎么上位？怎么破坏原配？)
10. **如果是正宫见情敌**：(看见别人追求User时的阴暗想法/处理手段)

【输出格式】
只输出 HTML 代码 (<table>...</table>)，不要 Markdown，不要 JSON。
表格样式简单即可，重点是内容。
`;

    try {
        const res = await fetch(`${apiUrl}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model,
                messages: [{role:"system", content:"You are a dark psychology expert. Output HTML table only."}, {role:"user", content:prompt}],
                temperature: 0.85
            })
        });
        const json = await res.json();
        let html = json.choices[0].message.content.trim();
        // 清洗 Markdown
        html = html.replace(/```html/gi, "").replace(/```/g, "").trim();
        
        // 加上样式类以便 CSS 控制
        html = html.replace('<table>', '<table class="dream-table shadow-table">'); // 复用 dream-table 样式

        // 保存并显示
        const list = getShadowData();
        list.unshift({
            date: Date.now(),
            cards: cardsDesc,
            tableHTML: html
        });
        saveShadowData(list);
        
        // 关闭牌桌，回到主界面刷新
        document.getElementById('shadow-card-table-modal').style.display = 'none';
        renderShadowHistory();

    } catch(e) {
        alert("潜入失败: " + e.message);
    } finally {
        btn.innerText = oldText; btn.disabled = false;
    }
}
</script>
<div id="sys-toast-container" class="sys-toast-container"></div>
<!-- 信件专用抽牌桌 (新增) -->
<div id="letter-card-table-modal" class="modal-overlay" style="background: rgba(45, 52, 54, 0.95); backdrop-filter: blur(5px);">
    <div style="width: 100%; height: 100%; position: relative; overflow-y: auto; overflow-x: hidden; padding-bottom: 100px;">
        <div id="letter-card-area" style="width: 100%; height: 100%; position: relative; transform-style: preserve-3d; perspective: 1000px;">
        </div>
        <div class="card-table-ui">
            <div style="color:#dfe6e9; text-shadow:0 1px 5px #000; font-size:1.1rem; font-weight:bold;">
                抽取命运牌，判断Ta是否已读... (已选: <span id="letter-flipped-count">0</span>)
            </div>
            <button class="m-btn primary" onclick="finishLetterReading()" style="background:#636e72; border:1px solid #b2bec3; box-shadow:0 0 15px rgba(255,255,255, 0.2);">
                🎴 确认并生成回信
            </button>
            <button class="m-btn secondary" onclick="document.getElementById('letter-card-table-modal').style.display='none'" style="background:rgba(255,255,255,0.2); color:white;">
                取消
            </button>
        </div>
    </div>
</div>
<!-- ================= 🔴 学习总结 APP 修复补丁 (请粘贴在这里) START 🔴 ================= -->

<!-- 1. 界面结构 -->
<div id="summary-app-modal" class="modal-overlay" style="background:#f1f2f6; z-index:9999; display:none;">
    <div class="modal-header" style="background:#fff; color:#2c3e50; border-bottom:1px solid #dfe6e9; padding-top: max(20px, env(safe-area-inset-top)); height:auto; min-height:80px; display:flex; align-items:flex-end;">
        <span style="font-weight:bold; font-size:1.1rem; margin-left:15px; margin-bottom:10px;">📝 学习总结</span>
        <button class="close-btn" onclick="document.getElementById('summary-app-modal').style.display='none'" style="margin-bottom:5px; font-size:2rem; color:#333;">×</button>
    </div>

    <div class="modal-body" style="padding:15px; padding-bottom:100px; overflow-y:auto;">
        <!-- 顶部切换按钮 -->
        <div style="display:flex; background:#fff; padding:10px; margin-bottom:15px; border-radius:12px; gap:10px; box-shadow:0 2px 5px rgba(0,0,0,0.05);">
            <button class="m-btn small" onclick="switchSummaryView('create')" id="btn-sum-create" style="flex:1; background:#607d8b; color:white; padding:10px;">✨ 新建</button>
            <button class="m-btn small" onclick="switchSummaryView('history')" id="btn-sum-history" style="flex:1; background:#eceff1; color:#333; padding:10px;">📂 历史</button>
        </div>

        <!-- A. 新建页面 -->
        <div id="summary-create-view">
            <div class="morandi-card" style="padding:20px;">
                <div class="input-group">
                    <label style="font-weight:bold; color:#546e7a;">📚 科目 / 领域</label>
                    <input type="text" id="sum-subject" placeholder="例如：高等数学、Python编程..." style="background:#f9f9f9;">
                </div>
                <div class="input-group" style="margin-top:15px;">
                    <label style="font-weight:bold; color:#546e7a;">✍️ 学习笔记 / 困惑点</label>
                    <textarea id="sum-notes" class="editor-textarea" style="height:120px; background:#f9f9f9; padding:10px;" placeholder="在此粘贴你的笔记，或写下你学到的内容..."></textarea>
                </div>
                <div class="input-group" style="margin-top:15px;">
                    <label style="display:flex; align-items:center; color:#78909c; font-size:0.85rem;">
                        <input type="checkbox" id="sum-use-wb" checked style="width:auto; margin-right:5px; transform:scale(1.2);"> 
                        <span>引用世界书人设 (让角色来辅导你)</span>
                    </label>
                </div>
                <button class="m-btn primary" onclick="generateSummary()" id="btn-sum-gen" style="background:#607d8b; width:100%; margin-top:20px; height:50px; font-size:1rem; box-shadow:0 4px 10px rgba(96, 125, 139, 0.3);">🧠 开始分析总结</button>
            </div>
            
            <!-- 结果展示区 -->
            <div id="summary-result-area" style="display:none; margin-top:20px; animation: fadeIn 0.5s;">
                <div class="morandi-card" style="border-left: 5px solid #f39c12; padding:15px; margin-bottom:10px;">
                    <h4 style="margin:0 0 10px 0; color:#d35400;">❓ 发现的问题 & 盲点</h4>
                    <div id="res-questions" style="font-size:0.95rem; line-height:1.6; color:#333;"></div>
                </div>
                <div class="morandi-card" style="border-left: 5px solid #3498db; padding:15px; margin-bottom:10px;">
                    <h4 style="margin:0 0 10px 0; color:#2980b9;">🌍 知识点扩展</h4>
                    <div id="res-expansion" style="font-size:0.95rem; line-height:1.6; color:#333;"></div>
                </div>
                <div class="morandi-card" style="border-left: 5px solid #27ae60; padding:15px; margin-bottom:10px;">
                    <h4 style="margin:0 0 10px 0; color:#27ae60;">📅 下一步计划 & 推荐</h4>
                    <div id="res-plan" style="font-size:0.95rem; line-height:1.6; color:#333;"></div>
                </div>
                <button class="m-btn small" onclick="saveSummaryResult()" style="width:100%; margin-top:15px; background:#bdc3c7; color:#333; height:45px;">💾 确认保存到历史</button>
            </div>
        </div>

        <!-- B. 历史页面 -->
        <div id="summary-history-view" style="display:none;">
            <div id="summary-history-list" style="padding-bottom:50px;"></div>
        </div>
    </div>
</div>

<!-- 2. 功能脚本 -->
<script>
(function() {
    console.log("正在初始化学习总结 APP...");

    // 1. 初始化数据结构 (无限存储)
    if (!window.BIG_MEMORY) window.BIG_MEMORY = {};
    if (!window.BIG_MEMORY.summary_data) window.BIG_MEMORY.summary_data = [];

    // 2. 挂载全局函数
    window.getSummaryData = function() { return window.BIG_MEMORY.summary_data || []; };
    
    window.saveSummaryData = function(list) {
        window.BIG_MEMORY.summary_data = list;
        if (typeof idb !== 'undefined' && idb.put) {
            idb.put('universal_store', { id: 'summary_data', data: list });
        }
    };

    window.openSummaryApp = function() {
        const modal = document.getElementById('summary-app-modal');
        if(modal) {
            modal.style.display = 'flex';
            switchSummaryView('create');
        } else {
            alert("错误：界面加载失败，请检查代码粘贴位置！");
        }
    };

    window.switchSummaryView = function(mode) {
        const createEl = document.getElementById('summary-create-view');
        const histEl = document.getElementById('summary-history-view');
        const btnCreate = document.getElementById('btn-sum-create');
        const btnHist = document.getElementById('btn-sum-history');

        if (mode === 'create') {
            createEl.style.display = 'block';
            histEl.style.display = 'none';
            btnCreate.style.background = '#607d8b'; btnCreate.style.color = '#fff';
            btnHist.style.background = '#eceff1'; btnHist.style.color = '#333';
        } else {
            createEl.style.display = 'none';
            histEl.style.display = 'block';
            btnCreate.style.background = '#eceff1'; btnCreate.style.color = '#333';
            btnHist.style.background = '#607d8b'; btnHist.style.color = '#fff';
            renderSummaryHistory();
        }
    };

    let pendingSummary = null;

    window.generateSummary = async function() {
        const subject = document.getElementById('sum-subject').value;
        const notes = document.getElementById('sum-notes').value;
        if (!subject || !notes) return alert("请填写内容！");

        const btn = document.getElementById('btn-sum-gen');
        const oldText = btn.innerText;
        btn.disabled = true; btn.innerText = "🧠 正在连接大脑...";

        // 获取 API Key
        let apiKey = "";
        try { apiKey = document.getElementById('api-key').value; } catch(e){}
        if(!apiKey) {
            try { const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}'); apiKey=s.key; } catch(e){}
        }
        if(!apiKey) { 
            alert("请先在桌面【设置】中配置 API Key！");
            btn.disabled = false; btn.innerText = oldText;
            return;
        }

        let apiUrl = document.getElementById('api-url')?.value || "https://api.openai.com/v1";
        if(apiUrl.endsWith('/')) apiUrl = apiUrl.slice(0,-1);
        let model = document.getElementById('model-select')?.value || "gpt-3.5-turbo";

        // 获取世界书上下文
        const wb = window.BIG_MEMORY.world_book || {};
        const globalCtx = document.getElementById('sum-use-wb').checked 
            ? (wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n") 
            : "";

        const prompt = `
你是一位专业的学习导师，同时你需要**严格扮演世界书中的角色**。
【世界观/角色】：${globalCtx}

【用户输入】
科目：${subject}
笔记内容：${notes}

【任务】
请以角色的口吻，对用户的笔记进行深度分析总结。
**必须严格输出 JSON 格式**，不要 Markdown 代码块。

【JSON 结构】
{
  "questions": "指出笔记中逻辑不通、遗漏的关键点，或者针对笔记内容提出 2-3 个启发性问题。",
  "expansion": "根据笔记内容，扩展延伸相关的知识点、背景或高级用法（角色视角的见解）。",
  "plan": "推荐下一步的学习目标、具体的教材名称、教程链接关键词（必须真实存在）。"
}
`;

        try {
            const res = await fetch(`${apiUrl}/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    messages: [{role:"system", content:"You are a helpful tutor. Output JSON only."}, {role:"user", content:prompt}],
                    temperature: 0.7
                })
            });

            const json = await res.json();
            if(json.error) throw new Error(json.error.message);
            
            let raw = json.choices[0].message.content.replace(/```json/g,"").replace(/```/g,"").trim();
            // 简单容错
            const first = raw.indexOf('{'); const last = raw.lastIndexOf('}');
            if(first !== -1 && last !== -1) raw = raw.substring(first, last+1);
            
            const result = JSON.parse(raw);

            document.getElementById('res-questions').innerText = result.questions;
            document.getElementById('res-expansion').innerText = result.expansion;
            document.getElementById('res-plan').innerText = result.plan;
            document.getElementById('summary-result-area').style.display = 'block';
            
            pendingSummary = {
                id: Date.now(),
                date: new Date().toLocaleString(),
                subject: subject,
                notes: notes,
                result: result
            };

        } catch(e) {
            console.error(e);
            alert("生成失败: " + e.message);
        } finally {
            btn.innerText = oldText; btn.disabled = false;
        }
    };

    window.saveSummaryResult = function() {
        if (!pendingSummary) return;
        const list = getSummaryData();
        list.unshift(pendingSummary);
        saveSummaryData(list);
        alert("✅ 已保存到历史记录！");
        document.getElementById('summary-result-area').style.display = 'none';
        document.getElementById('sum-notes').value = '';
        switchSummaryView('history');
    };

    window.renderSummaryHistory = function() {
        const list = getSummaryData();
        const container = document.getElementById('summary-history-list');
        container.innerHTML = '';
        
        if (list.length === 0) {
            container.innerHTML = '<div style="text-align:center; color:#999; padding:30px;">暂无记录</div>';
            return;
        }

        list.forEach((item, index) => {
            const div = document.createElement('div');
            div.className = 'morandi-card';
            div.style.marginBottom = '15px'; 
            div.style.padding = '15px';
            div.style.background = '#fff';
            
            div.innerHTML = `
                <div style="display:flex; justify-content:space-between; border-bottom:1px solid #eee; padding-bottom:8px; margin-bottom:10px;">
                    <span style="font-weight:bold; color:#607d8b; font-size:1rem;">📘 ${item.subject}</span>
                    <span style="font-size:0.8rem; color:#999;">${item.date}</span>
                </div>
                
                <div style="font-size:0.85rem; background:#f5f5f5; padding:8px; border-radius:6px; margin-bottom:12px; color:#555;">
                    📝 <strong>笔记:</strong> ${item.notes.substring(0, 50)}...
                </div>

                <div style="font-size:0.9rem; line-height:1.6; color:#333;">
                    <div style="margin-bottom:8px;"><strong style="color:#d35400;">❓ 问题:</strong> ${item.result.questions}</div>
                    <div style="margin-bottom:8px;"><strong style="color:#2980b9;">🌍 扩展:</strong> ${item.result.expansion}</div>
                    <div><strong style="color:#27ae60;">📅 计划:</strong> ${item.result.plan}</div>
                </div>

                <div style="text-align:right; margin-top:10px;">
                    <button class="m-btn small" onclick="deleteSummaryItem(${index})" style="background:#ffcdd2; color:#c0392b; font-size:0.8rem; padding:5px 12px;">🗑️ 删除</button>
                </div>
            `;
            container.appendChild(div);
        });
    };

    window.deleteSummaryItem = function(index) {
        if (!confirm("确定删除这条记录？")) return;
        const list = getSummaryData();
        list.splice(index, 1);
        saveSummaryData(list);
        renderSummaryHistory();
    };

    // 3. 强制数据加载
    setTimeout(async () => {
        try {
            if(typeof idb !== 'undefined') {
                const res = await idb.get('universal_store', 'summary_data');
                if(res) window.BIG_MEMORY.summary_data = res.data;
            }
        } catch(e) {}
    }, 1000);

})();
</script>
<!-- ================= 🔴 学习总结 APP 修复补丁 END 🔴 ================= -->
<div id="lofter-modal" class="modal-overlay" style="background:#fff;">
    <div class="fridge-header-clean" style="border-bottom:none;">
        <button class="fh-btn" onclick="document.getElementById('lofter-modal').style.display='none'">❮ 返回</button>
        <span class="fh-title" style="color:#2c6e49; font-weight:900; letter-spacing:1px;">LOFTER</span>
        <div style="width:30px;"></div> <!-- 占位 -->
    </div>
    
    <!-- 新增：用户要求输入框 -->
    <div class="lofter-toolbar">
        <input type="text" id="lofter-user-req" class="lofter-input" placeholder="输入梗/设定/想看的 (如: 校园PA/破镜重圆)...">
        <button class="fh-btn" onclick="generateLofterFeed()" style="font-weight:bold; color:#2c6e49;">产粮</button>
    </div>

    <div id="lofter-scroll-area" style="flex:1; overflow-y:auto; background:#f2f2f2; padding:10px;">
        <div id="lofter-feed-list"></div>
        <div style="text-align:center; padding:20px; color:#999; font-size:0.8rem;">
            <span onclick="clearLofterHistory()" style="text-decoration:underline; cursor:pointer;">清空所有历史</span>
        </div>
    </div>
</div>

<div id="lofter-detail-modal" class="modal-overlay" style="background:#fff; z-index:2100;">
    <div class="fridge-header-clean">
        <button class="fh-btn" onclick="closeLofterDetail()">❮ 返回列表</button>
        <span class="fh-title">阅读正文</span>
        <div style="width:30px;"></div>
    </div>
    <div id="lofter-article-body" style="flex:1; overflow-y:auto; padding:20px; font-family:'Songti SC', serif; line-height:1.8;">
        <!-- 正文内容 -->
    </div>
</div>
<!-- 关于痛苦 APP 主界面 -->
<div id="pain-app-modal" class="modal-overlay" style="background:#f5f6fa;">
    <div class="modal-header" style="background:#dcdde1; color:#2f3640;">
        <span>关于痛苦 · Pain & Healing</span>
        <button class="close-btn" onclick="document.getElementById('pain-app-modal').style.display='none'">×</button>
    </div>
    
    <div class="modal-body" style="padding:0;">
        <!-- 顶部标签切换 -->
        <div style="display:flex; background:#fff; padding:10px 20px; box-shadow:0 2px 5px rgba(0,0,0,0.05);">
            <button class="m-btn small" onclick="switchPainTab('his')" id="btn-tab-his" style="flex:1; margin-right:5px; background:#2f3640; color:white;">关于他的痛苦</button>
            <button class="m-btn small" onclick="switchPainTab('my')" id="btn-tab-my" style="flex:1; margin-left:5px; background:#dfe4ea;">关于你的痛苦</button>
        </div>

        <!-- 1. 关于他的痛苦 -->
        <div id="pain-tab-his" style="padding:20px; overflow-y:auto; padding-bottom:80px;">
            <div class="morandi-card" style="text-align:center; padding:30px; margin-bottom:20px;">
                <h3 style="color:#2f3640;">洞察他的伤痕</h3>
                <p style="font-size:0.8rem; color:#7f8fa6;">通过牌意，感知他未曾言说的痛楚与渴望。</p>
                <button class="m-btn primary" onclick="startPainDraw('his')" style="margin-top:15px; background:#2f3640;">🔮 抽取牌组并解析</button>
            </div>
            <div id="pain-his-history"></div> <!-- 历史记录区 -->
        </div>

        <!-- 2. 关于你的痛苦 -->
        <div id="pain-tab-my" style="display:none; padding:20px; overflow-y:auto; padding-bottom:80px;">
            <div class="morandi-card">
                <h3 style="margin-bottom:15px; color:#2f3640;">倾诉与疗愈</h3>
                <div class="input-group"><label>痛苦的根源 (Pain)</label><textarea id="my-pain-source" class="editor-textarea" style="height:60px;"></textarea></div>
                <div class="input-group"><label>你的感受 (Feeling)</label><textarea id="my-pain-feeling" class="editor-textarea" style="height:60px;"></textarea></div>
                <div class="input-group"><label>目前的想法 (Thought)</label><textarea id="my-pain-thought" class="editor-textarea" style="height:60px;"></textarea></div>
                <div class="input-group"><label>期望的调节方案 (Plan)</label><textarea id="my-pain-plan" class="editor-textarea" style="height:60px;"></textarea></div>
                <div class="input-group"><label>希望他如何帮你 (Help)</label><textarea id="my-pain-help" class="editor-textarea" style="height:60px;"></textarea></div>
                
                <div style="display:flex; gap:10px; margin-top:15px;">
                    <button class="m-btn secondary" onclick="saveMyPainDraft()">💾 暂存草稿</button>
                    <button class="m-btn primary" onclick="startPainDraw('my')" style="background:#2f3640;">📨 发送并获取回应</button>
                </div>
            </div>
            <div id="pain-my-reply-area" style="margin-top:20px;"></div>
        </div>
    </div>
</div>
<!-- 🔥 修正版：关于痛苦专用全功能牌桌 (114张全牌库) -->
<div id="pain-card-table-modal" class="modal-overlay" style="background: rgba(20, 20, 30, 0.95); backdrop-filter: blur(5px);">
    <div id="pain-card-table-desk" style="width: 100%; height: 100%; position: relative; overflow-y: auto; overflow-x: hidden; padding-bottom: 100px; box-shadow: inset 0 0 100px rgba(0,0,0,0.8);">
        <!-- 这里的 ID 是 pain-card-area，用于 JS 生成卡片 -->
        <div id="pain-card-area" style="width: 100%; height: 100%; position: relative; transform-style: preserve-3d; perspective: 1000px;">
        </div>
        
        <!-- 底部控制栏 -->
        <div class="card-table-ui">
            <div style="color:#dcdde1; text-shadow:0 1px 3px #000; font-weight:bold;">
                请抽取能够揭示真相的牌... (已选: <span id="pain-flipped-count">0</span>)
            </div>
            <button class="m-btn primary" onclick="finishPainAnalysis()" style="background:#2f3640; border:1px solid #718093; box-shadow:0 0 15px rgba(255,255,255,0.1);">
                👁️ 确认并开始解读
            </button>
            <button class="m-btn secondary" onclick="document.getElementById('pain-card-table-modal').style.display='none'">
                取消
            </button>
        </div>
    </div>
</div>
<!-- 🍬 扭蛋机主界面 (历史记录 + 机器) -->
<div id="gashapon-app-modal" class="modal-overlay" style="background:#fff0f5;">
    <div class="modal-header" style="background:#ffcdd2; color:#c62828;">
        <span>平行世界扭蛋机</span>
        <button class="close-btn" onclick="document.getElementById('gashapon-app-modal').style.display='none'">×</button>
    </div>
    <div class="modal-body" style="padding:0; display:flex; flex-direction:column;">
        <!-- 机器展示区 -->
        <div style="flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; background: radial-gradient(circle, #fff 20%, #ffebee 100%);">
            <div class="gashapon-machine" onclick="triggerGashaponStart()">
                <div class="gm-glass">
                    <div class="gm-ball b1"></div><div class="gm-ball b2"></div><div class="gm-ball b3"></div>
                </div>
                <div class="gm-body">
                    <div class="gm-knob"></div>
                    <div class="gm-exit"></div>
                </div>
                <div class="gm-label">PUSH</div>
            </div>
            <p style="margin-top:20px; color:#ef9a9a; font-weight:bold;">点击扭蛋机，开启一段平行人生</p>
        </div>
        
        <!-- 底部历史记录抽屉 -->
        <div class="gashapon-history-drawer">
            <div class="gh-handle" onclick="toggleGashaponHistory()">📜 查看收藏的扭蛋故事</div>
            <div id="gashapon-history-list" class="gh-list"></div>
        </div>
    </div>
</div>

<!-- 🍬 输入设定弹窗 -->
<div id="gashapon-input-modal" class="modal-overlay" style="background:rgba(0,0,0,0.5); z-index:2200; align-items:center; justify-content:center;">
    <div class="morandi-card" style="width:85%; max-width:400px; padding:20px; animation: popIn 0.3s;">
        <h3 style="color:#e91e63; margin-bottom:10px;">设定你的平行世界</h3>
        <p style="font-size:0.8rem; color:#888; margin-bottom:10px;">如果不填，将随机掉落一个世界。</p>
        <textarea id="gashapon-scenario" class="editor-textarea" style="height:100px; margin-bottom:15px;" placeholder="例如：他是吸血鬼，我是猎人 / 我们是青梅竹马但失散多年 / ABO设定..."></textarea>
        <div style="display:flex; gap:10px;">
            <button class="m-btn secondary" onclick="document.getElementById('gashapon-input-modal').style.display='none'">取消</button>
            <button class="m-btn primary" onclick="enterGashaponTable()" style="background:#f48fb1;">🎲以此设定去抽牌</button>
        </div>
    </div>
</div>

<!-- 🍬 专用独立牌桌 (复制自游戏机，改ID) -->
<div id="gashapon-card-table-modal" class="modal-overlay" style="background: rgba(40, 20, 30, 0.95); backdrop-filter: blur(5px);">
    <div id="gashapon-card-table-desk" style="width: 100%; height: 100%; position: relative; overflow-y: auto; overflow-x: hidden; padding-bottom: 100px;">
        <div id="gashapon-card-area" style="width: 100%; height: 100%; position: relative; transform-style: preserve-3d; perspective: 1000px;"></div>
        <div class="card-table-ui">
            <div style="color:#f8bbd0; text-shadow:0 1px 5px #000; font-weight:bold;">
                抽取命运卡牌，编织世界线... (<span id="gashapon-flipped-count">0</span>)
            </div>
            <button class="m-btn primary" onclick="finishGashaponDrawing()" style="background:#ec407a; border:1px solid #ff80ab; box-shadow:0 0 15px rgba(236, 64, 122, 0.4);">
                🔮 生成平行故事
            </button>
            <button class="m-btn secondary" onclick="document.getElementById('gashapon-card-table-modal').style.display='none'" style="background:rgba(255,255,255,0.2); color:white;">取消</button>
        </div>
    </div>
</div>

<!-- 🍬 最终结果：巨大的未开封扭蛋 -->
<div id="gashapon-capsule-modal" class="modal-overlay" style="background:rgba(0,0,0,0.8); z-index:3000; align-items:center; justify-content:center;">
    <div id="big-capsule" class="big-capsule" onclick="openBigCapsule()">
        <div class="bc-top"></div>
        <div class="bc-bottom"></div>
        <div class="bc-text">CLICK TO OPEN</div>
    </div>
    
    <!-- 故事纸条 (初始隐藏) -->
    <div id="gashapon-story-paper" class="story-paper" style="display:none;">
        <div class="sp-header">
            <span id="sp-date">DATE</span>
            <span class="sp-tag">PARALLEL WORLD</span>
        </div>
        <div class="sp-content" id="gashapon-story-content"></div>
        <div class="sp-footer">
            <button class="m-btn small" onclick="closeGashaponResult()">收藏并关闭</button>
        </div>
    </div>
</div>
<!-- 宠物：领养弹窗 -->
<div id="pet-adopt-modal" class="modal-overlay" style="z-index:5000; background:#fffbe7;">
    <div class="modal-header" style="background:#f0e68c;"><span>领养中心</span></div>
    <div class="modal-body" style="text-align:center;">
        <h3>请选择你的伙伴</h3>
        <div id="adopt-grid" style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px; margin-bottom:20px;">
            <!-- JS填充 -->
        </div>
        <div class="input-group">
            <label>上传照片 (自定义)</label>
            <input type="file" id="adopt-upload" accept="image/*">
        </div>
        <div class="input-group">
            <label>取个名字</label>
            <input type="text" id="adopt-name" placeholder="Name...">
        </div>
        <button class="m-btn primary" onclick="confirmAdoption()">确认领养</button>
    </div>
</div>

<!-- 宠物：商店弹窗 -->
<div id="pet-shop-modal" class="modal-overlay">
    <div class="modal-header">
        <span>商店 (积分: <span id="shop-coins">0</span>)</span>
        <button class="close-btn" onclick="document.getElementById('pet-shop-modal').style.display='none'">×</button>
    </div>
    <div class="modal-body">
        <div class="receipt-tabs">
            <div class="r-tab active" onclick="switchShopTab('food')">食物</div>
            <div class="r-tab" onclick="switchShopTab('bath')">洗护</div>
            <div class="r-tab" onclick="switchShopTab('bg')">背景</div>
            <div class="r-tab" onclick="switchShopTab('decor')">装饰</div>
        </div>
        <div id="shop-grid" style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px; padding-top:15px;"></div>
    </div>
</div>

<!-- 宠物：背包弹窗 -->
<div id="pet-bag-modal" class="modal-overlay">
    <div class="modal-header">
        <span>背包 (积分: <span id="bag-coins">0</span>)</span>
        <button class="close-btn" onclick="document.getElementById('pet-bag-modal').style.display='none'">×</button>
    </div>
    <div class="modal-body">
        <div id="bag-grid" style="display:grid; grid-template-columns:repeat(4,1fr); gap:10px;"></div>
    </div>
</div>

<!-- 宠物：设置与状态 -->
<div id="pet-settings-modal" class="modal-overlay">
    <div class="modal-header">
        <span>宠物档案</span>
        <button class="close-btn" onclick="document.getElementById('pet-settings-modal').style.display='none'">×</button>
    </div>
    <div class="modal-body">
        <div class="morandi-card" style="text-align:center;">
            <div id="pet-info-display" style="font-size:1.5rem; font-weight:bold;"></div>
            <div class="pet-bars" style="margin-top:15px; text-align:left;">
                <label>饱食度: <span id="stat-hunger">0</span>%</label>
                <div class="g-bar-bg"><div id="bar-hunger" class="g-bar-fill" style="background:#ff9f43; width:0%"></div></div>
                
                <label>清洁度: <span id="stat-clean">0</span>%</label>
                <div class="g-bar-bg"><div id="bar-clean" class="g-bar-fill" style="background:#54a0ff; width:0%"></div></div>
                
                <label>心情值: <span id="stat-mood">0</span>%</label>
                <div class="g-bar-bg"><div id="bar-mood" class="g-bar-fill" style="background:#ff6b6b; width:0%"></div></div>
            </div>
        </div>
         <div class="morandi-card">
            <h3>任务与奖励(余额: <span id="setting-coin-display">0.00</span>)</h3>

            <button class="m-btn primary" id="btn-daily-checkin" onclick="petDailyCheckIn()" style="width:100%; margin-bottom:10px;">📅 每日签到 (+10积分)</button>
            <div style="font-size:0.8rem; color:#666; margin-bottom:10px;">💬 任务: 与角色对话30次 (+5积分) <span id="chat-task-progress">(0/30)</span></div>
            
            <div style="margin-top:20px; border-top:1px dashed #ccc; padding-top:10px;">
                <!-- 👇👇👇 这里是新增的转盘按钮 👇👇👇 -->
                <button class="m-btn primary" onclick="spinGamblingWheel()" style="width:100%; background:linear-gradient(45deg, #ff9a9e, #fad0c4); color:#d35400; border:none; box-shadow:0 4px 10px rgba(255, 107, 107, 0.3); margin-bottom:10px;">
                    🎰 赌狗大转盘 (0.25分/次)
                </button>
                

                <button class="m-btn small" onclick="openCheatInput()" style="background:#eee;">🛠️ 作弊通道</button>
                <div style="font-size:0.6rem; color:#999; margin-top:5px;">想要作弊可以dd作者</div>
            </div>
        </div>

      <!-- 这里的 onclick 改成了 openAdoptionModal()，这样点击时才会重新生成图片列表 -->
<button class="m-btn secondary" onclick="openAdoptionModal()" style="width:100%; background:#ffcccc; color:red;">重新领养 (重置数据)</button>
    </div>
</div>
<!-- 🐾 宠物日记独立 APP 界面 -->
<div id="pet-diary-app-modal" class="modal-overlay" style="background:#fff8e1;">
    <div class="modal-header" style="background:#ffecb3; color:#d35400;">
        <span>宠物陪伴日记</span>
        <button class="close-btn" onclick="document.getElementById('pet-diary-app-modal').style.display='none'">×</button>
    </div>
    <div class="modal-body">
        <div class="morandi-card" style="text-align:center; padding:20px; margin-bottom:15px; background:rgba(255,255,255,0.6);">
            <div style="font-size:3rem;">📖</div>
            <h3 style="color:#d35400; margin:10px 0;">我和它的故事</h3>
            <p style="font-size:0.8rem; color:#888;">这里记录了你们互动的每一个瞬间</p>
        </div>
        
        <!-- 故事列表容器 -->
        <div id="pet-diary-full-list" style="padding-bottom:50px;"></div>
    </div>
</div>
<!-- 😈 阴暗面：主界面 (历史记录) -->
<div id="shadow-app-modal" class="modal-overlay" style="background:#1e272e;">
    <div class="modal-header" style="background:#000; color:#d63031; border-bottom:1px solid #636e72;">
        <span style="font-family: 'Old English Text MT', serif; letter-spacing:1px;">Dark Side · 阴暗面</span>
        <button class="close-btn" onclick="document.getElementById('shadow-app-modal').style.display='none'" style="color:#d63031;">×</button>
    </div>
    <div class="modal-body" style="padding:20px;">
        <!-- 顶部操作卡片 -->
        <div class="morandi-card" style="background:rgba(0,0,0,0.6); border:1px solid #d63031; text-align:center; padding:30px; margin-bottom:20px;">
            <div style="font-size:3rem; margin-bottom:15px; filter: drop-shadow(0 0 5px red);">❤️</div>
            <h3 style="color:#d63031; margin-bottom:10px;">直视深渊</h3>
            <p style="font-size:0.8rem; color:#b2bec3;">抽取命运牌，强行揭开Ta内心最阴暗、<br>最病态、最不敢让你知道的角落。</p>
            <button class="m-btn primary" onclick="startShadowDraw()" style="margin-top:20px; background:#c0392b; color:#fff; border:none; box-shadow:0 0 15px rgba(192, 57, 43, 0.4);">
                🩸 开始潜入 (生成解析)
            </button>
        </div>

        <!-- 历史记录列表 -->
        <div style="color:#636e72; font-size:0.8rem; margin-bottom:10px; border-bottom:1px solid #636e72; padding-bottom:5px;">
            ARCHIVES (已存档的罪证)
        </div>
        <div id="shadow-history-list" style="padding-bottom:50px;"></div>
    </div>
</div>

<!-- 😈 阴暗面：专用抽牌桌 (独立复制，不干扰其他) -->
<div id="shadow-card-table-modal" class="modal-overlay" style="background: rgba(10, 10, 10, 0.98);">
    <div id="shadow-card-table-desk" style="width: 100%; height: 100%; position: relative; overflow-y: auto; overflow-x: hidden; padding-bottom: 100px; background: radial-gradient(circle, #2d3436 0%, #000 100%);">
        <div id="shadow-card-area" style="width: 100%; height: 100%; position: relative; transform-style: preserve-3d; perspective: 1000px;"></div>
        
        <div class="card-table-ui">
            <div style="color:#fab1a0; text-shadow:0 0 5px red; font-weight:bold; font-family:serif;">
                请翻开能够照亮黑暗的牌... (<span id="shadow-flipped-count">0</span>)
            </div>
            <button class="m-btn primary" onclick="finishShadowAnalysis()" style="background:#d63031; border:1px solid #ff7675; color:white;">
                💗确认并生成阴暗报告
            </button>
            <button class="m-btn secondary" onclick="document.getElementById('shadow-card-table-modal').style.display='none'" style="background:#2d3436; color:#ccc;">
                逃离
            </button>
        </div>
    </div>
</div>
<!-- === RPG 游戏主界面 === -->
<div id="rpg-app-modal" class="modal-overlay" style="background:#000;">
    <!-- 游戏区域 -->
    <div id="rpg-viewport" style="position:relative; width:100%; height:100%; overflow:hidden; display:flex; align-items:center; justify-content:center;">
        
        <!-- 在 id="rpg-app-modal" 内部找到 rpg-map-container -->
<div id="rpg-map-container" style="position:relative; width:100%; height:100%; max-width:600px; max-height:900px; overflow:hidden;">
    <!-- 1. 底层背景 (房间/外面) -->
    <img id="rpg-bg-layer" src="" style="position:absolute; top:0; left:0; width:100%; height:100%; object-fit:fill; z-index:0;">
    
    <!-- 2. 地板/碰撞图层 (现在是可见的！) -->
    <img id="rpg-floor-layer" src="" style="position:absolute; top:0; left:0; width:100%; height:100%; object-fit:fill; z-index:1; pointer-events:none;">

    <!-- 3. 逻辑碰撞层 (隐藏，用于 JS 读取像素) -->
    <canvas id="rpg-collision-canvas" style="display:none;"></canvas>

    <!-- 4. 装饰物层 -->
    <div id="rpg-decor-layer" style="position:absolute; top:0; left:0; width:100%; height:100%; z-index:5; pointer-events:none;"></div>

    <!-- 5. 角色层 -->
    <div id="rpg-char-npc" class="rpg-sprite" style="z-index:10;"></div>
    <div id="rpg-char-player" class="rpg-sprite" style="z-index:11;"></div>
</div>

        <!-- UI层：对话框 -->
        <div id="rpg-dialog-overlay" style="display:none; position:absolute; bottom:20px; left:10px; right:10px; background:rgba(0,0,0,0.9); border:2px solid #fff; border-radius:4px; padding:10px; z-index:100; color:#fff; font-family:'Courier New';">
            <div id="rpg-dialog-text">这里显示提示信息...</div>
            <div id="rpg-dialog-actions" style="margin-top:10px; display:flex; gap:10px; justify-content:flex-end;">
                <button class="m-btn small" id="rpg-btn-yes" style="background:#00b894; color:fff;">确定</button>
                <button class="m-btn small" onclick="closeRpgDialog()" style="background:#636e72; color:#ccc;">取消</button>
            </div>
        </div>

        <!-- UI层：虚拟摇杆 (简单的方向键) -->
        <div id="rpg-controls" style="position:absolute; bottom:30px; left:20px; z-index:90; display:grid; grid-template-columns:repeat(3, 40px); gap:5px;">
            <div></div><button class="rpg-dpad-btn" ontouchstart="startMove('up')" ontouchend="stopMove()" onmousedown="startMove('up')" onmouseup="stopMove()">▲</button><div></div>
            <button class="rpg-dpad-btn" ontouchstart="startMove('left')" ontouchend="stopMove()" onmousedown="startMove('left')" onmouseup="stopMove()">◀</button>
            <div style="width:40px;height:40px;background:#333;border-radius:50%;"></div>
            <button class="rpg-dpad-btn" ontouchstart="startMove('right')" ontouchend="stopMove()" onmousedown="startMove('right')" onmouseup="stopMove()">▶</button>
            <div></div><button class="rpg-dpad-btn" ontouchstart="startMove('down')" ontouchend="stopMove()" onmousedown="startMove('down')" onmouseup="stopMove()">▼</button><div></div>
        </div>

        <!-- 顶部功能栏 -->
        <div style="position:absolute; top:calc(var(--safe-top) + 10px); right:10px; z-index:90; display:flex; gap:10px;">
            <button class="m-btn small" onclick="toggleRpgHistory()" style="background:rgba(255,255,255,0.2); color:#fff;">📜 故事集</button>
            <button class="m-btn small" onclick="closeRpgApp()" style="background:rgba(255,0,0,0.5); color:#fff;">退出</button>
        </div>
    </div>

    <!-- 侧边栏：生成的故事历史 -->
    <div id="rpg-history-panel" class="chat-settings-panel">
        <h3>📖 生活片段</h3>
        <button class="m-btn small" onclick="toggleRpgHistory()" style="margin-bottom:10px; background:#e8d7d7;">关闭</button>
        <div id="rpg-history-list" style="display:flex; flex-direction:column; gap:10px;"></div>
    </div>
</div>
<div id="rpg-chat-modal" class="modal-overlay" style="display:none; background:#000;">
    <!-- 1. 背景容器 (解决白屏问题) -->
    <div id="rpg-chat-bg-container" style="position:absolute; top:0; left:0; width:100%; height:100%; opacity:0.6; filter: blur(2px);"></div>

    <!-- 2. 顶部标题 -->
    <div class="modal-header" style="background:rgba(0,0,0,0.6); color:#fff; position:relative; z-index:20;">
        <span>与 Ta 对话</span>
        <button class="close-btn" onclick="closeRpgChat()" style="color:#fff;">×</button>
    </div>
    
    <!-- 3. 立绘区域 (中间) -->
    <div style="flex:1; position:relative; display:flex; justify-content:center; align-items:center; z-index:20; overflow:hidden;">
        <!-- 对方立绘 (他说话时显示) -->
        <img id="rpg-chat-npc-img" src="" style="height:70%; max-height:400px; object-fit:contain; filter: drop-shadow(0 0 10px rgba(255,255,255,0.5)); display:none; transition: opacity 0.3s;">
        <!-- 我的立绘 (我输入时显示) -->
        <img id="rpg-chat-user-img" src="" style="height:70%; max-height:400px; object-fit:contain; filter: drop-shadow(0 0 10px rgba(255,255,255,0.5)); transition: opacity 0.3s;">
    </div>

    <!-- 4. 底部对话控制区 -->
    <div style="padding:20px; background:rgba(0,0,0,0.85); z-index:20; min-height:160px; border-top:2px solid #555; position:relative;">
        
        <!-- 找到 rpg-chat-modal 里的底部输入区域 (大约在 2750行附近)，完全替换为： -->
<div style="flex:1; display:flex; flex-direction:column; background:rgba(0,0,0,0.8); padding:15px; border-top:1px solid rgba(255,255,255,0.2);">
    
    <!-- 1. 输入模式 (平时显示这个) -->
    <div id="rpg-input-mode" style="display:block; width:100%; height:100%; display:flex; flex-direction:column;">
        <textarea id="rpg-chat-input" placeholder="输入对话... (点击右侧按钮抽牌)" style="flex:1; background:transparent; border:none; color:#fff; resize:none; font-size:1rem; outline:none;"></textarea>
        
        <div style="display:flex; justify-content:space-between; margin-top:10px;">
            <!-- 功能按钮 -->
            <div style="display:flex; gap:10px;">
                <button onclick="document.getElementById('file-input').click()" style="background:none; border:none; font-size:1.2rem;">📷</button>
                <button onclick="alert('语音功能开发中')" style="background:none; border:none; font-size:1.2rem;">🎤</button>
            </div>
            <!-- 抽牌按钮 -->
            <button onclick="openRpgCardTable()" style="background:linear-gradient(45deg, #9c27b0, #673ab7); border:none; color:#fff; padding:5px 15px; border-radius:20px; cursor:pointer;">🔮 命运抽牌</button>
        </div>
    </div>

    <!-- 2. 显示/打字机模式 (刚回复时显示这个，平时隐藏) -->
    <!-- 🔥 必须有这个 id="rpg-display-mode"，否则点击抽牌后无法切换界面 -->
    <div id="rpg-display-mode" style="display:none; width:100%; height:100%; overflow-y:auto; cursor:pointer;" onclick="resetRpgChatInput()">
        <div id="rpg-typewriter-text" style="font-family:'Songti SC', serif; color:#fff; font-size:1.1rem; line-height:1.6; white-space: pre-wrap;">
            <!-- JS 会把生成的回复填在这里 -->
        </div>
        <div style="text-align:center; font-size:0.8rem; color:rgba(255,255,255,0.5); margin-top:10px;">
            ( 点击任意处继续回复 )
        </div>
    </div>

</div>
    
    <!-- 5. 历史记录悬浮窗 -->
    <div id="rpg-chat-history-box" style="position:absolute; top:60px; right:10px; width:200px; max-height:200px; overflow-y:auto; background:rgba(255,255,255,0.9); border-radius:8px; padding:10px; display:none; z-index:30;">
        <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
            <span style="font-weight:bold; font-size:0.8rem;">对话记录</span>
            <span onclick="toggleRpgChatHistory()" style="cursor:pointer;">×</span>
        </div>
        <div id="rpg-chat-list"></div>
    </div>
    <button onclick="toggleRpgChatHistory()" style="position:absolute; top:60px; right:10px; background:rgba(255,255,255,0.5); border:none; border-radius:50%; width:30px; height:30px; z-index:30;">📝</button>
</div>

<!-- === RPG 专用牌桌 (复用逻辑，独立ID) === --><div id="rpg-card-table-modal" class="modal-overlay" style="background: rgba(10, 10, 20, 0.95); backdrop-filter: blur(5px); z-index: 3100;">
   <div id="rpg-card-table-desk" style="width:100%;height:100%;position:relative;overflow-y:auto;">
        <div id="rpg-card-area" style="width:100%;height:100%;perspective:1000px;"></div>
        <div class="card-table-ui">
            <div style="color:#fdcb6e;">命运判定中... (<span id="rpg-flipped-count">0</span>)</div>
           <!-- 必须长这样 -->
<button class="m-btn primary" onclick="finishRpgChat()" style="background:#e17055; border:1px solid #fab1a0; color:white;">🗣️ 确认并解读</button>
            <button class="m-btn secondary" onclick="document.getElementById('rpg-card-table-modal').style.display='none'">取消</button>
        </div>
    </div>
</div>
<!-- ================= 🔴 学习总结 APP 修复整合包 START 🔴 ================= -->

<!-- 1. 界面部分 (HTML) -->
<div id="summary-app-modal" class="modal-overlay" style="background:#f1f2f6; z-index:9999; display:none;">
    <div class="modal-header" style="background:#fff; color:#2c3e50; border-bottom:1px solid #dfe6e9; padding-top: max(20px, env(safe-area-inset-top)); height:auto; min-height:80px; display:flex; align-items:flex-end;">
        <span style="font-weight:bold; font-size:1.1rem; margin-left:15px; margin-bottom:10px;">📝 学习总结</span>
        <button class="close-btn" onclick="document.getElementById('summary-app-modal').style.display='none'" style="margin-bottom:5px; font-size:2rem; color:#333;">×</button>
    </div>

    <div class="modal-body" style="padding:15px; padding-bottom:100px; overflow-y:auto;">
        <!-- 顶部切换按钮 -->
        <div style="display:flex; background:#fff; padding:10px; margin-bottom:15px; border-radius:12px; gap:10px; box-shadow:0 2px 5px rgba(0,0,0,0.05);">
            <button class="m-btn small" onclick="switchSummaryView('create')" id="btn-sum-create" style="flex:1; background:#607d8b; color:white; padding:10px;">✨ 新建</button>
            <button class="m-btn small" onclick="switchSummaryView('history')" id="btn-sum-history" style="flex:1; background:#eceff1; color:#333; padding:10px;">📂 历史</button>
        </div>

        <!-- A. 新建页面 -->
        <div id="summary-create-view">
            <div class="morandi-card" style="padding:20px;">
                <div class="input-group">
                    <label style="font-weight:bold; color:#546e7a;">📚 科目 / 领域</label>
                    <input type="text" id="sum-subject" placeholder="例如：高等数学、Python编程..." style="background:#f9f9f9;">
                </div>
                <div class="input-group" style="margin-top:15px;">
                    <label style="font-weight:bold; color:#546e7a;">✍️ 学习笔记 / 困惑点</label>
                    <textarea id="sum-notes" class="editor-textarea" style="height:120px; background:#f9f9f9; padding:10px;" placeholder="在此粘贴你的笔记，或写下你学到的内容..."></textarea>
                </div>
                <div class="input-group" style="margin-top:15px;">
                    <label style="display:flex; align-items:center; color:#78909c; font-size:0.85rem;">
                        <input type="checkbox" id="sum-use-wb" checked style="width:auto; margin-right:5px; transform:scale(1.2);"> 
                        <span>引用世界书人设 (让角色来辅导你)</span>
                    </label>
                </div>
                <button class="m-btn primary" onclick="generateSummary()" id="btn-sum-gen" style="background:#607d8b; width:100%; margin-top:20px; height:50px; font-size:1rem; box-shadow:0 4px 10px rgba(96, 125, 139, 0.3);">🧠 开始分析总结</button>
            </div>
            
            <!-- 结果展示区 -->
            <div id="summary-result-area" style="display:none; margin-top:20px; animation: fadeIn 0.5s;">
                <div class="morandi-card" style="border-left: 5px solid #f39c12; padding:15px; margin-bottom:10px;">
                    <h4 style="margin:0 0 10px 0; color:#d35400;">❓ 发现的问题 & 盲点</h4>
                    <div id="res-questions" style="font-size:0.95rem; line-height:1.6; color:#333;"></div>
                </div>
                <div class="morandi-card" style="border-left: 5px solid #3498db; padding:15px; margin-bottom:10px;">
                    <h4 style="margin:0 0 10px 0; color:#2980b9;">🌍 知识点扩展</h4>
                    <div id="res-expansion" style="font-size:0.95rem; line-height:1.6; color:#333;"></div>
                </div>
                <div class="morandi-card" style="border-left: 5px solid #27ae60; padding:15px; margin-bottom:10px;">
                    <h4 style="margin:0 0 10px 0; color:#27ae60;">📅 下一步计划 & 推荐</h4>
                    <div id="res-plan" style="font-size:0.95rem; line-height:1.6; color:#333;"></div>
                </div>
                <button class="m-btn small" onclick="saveSummaryResult()" style="width:100%; margin-top:15px; background:#bdc3c7; color:#333; height:45px;">💾 确认保存到历史</button>
            </div>
        </div>

        <!-- B. 历史页面 -->
        <div id="summary-history-view" style="display:none;">
            <div id="summary-history-list" style="padding-bottom:50px;"></div>
        </div>
    </div>
</div>

<!-- 2. 逻辑脚本 (JS) -->
<script>
(function() {
    // 立即执行函数，防止变量污染
    console.log("正在初始化学习总结 APP...");

    // 1. 强制初始化数据结构 (防止 undefined)
    if (!window.BIG_MEMORY) window.BIG_MEMORY = {};
    if (!window.BIG_MEMORY.summary_data) window.BIG_MEMORY.summary_data = [];

    // 2. 挂载全局函数 (确保 onclick 能找到)
    window.getSummaryData = function() { return window.BIG_MEMORY.summary_data || []; };
    
    window.saveSummaryData = function(list) {
        window.BIG_MEMORY.summary_data = list;
        if (typeof idb !== 'undefined' && idb.put) {
            idb.put('universal_store', { id: 'summary_data', data: list });
        }
    };

    window.openSummaryApp = function() {
        const modal = document.getElementById('summary-app-modal');
        if(modal) {
            modal.style.display = 'flex';
            switchSummaryView('create');
        } else {
            alert("错误：找不到界面元素！请检查代码粘贴位置。");
        }
    };

    window.switchSummaryView = function(mode) {
        const createEl = document.getElementById('summary-create-view');
        const histEl = document.getElementById('summary-history-view');
        const btnCreate = document.getElementById('btn-sum-create');
        const btnHist = document.getElementById('btn-sum-history');

        if (mode === 'create') {
            createEl.style.display = 'block';
            histEl.style.display = 'none';
            btnCreate.style.background = '#607d8b'; btnCreate.style.color = '#fff';
            btnHist.style.background = '#eceff1'; btnHist.style.color = '#333';
        } else {
            createEl.style.display = 'none';
            histEl.style.display = 'block';
            btnCreate.style.background = '#eceff1'; btnCreate.style.color = '#333';
            btnHist.style.background = '#607d8b'; btnHist.style.color = '#fff';
            renderSummaryHistory();
        }
    };

    let pendingSummary = null;

    window.generateSummary = async function() {
        const subject = document.getElementById('sum-subject').value;
        const notes = document.getElementById('sum-notes').value;
        if (!subject || !notes) return alert("请填写内容！");

        const btn = document.getElementById('btn-sum-gen');
        const oldText = btn.innerText;
        btn.disabled = true; btn.innerText = "🧠 正在连接大脑...";

        // 强力获取 API Key
        let apiKey = "";
        try { apiKey = document.getElementById('api-key').value; } catch(e){}
        if(!apiKey) {
            try { const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}'); apiKey=s.key; } catch(e){}
        }
        if(!apiKey) { 
            alert("请先在桌面【设置】中配置 API Key！");
            btn.disabled = false; btn.innerText = oldText;
            return;
        }

        let apiUrl = document.getElementById('api-url')?.value || "https://api.openai.com/v1";
        if(apiUrl.endsWith('/')) apiUrl = apiUrl.slice(0,-1);
        let model = document.getElementById('model-select')?.value || "gpt-3.5-turbo";

        // 获取世界书上下文
        const wb = window.BIG_MEMORY.world_book || {};
        const globalCtx = document.getElementById('sum-use-wb').checked 
            ? (wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n") 
            : "";

        const prompt = `
你是一位专业的学习导师，同时你需要**严格扮演世界书中的角色**。
【世界观/角色】：${globalCtx}

【用户输入】
科目：${subject}
笔记内容：${notes}

【任务】
请以角色的口吻，对用户的笔记进行深度分析总结。
**必须严格输出 JSON 格式**，不要 Markdown 代码块。

【JSON 结构】
{
  "questions": "指出笔记中逻辑不通、遗漏的关键点，或者针对笔记内容提出 2-3 个启发性问题。",
  "expansion": "根据笔记内容，扩展延伸相关的知识点、背景或高级用法（角色视角的见解）。",
  "plan": "推荐下一步的学习目标、具体的教材名称、教程链接关键词（必须真实存在）。"
}
`;

        try {
            const res = await fetch(`${apiUrl}/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    messages: [{role:"system", content:"You are a helpful tutor. Output JSON only."}, {role:"user", content:prompt}],
                    temperature: 0.7
                })
            });

            const json = await res.json();
            if(json.error) throw new Error(json.error.message);
            
            let raw = json.choices[0].message.content.replace(/```json/g,"").replace(/```/g,"").trim();
            // 简单容错
            const first = raw.indexOf('{'); const last = raw.lastIndexOf('}');
            if(first !== -1 && last !== -1) raw = raw.substring(first, last+1);
            
            const result = JSON.parse(raw);

            document.getElementById('res-questions').innerText = result.questions;
            document.getElementById('res-expansion').innerText = result.expansion;
            document.getElementById('res-plan').innerText = result.plan;
            document.getElementById('summary-result-area').style.display = 'block';
            
            pendingSummary = {
                id: Date.now(),
                date: new Date().toLocaleString(),
                subject: subject,
                notes: notes,
                result: result
            };

        } catch(e) {
            console.error(e);
            alert("生成失败: " + e.message);
        } finally {
            btn.innerText = oldText; btn.disabled = false;
        }
    };

    window.saveSummaryResult = function() {
        if (!pendingSummary) return;
        const list = getSummaryData();
        list.unshift(pendingSummary);
        saveSummaryData(list);
        alert("✅ 已保存到历史记录！");
        document.getElementById('summary-result-area').style.display = 'none';
        document.getElementById('sum-notes').value = '';
        switchSummaryView('history');
    };

    window.renderSummaryHistory = function() {
        const list = getSummaryData();
        const container = document.getElementById('summary-history-list');
        container.innerHTML = '';
        
        if (list.length === 0) {
            container.innerHTML = '<div style="text-align:center; color:#999; padding:30px;">暂无记录</div>';
            return;
        }

        list.forEach((item, index) => {
            const div = document.createElement('div');
            div.className = 'morandi-card';
            div.style.marginBottom = '15px'; 
            div.style.padding = '15px';
            div.style.background = '#fff';
            
            div.innerHTML = `
                <div style="display:flex; justify-content:space-between; border-bottom:1px solid #eee; padding-bottom:8px; margin-bottom:10px;">
                    <span style="font-weight:bold; color:#607d8b; font-size:1rem;">📘 ${item.subject}</span>
                    <span style="font-size:0.8rem; color:#999;">${item.date}</span>
                </div>
                
                <div style="font-size:0.85rem; background:#f5f5f5; padding:8px; border-radius:6px; margin-bottom:12px; color:#555;">
                    📝 <strong>笔记:</strong> ${item.notes.substring(0, 50)}...
                </div>

                <div style="font-size:0.9rem; line-height:1.6; color:#333;">
                    <div style="margin-bottom:8px;"><strong style="color:#d35400;">❓ 问题:</strong> ${item.result.questions}</div>
                    <div style="margin-bottom:8px;"><strong style="color:#2980b9;">🌍 扩展:</strong> ${item.result.expansion}</div>
                    <div><strong style="color:#27ae60;">📅 计划:</strong> ${item.result.plan}</div>
                </div>

                <div style="text-align:right; margin-top:10px;">
                    <button class="m-btn small" onclick="deleteSummaryItem(${index})" style="background:#ffcdd2; color:#c0392b; font-size:0.8rem; padding:5px 12px;">🗑️ 删除</button>
                </div>
            `;
            container.appendChild(div);
        });
    };

    window.deleteSummaryItem = function(index) {
        if (!confirm("确定删除这条记录？")) return;
        const list = getSummaryData();
        list.splice(index, 1);
        saveSummaryData(list);
        renderSummaryHistory();
    };

    // 3. 【关键补丁】劫持加载函数，确保数据被读取
    const originalLoad = window.loadAllBigData;
    window.loadAllBigData = async function() {
        if(originalLoad) await originalLoad();
        
        // 尝试单独读取
        try {
            if(typeof idb !== 'undefined') {
                const res = await idb.get('universal_store', 'summary_data');
                if(res) window.BIG_MEMORY.summary_data = res.data;
            }
        } catch(e) {}
        console.log("学习总结数据补丁已加载");
    };

    // 4. 【关键补丁】注册美化映射 (延迟执行，确保 APP_MAP 存在)
    setTimeout(() => {
        if(typeof APP_MAP !== 'undefined') {
            const exists = APP_MAP.find(a => a.id === 'summary');
            if(!exists) {
                APP_MAP.push({ 
                    id: 'summary', 
                    name: '学习总结', 
                    selector: 'div[onclick="openSummaryApp()"]' 
                });
            }
        }
    }, 2000);

})();
</script>
<!-- ================= 🔴 学习总结 APP 修复整合包 END 🔴 ================= -->
<script>
// ==================== RPG 像素生活系统 (最终增强版) ====================

// --- 1. 基础配置 ---
const RPG_ASSETS = {
    bg_room: "https://i.postimg.cc/4xNTKjLp/IMG_0470.png",      
    bg_outside: "https://i.postimg.cc/bwCf1L4q/IMG_0496.png",   
    // 地板/碰撞图 (既是背景的一部分，也是碰撞依据)
    collision_map: "https://i.postimg.cc/SKH0vRS0/IMG_0488.png",
    
    // 默认 GIF
    char_gifs: {
        idle: "https://i.postimg.cc/N0ZhzFgm/IMG_0486.gif",  
        right: "https://i.postimg.cc/LsGdb5Ht/IMG_0482.gif", 
        front: "https://i.postimg.cc/LsGdb5HB/IMG_0487.gif", 
        back: "https://i.postimg.cc/bv4XBrz9/IMG_0483.gif"   
    },
    
    // 物品配置 (Scene 区分房间和外面)
    items: [
        // === 🏠 房间 (Room) ===
        { id: 'bed', scene: 'room', name: '床', src: 'https://i.postimg.cc/tCzj495W/IMG_0490.png', x: 5, y: 54, w: 25, prompt: '要睡觉吗？' },
        { id: 'tv', scene: 'room', name: '电视', src: 'https://i.postimg.cc/XY70ZtHp/IMG_0492.png', x: 18, y: 10, w: 25, prompt: '要看电视吗？' },
        { id: 'kitchen', scene: 'room', name: '厨房', src: 'https://i.postimg.cc/3xJHyzSC/IMG_0493.png', x: 60, y: 4, w: 38, prompt: '要做饭吗？' },
        { id: 'catbed', scene: 'room', name: '猫窝', src: 'https://i.postimg.cc/QdxrBv4K/IMG_0494.png', x: 70, y: 50, w: 25, prompt: '要和宠物玩吗？' },
        { id: 'tub', scene: 'room', name: '浴缸', src: 'https://i.postimg.cc/135ZgbCp/IMG_0495.png', x: 65, y: 70, w: 30, prompt: '要洗澡吗？' },
        // 传送：地毯 -> 外面
        { id: 'carpet', scene: 'room', name: '地毯', src: 'https://i.postimg.cc/YCqw4Tn9/IMG_0491.png', x: 40, y: 85, w: 20, prompt: '要到外面去吗？', action: 'go_out' },

        // === 🌳 外面 (Outside) ===
        // 传送：门 -> 房间
        { id: 'door', scene: 'outside', name: '门', src: 'https://i.postimg.cc/BnYf2NkR/IMG_0501.png', x: 40, y: 0, w: 20, prompt: '要回房间吗？', action: 'go_in' },
       
        // 装饰灯
        { id: 'l1', scene: 'outside', src: 'https://i.postimg.cc/02Csy9fN/IMG_0503.png', x: 5, y: 10, w: 15, collision: true },
        { id: 'l2', scene: 'outside', src: 'https://i.postimg.cc/TYc63T9K/IMG_0504.png', x: 20, y: 10, w: 19, collision: true },
        { id: 'l3', scene: 'outside', src: 'https://i.postimg.cc/6Q8JcnNw/IMG_0505.png', x: 80, y: 15, w: 13, collision: true },
        { id: 'l4', scene: 'outside', src: 'https://i.postimg.cc/65hXpB02/IMG_0506.png', x: 60, y: 10, w: 19, collision: true },
        { id: 'l5', scene: 'outside', src: 'https://i.postimg.cc/SKnFdCps/IMG_0507.png', x: 80, y: 38, w: 8, collision: true },
        { id: 'l6', scene: 'outside', src: 'https://i.postimg.cc/9fD5bZjy/IMG_0518.png', x: 10, y: 36, w:10, collision: true },

        // NPC 们
        { id: 'n1', scene: 'outside', type: 'person', name: '朋友A', src: 'https://i.postimg.cc/cL9GfT2m/IMG_0509.png', x: 28, y: 17, w: 15, prompt: '祝你婚后幸福' },
        { id: 'n2', scene: 'outside', type: 'person', name: '朋友B', src: 'https://i.postimg.cc/fbVnCmhk/IMG_0510.png', x: 20, y: 40, w: 22, prompt: '天天开心哦' },
        { id: 'n3', scene: 'outside', type: 'person', name: '朋友C', src: 'https://i.postimg.cc/4xLRpwjN/IMG_0511.png', x: 7, y: 33, w: 20, prompt: '今天过得怎么样呀' },
        { id: 'n4', scene: 'outside', type: 'person', name: '朋友D', src: 'https://i.postimg.cc/SxTbcVHK/IMG_0512.png', x: 65, y: 19, w: 20, prompt: '要不要一起出去玩？' },
        { id: 'n5', scene: 'outside', type: 'person', name: '朋友E', src: 'https://i.postimg.cc/vHvsZGz6/IMG_0513.png', x: 70, y: 33, w: 18, prompt: '菜很好吃谢谢款待' },
        { id: 'n6', scene: 'outside', type: 'person', name: '朋友F', src: 'https://i.postimg.cc/bvZcgkjq/IMG_0514.png', x: 25, y: 29, w: 15, prompt: '祝福你们' },
        { id: 'n7', scene: 'outside', type: 'person', name: '朋友G', src: 'https://i.postimg.cc/JhsVxZWy/IMG_0515.png', x: 52, y: 40, w: 23.5, prompt: '你们真般配' },
        { id: 'n9', scene: 'outside', type: 'person', name: '朋友I', src: 'https://i.postimg.cc/1z8hBwZN/IMG_0516.png', x: 55, y: 28, w: 19, prompt: '你们是怎么在一起的呀？' },
        { id: 'n10', scene: 'outside', type: 'person', name: '朋友J', src: 'https://i.postimg.cc/8C7Q4MVJ/IMG_0517.png', x: 13, y: 22, w: 20, prompt: '你们谁先喜欢谁的呀？' }
    ]
};

// --- 2. 状态与皮肤 ---
let rpgState = {
    player: { x: 50, y: 80, dir: 'front' }, 
    npc: { x: 50, y: 50, dir: 'idle', moveTimer: null },
    currentScene: 'room',
    isMoving: false,
    moveDir: null,
    moveInterval: null,
    collisionCtx: null, 
    mapW: 0, mapH: 0
};

// 全局皮肤缓存 (美化用)
let RPG_SKINS = {
    user_idle: null,
    user_front: null,
    user_back: null,
    user_right: null,
    user_left: null,
    npc_idle: null,
    // --- 新增 NPC 行走皮肤 ---
    npc_front: null,
    npc_back: null,
    npc_right: null
};

// 更新加载函数
async function loadRpgSkins() {
    try {
        const keys = ['rpg_user_idle', 'rpg_user_front', 'rpg_user_back', 'rpg_user_right', 'rpg_user_left', 'rpg_npc_idle'];
        for (let key of keys) {
            const res = await idb.get('settings_heavy', key);
            if (res) {
                // 去掉 'rpg_' 前缀作为键名
                const skinKey = key.replace('rpg_', '');
                RPG_SKINS[skinKey] = res.data;
            }
        }
    } catch(e) { console.log("皮肤加载略过"); }
}

// --- 3. 初始化 ---
function openRpgApp() {
    document.getElementById('rpg-app-modal').style.display = 'flex';
    // 加载美化资源
    loadRpgSkins().then(() => {
        initRpgGame();
        renderRpgHistory();
    });
}

function closeRpgApp() {
    document.getElementById('rpg-app-modal').style.display = 'none';
    stopMove();
    if(rpgState.npc.moveTimer) clearInterval(rpgState.npc.moveTimer);
}

function initRpgGame() {
    const container = document.getElementById('rpg-map-container');
    rpgState.mapW = container.clientWidth;
    rpgState.mapH = container.clientHeight;

    switchScene('room');

    // 初始化碰撞 Canvas
    const canvas = document.getElementById('rpg-collision-canvas');
    canvas.width = rpgState.mapW;
    canvas.height = rpgState.mapH;
    rpgState.collisionCtx = canvas.getContext('2d', { willReadFrequently: true });
    
    // 加载碰撞图数据
    const colImg = new Image();
    colImg.crossOrigin = "Anonymous";
    colImg.src = RPG_ASSETS.collision_map;
    colImg.onload = () => {
        rpgState.collisionCtx.drawImage(colImg, 0, 0, rpgState.mapW, rpgState.mapH);
    };

    updateSpritePosition('player');
    updateSpritePosition('npc');
    startNpcAI();
}
async function loadRpgSkins() {
    try {
        // 定义所有需要加载的 key (注意：数据库里的 key 是带 rpg_ 前缀的)
        const keys = [
            'rpg_user_idle', 'rpg_user_front', 'rpg_user_back', 'rpg_user_right', 'rpg_user_left', 
            'rpg_npc_idle',
            // --- 新增 NPC Key ---
            'rpg_npc_front', 'rpg_npc_back', 'rpg_npc_right'
        ];
        
        for (let key of keys) {
            const res = await idb.get('settings_heavy', key);
            if (res) {
                // 去掉 'rpg_' 前缀作为内存对象的键名
                const skinKey = key.replace('rpg_', '');
                RPG_SKINS[skinKey] = res.data;
            }
        }
    } catch(e) { console.log("皮肤加载略过"); }
}

// 场景切换
function switchScene(sceneName) {
    rpgState.currentScene = sceneName;
    const bgImg = document.getElementById('rpg-bg-layer');
    const floorImg = document.getElementById('rpg-floor-layer');
    
    if(sceneName === 'room') {
        bgImg.src = RPG_ASSETS.bg_room;
        floorImg.src = RPG_ASSETS.collision_map;
        floorImg.style.display = 'block'; // 房间内显示地板图
    } else {
        bgImg.src = RPG_ASSETS.bg_outside;
        floorImg.style.display = 'none'; // 外面不显示地板图
    }
    
    renderDecorations();
    
    // 重置位置
    rpgState.player.x = 50; rpgState.player.y = 80;
    rpgState.npc.x = 50; rpgState.npc.y = 70;
    updateSpritePosition('player');
    updateSpritePosition('npc');
}

// 渲染装饰物
function renderDecorations() {
    const layer = document.getElementById('rpg-decor-layer');
    layer.innerHTML = '';
    
    RPG_ASSETS.items.forEach(item => {
        if (item.scene !== rpgState.currentScene) return;

        const img = document.createElement('img');
        img.src = item.src;
        img.className = 'rpg-decor'; // CSS class handled styling
        img.style.position = 'absolute';
        img.style.left = item.x + '%';
        img.style.top = item.y + '%';
        img.style.width = item.w + '%';
        img.style.zIndex = Math.floor(item.y); // 简单遮挡关系
        
        if(item.type === 'person') {
             img.style.pointerEvents = 'auto';
             img.style.cursor = 'pointer';
             img.onclick = (e) => { e.stopPropagation(); openRpgChatMode(); };
        } else {
             img.style.pointerEvents = 'none';
        }
        layer.appendChild(img);
    });
}
function startMove(dir) {
    if (rpgState.isMoving) return;
    rpgState.isMoving = true;
    rpgState.moveDir = dir;
    
    const pDiv = document.getElementById('rpg-char-player');
    let src = "";
    
    // 重置 transform，避免翻转干扰
    pDiv.style.transform = 'none';

    if(dir === 'right') {
        // 如果有自定义右图用右图，没有则用默认 GIF
        src = RPG_SKINS.user_right || RPG_ASSETS.char_gifs.right;
        // 如果没有自定义右图(用的是默认)，可能需要处理翻转(视素材而定，这里假设默认素材向右)
    } 
    else if (dir === 'left') {
        // 如果有自定义左图，直接用
        if (RPG_SKINS.user_left) {
            src = RPG_SKINS.user_left;
        } else {
            // 没有自定义左图，借用右图并翻转
            src = RPG_SKINS.user_right || RPG_ASSETS.char_gifs.right;
            pDiv.style.transform = 'scaleX(-1)';
        }
    } 
    else if (dir === 'up') {
        src = RPG_SKINS.user_back || RPG_ASSETS.char_gifs.back;
    } 
    else if (dir === 'down') {
        src = RPG_SKINS.user_front || RPG_ASSETS.char_gifs.front;
    }
    
    pDiv.style.backgroundImage = `url(${src})`;
    rpgState.moveInterval = setInterval(gameLoop, 30);
}

// 同时也修正 stopMove 恢复待机图
function stopMove() {
    rpgState.isMoving = false;
    clearInterval(rpgState.moveInterval);
    const pDiv = document.getElementById('rpg-char-player');
    // 恢复待机图
    const src = RPG_SKINS.user_idle || RPG_ASSETS.char_gifs.idle;
    pDiv.style.backgroundImage = `url(${src})`;
    pDiv.style.transform = 'none';
}

function gameLoop() {
    let nextX = rpgState.player.x;
    let nextY = rpgState.player.y;
    const speed = 1.5;

    if(rpgState.moveDir === 'up') nextY -= speed;
    if(rpgState.moveDir === 'down') nextY += speed;
    if(rpgState.moveDir === 'left') nextX -= speed;
    if(rpgState.moveDir === 'right') nextX += speed;

    if(nextX < 0) nextX = 0; if(nextX > 90) nextX = 90;
    if(nextY < 0) nextY = 0; if(nextY > 90) nextY = 90;

    if (checkCollision(nextX, nextY)) return; 

    rpgState.player.x = nextX;
    rpgState.player.y = nextY;
    updateSpritePosition('player');
    checkInteraction();
}
function updateSpritePosition(role) {
    const el = document.getElementById(role === 'player' ? 'rpg-char-player' : 'rpg-char-npc');
    const data = role === 'player' ? rpgState.player : rpgState.npc;
    
    // 重置变换，防止翻转状态残留
    el.style.transform = 'none';

    // === 玩家逻辑 (保持不变) ===
    if (role === 'player') {
        if(!rpgState.isMoving) {
            let src = RPG_SKINS.user_idle || RPG_ASSETS.char_gifs.idle;
            el.style.backgroundImage = `url(${src})`;
        }
        // (玩家移动时的图由 gameLoop 控制，这里主要负责坐标和静止态)
    } 
    
    // === NPC 逻辑 (新增自定义行走) ===
    else if (role === 'npc') {
        let src = RPG_SKINS.npc_idle || RPG_ASSETS.char_gifs.idle; // 默认待机图
        const dir = data.dir; // 从 startNpcAI 获取方向

        if (dir === 'down') {
            // 向前走 (Front)
            src = RPG_SKINS.npc_front || RPG_ASSETS.char_gifs.front || src;
        } 
        else if (dir === 'up') {
            // 向后走 (Back)
            src = RPG_SKINS.npc_back || RPG_ASSETS.char_gifs.back || src;
        } 
        else if (dir === 'right') {
            // 向右走
            src = RPG_SKINS.npc_right || RPG_ASSETS.char_gifs.right || src;
        } 
        else if (dir === 'left') {
            // 向左走：使用向右的图 + 镜像翻转
            src = RPG_SKINS.npc_right || RPG_ASSETS.char_gifs.right || src;
            el.style.transform = 'scaleX(-1)'; // 👈 核心：镜像反转
        }
        // 如果 dir === 'idle'，保持默认 src

        el.style.backgroundImage = `url(${src})`;
        
        // 确保 NPC 可交互
        el.style.cursor = 'pointer';
        el.style.pointerEvents = 'auto';
        el.onclick = () => openRpgChatMode();
    }
    
    // 更新坐标
    el.style.left = data.x + '%';
    el.style.top = data.y + '%';
}
function checkCollision(xPercent, yPercent) {
    // 1. 房间内透明度检测 (地板图非透明区域不能走 -> 假设非透明是墙)
    // 实际上通常透明是地板。如果你的图透明是地板，那么 pixel[3] == 0 才是可行走。
    // 这里假设：IMG_0488.png 透明部分是可以走的，有颜色部分是家具/墙。
    if (rpgState.currentScene === 'room') {
        const px = Math.floor((xPercent / 100) * rpgState.mapW);
        const py = Math.floor((yPercent / 100) * rpgState.mapH) + 60; 
        try {
            const pixel = rpgState.collisionCtx.getImageData(px, py, 1, 1).data;
            if (pixel[3] > 100) return true; // 有颜色 = 撞墙
        } catch(e) {}
    }

    // 2. 物品碰撞
    for (let item of RPG_ASSETS.items) {
        if (item.scene !== rpgState.currentScene) continue;
        if (item.collision) {
            // 简单的矩形检测
            if (xPercent > item.x && xPercent < item.x + item.w &&
                yPercent > item.y && yPercent < item.y + (item.w)) {
                return true;
            }
        }
    }
    return false;
}

function checkInteraction() {
    let nearItem = null;
    const px = rpgState.player.x;
    const py = rpgState.player.y;

    for (let item of RPG_ASSETS.items) {
        if (item.scene !== rpgState.currentScene) continue;
        const dist = Math.hypot(px - (item.x + item.w/2), py - (item.y + item.w/2));
        if (dist < 10) { nearItem = item; break; }
    }

    const dialog = document.getElementById('rpg-dialog-overlay');
    if (nearItem && nearItem.prompt) {
        dialog.style.display = 'block';
        document.getElementById('rpg-dialog-text').innerText = nearItem.prompt;
        document.getElementById('rpg-btn-yes').onclick = () => {
            if(nearItem.action === 'go_out') {
                switchScene('outside'); closeRpgDialog();
            } else if (nearItem.action === 'go_in') {
                switchScene('room'); closeRpgDialog();
            } else {
                generateRpgStory(nearItem); closeRpgDialog();
            }
        };
    } else {
        dialog.style.display = 'none';
    }
}

function closeRpgDialog() { document.getElementById('rpg-dialog-overlay').style.display = 'none'; }

// --- 5. 聊天模式 (背景显示修复) ---
function openRpgChatMode() {
    document.getElementById('rpg-chat-modal').style.display = 'flex';
    
    // 1. 设置背景容器 (解决白屏问题)
    const bgContainer = document.getElementById('rpg-chat-bg-container');
    const bgSrc = rpgState.currentScene === 'room' ? RPG_ASSETS.bg_room : RPG_ASSETS.bg_outside;
    bgContainer.style.backgroundImage = `url(${bgSrc})`;
    bgContainer.style.backgroundSize = 'cover';
    bgContainer.style.backgroundPosition = 'center';
    
    // 2. 将当前场景的家具复制进背景容器，实现"看到装饰"
    bgContainer.innerHTML = ''; // 清空旧的
    // 复制地板层 (如果在房间)
    if(rpgState.currentScene === 'room') {
        const floor = document.createElement('img');
        floor.src = RPG_ASSETS.collision_map;
        floor.style.cssText = "position:absolute; top:0; left:0; width:100%; height:100%; object-fit:fill;";
        bgContainer.appendChild(floor);
    }
    // 复制装饰物
    const originalDecor = document.getElementById('rpg-decor-layer');
    // 克隆节点
    const cloneDecor = originalDecor.cloneNode(true);
    bgContainer.appendChild(cloneDecor);

    // 3. 设置立绘
    const npcImg = document.getElementById('rpg-chat-npc-img');
    const userImg = document.getElementById('rpg-chat-user-img');
    npcImg.src = RPG_SKINS.npc_idle || RPG_ASSETS.char_gifs.idle;
    userImg.src = RPG_SKINS.user_idle || RPG_ASSETS.char_gifs.idle;

    renderRpgChatList();
}

function closeRpgChat() {
    document.getElementById('rpg-chat-modal').style.display = 'none';
}
// 修改 NPC AI：移动时判断方向并更新状态
function startNpcAI() {
    if(rpgState.npc.moveTimer) clearInterval(rpgState.npc.moveTimer);
    rpgState.npc.moveTimer = setInterval(() => {
        if(Math.random() < 0.4) { // 提高一点动弹的频率
            let nx = rpgState.npc.x, ny = rpgState.npc.y;
            let dir = 'idle'; // 默认状态
            
            const r = Math.random();
            // 根据随机数决定方向
            if(r < 0.25) { 
                nx -= 5; dir = 'left'; 
            } else if(r < 0.5) { 
                nx += 5; dir = 'right'; 
            } else if(r < 0.75) { 
                ny -= 5; dir = 'up';   // 也就是背影
            } else { 
                ny += 5; dir = 'down'; // 也就是正面
            }

            // 边界检查
            if(nx > 0 && nx < 90 && ny > 0 && ny < 90) {
                rpgState.npc.x = nx; 
                rpgState.npc.y = ny;
                rpgState.npc.dir = dir; // 记录当前方向
                updateSpritePosition('npc'); // 更新画面
            }
        } else {
            // 有概率停下来发呆
            rpgState.npc.dir = 'idle';
            updateSpritePosition('npc');
        }
    }, 2000);
}

// 确保在美化界面应用设置时更新 RPG 皮肤
if(typeof applyAllThemeSettings === 'function') {
    const _oldApply = applyAllThemeSettings;
    applyAllThemeSettings = async function() {
        await _oldApply();
        await loadRpgSkins(); // 重新加载皮肤
    }
}
// ==================== RPG 像素生活系统 (修复整合版) ====================

// --- 变量定义 (独立于 Page 2 游戏机) ---
let rpgActiveDeck = [];
let rpgFlippedCards = [];

// 1. 启动 RPG 专用抽牌 (对应点击 "🎲 抽牌并对话")
// 1. 启动 RPG 专用抽牌 (对应点击 "🎲 抽牌并对话")
window.openRpgCardTable = function() {
    const inputVal = document.getElementById('rpg-chat-input').value.trim();
    if(!inputVal) return alert("请先在输入框对 Ta 说点什么...");

    const modal = document.getElementById('rpg-card-table-modal');
    const area = document.getElementById('rpg-card-area');
    const desk = document.getElementById('rpg-card-table-desk');

    // 应用美化 (复用塔罗桌布)
    if(typeof idb !== 'undefined') {
        idb.get('settings_heavy', 'tarot_table').then(res => {
            if(res && res.data) {
                desk.style.backgroundImage = `url(${res.data})`;
                desk.style.backgroundSize = 'cover';
            }
        });
    }

    area.innerHTML = ''; 
    rpgActiveDeck = [];
    rpgFlippedCards = [];
    document.getElementById('rpg-flipped-count').innerText = '0';

    // 生成完整牌库 (0-77 塔罗 + 1-36 雷诺曼)
    for(let i=0; i<=77; i++) rpgActiveDeck.push({ type: 'tarot', id: i, isReversed: Math.random() < 0.3 }); 
    for(let i=1; i<=36; i++) rpgActiveDeck.push({ type: 'lenormand', id: i, isReversed: false }); 
    
    // 洗牌
    rpgActiveDeck.sort(() => Math.random() - 0.5);

    // 计算布局
    const deskW = window.innerWidth;
    const cardWidth = 60, cardHeight = 90, gapX = 10, gapY = 15;       
    let columns = Math.floor((deskW - 20) / (cardWidth + gapX));
    if (columns < 4) columns = 4;
    
    const startX = Math.max(0, (deskW - (columns * cardWidth + (columns - 1) * gapX)) / 2);
    const startY = 60;

    rpgActiveDeck.forEach((card, index) => {
        const el = document.createElement('div');
        el.className = 'playing-card'; 
        
        const colIndex = index % columns;
        const rowIndex = Math.floor(index / columns);
        
        el.style.left = (startX + colIndex * (cardWidth + gapX)) + 'px';
        el.style.top = (startY + rowIndex * (cardHeight + gapY)) + 'px';
        el.style.transform = `rotate(${Math.random() * 6 - 3}deg)`; 
        
        // 绑定点击事件
        el.onclick = () => flipRpgCard(el, card);
        
        const front = document.createElement('div');
        front.className = 'playing-card-front';
        el.appendChild(front);
        
        area.appendChild(el);
    });
    
    const totalRows = Math.ceil(rpgActiveDeck.length / columns);
    area.style.height = (startY + totalRows * (cardHeight + gapY) + 120) + 'px';

    modal.style.display = 'flex';
}

// 2. 翻牌逻辑
async function flipRpgCard(el, cardData) {
    if(el.classList.contains('flipped')) {
        // 取消翻牌
        el.classList.remove('flipped');
        rpgFlippedCards = rpgFlippedCards.filter(c => !(c.type === cardData.type && c.id === cardData.id));
        
        setTimeout(() => {
            const frontEl = el.querySelector('.playing-card-front');
            if(frontEl) {
                frontEl.style.backgroundImage = ''; 
                frontEl.style.transform = ''; 
                frontEl.innerText = '';
            }
        }, 300);
    } else {
        // 翻牌
        el.classList.add('flipped');
        rpgFlippedCards.push(cardData);
        
        const dbName = cardData.type === 'tarot' ? 'tarot_deck' : 'lenormand_deck';
        try {
            const item = await idb.get(dbName, cardData.id);
            const frontEl = el.querySelector('.playing-card-front');
            
            if (item && item.data) {
                frontEl.style.backgroundImage = `url(${item.data})`;
                frontEl.style.backgroundSize = 'cover'; 
                frontEl.style.backgroundPosition = 'center';
                frontEl.innerText = ''; 
            } else {
                // 没图时的兜底显示
                frontEl.style.backgroundColor = '#e17055';
                frontEl.style.color = '#fff';
                frontEl.style.display = 'flex';
                frontEl.style.alignItems = 'center';
                frontEl.style.justifyContent = 'center';
                frontEl.style.fontSize = '0.7rem';
                frontEl.innerText = `${cardData.type}\n#${cardData.id}`;
            }
            
            // 处理逆位
            if(cardData.type === 'tarot' && cardData.isReversed) {
                frontEl.style.transform = "rotateY(180deg) rotate(180deg)"; 
            } else {
                frontEl.style.transform = "rotateY(180deg)";
            }
        } catch(e) { console.error("加载图片失败:", e); }
    }
    document.getElementById('rpg-flipped-count').innerText = rpgFlippedCards.length;
}

// 3. 核心 API 生成：完成对话 (保留原提示词)
async function finishRpgChat() {
    if(rpgFlippedCards.length === 0) return alert("请至少翻一张牌，让命运指引 Ta 的回复！");
    
    // UI 交互
    const userInput = document.getElementById('rpg-chat-input').value;
    const btn = document.querySelector('#rpg-card-table-modal .primary');
    const oldText = btn.innerText;
    btn.innerText = "⏳ 正在连接 Ta 的潜意识..."; btn.disabled = true;

    // 准备上下文数据
    const cardsDesc = rpgFlippedCards.map(c => (c.type==='tarot'?TAROT_NAMES[c.id]:LENORMAND_NAMES[c.id]) + (c.isReversed?"(逆)":"")).join(", ");
    const wb = getWBData();
    const globalCtx = (wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    const chatCtx = (wb['2.小剧场'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    
    // 获取 API Key
    let apiKey = document.getElementById('api-key').value;
    let apiUrl = document.getElementById('api-url').value || "https://api.openai.com/v1";
    let model = document.getElementById('model-select').value || "gpt-3.5-turbo";
    if(!apiKey) {
        try { const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}'); apiKey=s.key; apiUrl=s.url; model=s.model; } catch(e){}
    }
    if(!apiKey) { btn.innerText = oldText; btn.disabled = false; return alert("请先在桌面【设置】中配置 API Key"); }

    // === 🌟 原版提示词 (Original Prompt) ===
    const prompt = `
你现在正在和用户进行面对面的亲密对话。
【角色设定】：${globalCtx}
【补充设定】：${chatCtx}

【情境】：
用户对你说了："${userInput}"
与此同时，此时此刻的命运卡牌显示了当下的能量场：【${cardsDesc}】

【任务】：
请结合**牌意**和角色性格，给用户一个回复。

👉 **解牌核心要求（重要）**：
请不要照书本背诵牌义。请根据牌面的**【画面感 (Imagery)】**和**【能量的流动 (Energy Flow)】**来决定角色此刻的情绪和潜台词。
   - 例如：抽到《宝剑六》，能量是“渡过难关后的平静但带着忧伤”，画面是“乘船远去”。角色回复时应该带着这种微微的疏离感或释然感。
   - 例如：抽到《权杖八》，能量是“急速、热烈、冲动”，画面是“满天飞来的权杖”。角色回复时语速应该很快，情绪高昂，迫不及待。

【输出要求】：
1. **字数**：严格控制在 **3 到 4 句话**。
2. **内容**：转化为角色的自然语言，**绝对不要**出现“因为牌意是...”这种解释性的话。
3. **格式**：直接输出回复内容，不要引号。
`;

    try {
        const res = await fetch(`${apiUrl.replace(/\/$/, "")}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model,
                messages: [{role:"system", content:"You are a roleplay character."}, {role:"user", content:prompt}],
                temperature: 0.8
            })
        });
        const json = await res.json();
        const reply = json.choices[0].message.content.trim();

        // --- 保存到无限存储 (Big Memory) ---
        if(!window.BIG_MEMORY.rpg_data) window.BIG_MEMORY.rpg_data = { history: [], chat_history: [] };
        if(!window.BIG_MEMORY.rpg_data.chat_history) window.BIG_MEMORY.rpg_data.chat_history = [];
        
        // 存入用户消息
        window.BIG_MEMORY.rpg_data.chat_history.push({ role: 'me', text: userInput });
        // 存入回复 (带小尾巴显示牌名)
        window.BIG_MEMORY.rpg_data.chat_history.push({ role: 'char', text: reply + ` <span style="font-size:0.6rem;opacity:0.5;">(🔮${cardsDesc})</span>` });
        
        // 写入数据库
        saveToBigDB('rpg_data', window.BIG_MEMORY.rpg_data);
        
        // 刷新界面
        renderRpgChatList();
        document.getElementById('rpg-chat-input').value = ''; // 清空输入框
        document.getElementById('rpg-card-table-modal').style.display = 'none'; // 关闭牌桌

    } catch(e) {
        console.error(e);
        alert("回复生成失败: " + e.message);
    } finally {
        btn.innerText = oldText; btn.disabled = false;
    }
}

// 4. 生成互动小故事 (点击家具时调用)
async function generateRpgStory(item) {
    // UI 提示
    const storyList = document.getElementById('rpg-history-list');
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'morandi-card';
    loadingDiv.innerHTML = `<div class="skeleton-text">正在生成与【${item.name}】的互动故事...</div>`;
    storyList.prepend(loadingDiv);
    
    // 准备数据
    const wb = getWBData();
    const globalCtx = (wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    const theaterCtx = (wb['2.小剧场'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    
    // API Check
    let apiKey = document.getElementById('api-key').value;
    let apiUrl = document.getElementById('api-url').value || "https://api.openai.com/v1";
    let model = document.getElementById('model-select').value || "gpt-3.5-turbo";
    
    // 尝试读取缓存 Key
    if(!apiKey) { try { const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}'); apiKey=s.key; apiUrl=s.url; model=s.model; } catch(e){} }
    if(!apiKey) { loadingDiv.remove(); return alert("请配置 API Key"); }

    // === 🌟 原版提示词 (Original Prompt) ===
    const prompt = `
你是一位擅长描写生活细节的小说家。
【世界观】：${globalCtx}
【附加设定】：${theaterCtx}

【当前事件】：用户在房间里与【${item.name}】进行了互动。
【任务】：
请写一段 **不少于 300 字** 的小故事。
- 视角：第二人称“你”。
- 内容：描写“你”使用${item.name}的过程，触发的回忆，或者当下的细腻感受。如果世界观里有 CP 角色，可以描写想起他/她的情节。
- 风格：温馨、生活化、画面感强。

请直接输出正文，不要标题。
`;

    try {
        const res = await fetch(`${apiUrl}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model,
                messages: [{role:"system", content:"You are a creative writer."}, {role:"user", content:prompt}],
                temperature: 0.8
            })
        });
        const json = await res.json();
        const story = json.choices[0].message.content;

        // 保存到无限存储
        if(!window.BIG_MEMORY.rpg_data) window.BIG_MEMORY.rpg_data = { history: [], chat_history: [] };
        if(!window.BIG_MEMORY.rpg_data.history) window.BIG_MEMORY.rpg_data.history = [];

        window.BIG_MEMORY.rpg_data.history.unshift({
            date: Date.now(),
            text: story,
            item: item.name
        });
        
        saveToBigDB('rpg_data', window.BIG_MEMORY.rpg_data);
        
        loadingDiv.remove();
        renderRpgHistory(); // 刷新列表
        alert("✨ 互动故事已生成！");

    } catch(e) {
        console.error(e);
        loadingDiv.innerHTML = `<span style="color:red">生成失败: ${e.message}</span>`;
    }
}

// 5. 渲染历史记录 (侧边栏)
function renderRpgHistory() {
    const data = window.BIG_MEMORY.rpg_data ? window.BIG_MEMORY.rpg_data.history : [];
    const con = document.getElementById('rpg-history-list');
    con.innerHTML = '';
    
    if(!data || data.length === 0) {
        con.innerHTML = '<div style="text-align:center; color:#999; margin-top:20px;">暂无故事，快去点击房间里的物品吧~</div>';
        return;
    }

    data.forEach((h, i) => {
        con.innerHTML += `
        <div class="morandi-card" style="padding:10px; margin-bottom:10px; background:#fff;">
            <div style="font-size:0.8rem;color:#888; border-bottom:1px dashed #eee; margin-bottom:5px;">
                ${new Date(h.date).toLocaleString()} [${h.item}]
            </div>
            <div style="font-size:0.9rem; line-height:1.5;">${h.text}</div>
            <button class="m-btn small" onclick="deleteRpgHistory(${i})" style="color:red;margin-top:8px;width:100%;background:#ffcdd2;">删除</button>
        </div>`;
    });
}

// 6. 删除故事
function deleteRpgHistory(index) {
    if(!confirm("删除这段回忆？")) return;
    window.BIG_MEMORY.rpg_data.history.splice(index, 1);
    saveToBigDB('rpg_data', window.BIG_MEMORY.rpg_data);
    renderRpgHistory();
}

// 7. 渲染对话历史 (浮窗)
function renderRpgChatList() {
    const list = document.getElementById('rpg-chat-list');
    const data = (window.BIG_MEMORY.rpg_data && window.BIG_MEMORY.rpg_data.chat_history) ? window.BIG_MEMORY.rpg_data.chat_history : [];
    
    list.innerHTML = '';
    data.forEach(msg => {
        const div = document.createElement('div');
        div.className = `rpg-chat-bubble ${msg.role}`; 
        // class .me 和 .char 已经在你的 CSS 里定义了
        div.innerHTML = msg.text;
        list.appendChild(div);
    });
    // 自动滚动到底部
    const box = document.getElementById('rpg-chat-history-box');
    if(box) box.scrollTop = box.scrollHeight;
}

// 8. 清空对话
function clearRpgChatHistory() {
    if(!confirm("清空对话记录？")) return;
    window.BIG_MEMORY.rpg_data.chat_history = [];
    saveToBigDB('rpg_data', window.BIG_MEMORY.rpg_data);
    renderRpgChatList();
}
</script>
<!-- === RPG 专用独立牌桌 (功能复刻版：无限存储 + 114张全牌库) === -->
<div id="rpg-card-table-modal" class="modal-overlay" style="background: rgba(10, 10, 20, 0.95); backdrop-filter: blur(5px);">
    <div id="rpg-card-table-desk" style="width: 100%; height: 100%; position: relative; overflow-y: auto; overflow-x: hidden; padding-bottom: 100px;">
        <div id="rpg-card-area" style="width: 100%; height: 100%; position: relative; transform-style: preserve-3d; perspective: 1000px;">
            <!-- 卡牌将由 JS 动态生成在这里 -->
        </div>
        
        <div class="card-table-ui">
            <div style="color:#fdcb6e; text-shadow:0 1px 5px #000; font-size:1.1rem; font-weight:bold;">
                请抽取能够决定对话走向的牌... (<span id="rpg-flipped-count">0</span>)
            </div>
            <button class="m-btn primary" onclick="finishRpgChat()" style="background:#e17055; border:1px solid #fab1a0; color:white; box-shadow:0 0 15px rgba(225, 112, 85, 0.4);">
                🗣️ 确认牌意并生成回复
            </button>
            <button class="m-btn secondary" onclick="document.getElementById('rpg-card-table-modal').style.display='none'" style="background:rgba(255,255,255,0.2); color:white;">
                取消
            </button>
        </div>
    </div>
</div>
<script>
// ==================== 🛠️ RPG 系统终极修复补丁 (无限存储 + 沉浸对话) ====================

let rpgTypewriterTimer = null;

// 1. 打开对话模式：初始化状态
window.openRpgChatMode = function() {
    document.getElementById('rpg-chat-modal').style.display = 'flex';
    
    // 背景处理：复制当前场景作为背景，解决白屏
    const bgContainer = document.getElementById('rpg-chat-bg-container');
    bgContainer.innerHTML = ''; // 清空旧的
    
    // 放入背景图
    const bgSrc = rpgState.currentScene === 'room' ? RPG_ASSETS.bg_room : RPG_ASSETS.bg_outside;
    bgContainer.style.backgroundImage = `url(${bgSrc})`;
    bgContainer.style.backgroundSize = 'cover';
    
    // 如果是房间，放入地板
    if(rpgState.currentScene === 'room') {
        const floor = document.createElement('img');
        floor.src = RPG_ASSETS.collision_map;
        floor.style.cssText = "position:absolute; top:0; left:0; width:100%; height:100%; object-fit:fill;";
        bgContainer.appendChild(floor);
    }
    // 复制家具层
    const cloneDecor = document.getElementById('rpg-decor-layer').cloneNode(true);
    bgContainer.appendChild(cloneDecor);

    // 设置立绘
    document.getElementById('rpg-chat-npc-img').src = RPG_SKINS.npc_idle || RPG_ASSETS.char_gifs.idle;
    document.getElementById('rpg-chat-user-img').src = RPG_SKINS.user_idle || RPG_ASSETS.char_gifs.idle;

    // 🔥 关键：初始状态 -> 显示输入框，显示"我"的立绘，隐藏NPC
    resetRpgChatInput();
    renderRpgChatList();
};

// 2. 切换视觉状态 (控制谁在说话，显示谁的立绘)
// 切换视觉状态 (控制谁在说话，显示谁的立绘 + 切换底部盒子)
function toggleSpeaker(who) {
    const npcImg = document.getElementById('rpg-chat-npc-img');
    const userImg = document.getElementById('rpg-chat-user-img');
    const inputMode = document.getElementById('rpg-input-mode');
    const displayMode = document.getElementById('rpg-display-mode');

    if (who === 'me') {
        // 轮到我：显示我，隐藏他，显示输入框，隐藏回复框
        if(npcImg) npcImg.style.display = 'none';
        if(userImg) userImg.style.display = 'block';
        
        if(inputMode) inputMode.style.display = 'block';
        if(displayMode) displayMode.style.display = 'none';
    } else {
        // 轮到他：显示他，隐藏我，隐藏输入框，显示回复框 (在同一位置)
        if(npcImg) npcImg.style.display = 'block';
        if(userImg) userImg.style.display = 'none';
        
        if(inputMode) inputMode.style.display = 'none';
        if(displayMode) displayMode.style.display = 'block'; // 这里的 block 配合 CSS 里的样式
    }
}
// === 🔥 必须补上这个函数，否则会报错 ===
function toggleSpeaker(who) {
    const npcImg = document.getElementById('rpg-chat-npc-img');
    const userImg = document.getElementById('rpg-chat-user-img');
    const inputMode = document.getElementById('rpg-input-mode');
    const displayMode = document.getElementById('rpg-display-mode');

    if (who === 'me') {
        // 轮到我：显示我，隐藏他，显示输入框，隐藏回复框
        if(npcImg) npcImg.style.display = 'none';
        if(userImg) userImg.style.display = 'block';
        
        if(inputMode) inputMode.style.display = 'block';
        if(displayMode) displayMode.style.display = 'none';
    } else {
        // 轮到他：显示他，隐藏我，隐藏输入框，显示回复框 (在同一位置)
        if(npcImg) npcImg.style.display = 'block';
        if(userImg) userImg.style.display = 'none';
        
        if(inputMode) inputMode.style.display = 'none';
        if(displayMode) displayMode.style.display = 'block';
    }
}
// 3. 重置回输入状态 (点击文本框后触发)
window.resetRpgChatInput = function() {
    if(rpgTypewriterTimer) clearInterval(rpgTypewriterTimer);
    document.getElementById('rpg-chat-input').value = ''; 
    toggleSpeaker('me'); // 切换回"我"的视角
};

function playRpgTypewriter(text) {
    const el = document.getElementById('rpg-typewriter-text');
    el.innerHTML = '';
    let i = 0;
    if(window.rpgTypewriterTimer) clearInterval(window.rpgTypewriterTimer);
    
    window.rpgTypewriterTimer = setInterval(() => {
        el.innerText += text.charAt(i); 
        i++;
        if(i >= text.length) clearInterval(window.rpgTypewriterTimer);
    }, 50); 
}
// ==================== 🛠️ RPG 核心逻辑 (已修复：读取传讯 + 切换UI) ====================

window.finishRpgChat = async function() {
    // 1. 校验是否翻牌
    if(rpgFlippedCards.length === 0) return alert("请至少翻一张牌！");
    
    // 2. 获取用户刚才的输入
    const userInput = document.getElementById('rpg-chat-input').value;
    const btn = document.querySelector('#rpg-card-table-modal .primary');
    const oldText = btn.innerText;
    
    // 3. UI 锁定状态
    btn.innerText = "⏳ 正在连接 Ta 的潜意识..."; btn.disabled = true;

    // 4. 准备数据
    const cardsDesc = rpgFlippedCards.map(c => (c.type==='tarot'?TAROT_NAMES[c.id]:LENORMAND_NAMES[c.id]) + (c.isReversed?"(逆)":"")).join(", ");
    
    // 获取世界书数据
    const wb = window.getWBData(); 
    const globalCtx = (wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    
    // 🔥【关键修改】这里改成读取 '5.传讯'
    const msgCtx = (wb['5.传讯'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    
    // 获取 API Key
    let apiKey = document.getElementById('api-key').value;
    let apiUrl = document.getElementById('api-url').value || "https://api.openai.com/v1";
    let model = document.getElementById('model-select').value || "gpt-3.5-turbo";
    
    if(!apiKey) {
        try { const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}'); apiKey=s.key; apiUrl=s.url; model=s.model; } catch(e){}
    }
    if(!apiKey) { btn.innerText = oldText; btn.disabled = false; return alert("请先配置 API Key"); }

    // 5. 构建提示词
    const prompt = `
你现在正在和用户进行面对面的亲密对话。
【角色设定】：${globalCtx}
【传讯/短信风格设定】：${msgCtx} 
【情境】：用户说："${userInput}"
【命运卡牌】：${cardsDesc}

【任务】：
请结合牌意和角色性格，给用户一个回复。
将牌面的能量转化为角色的情绪和潜台词。
**字数限制：3-4句话。**
直接输出回复内容。
`;

    try {
        const res = await fetch(`${apiUrl.replace(/\/$/, "")}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model,
                messages: [{role:"system", content:"You are a roleplay character."}, {role:"user", content:prompt}],
                temperature: 0.8
            })
        });
        const json = await res.json();
        const reply = json.choices[0].message.content.trim();

        // === 数据保存逻辑 (无限存储) ===
        if(!window.BIG_MEMORY.rpg_data) window.BIG_MEMORY.rpg_data = { history: [], chat_history: [] };
        if(!window.BIG_MEMORY.rpg_data.chat_history) window.BIG_MEMORY.rpg_data.chat_history = [];
        
        // 存入聊天气泡
        window.BIG_MEMORY.rpg_data.chat_history.push({ role: 'me', text: userInput });
        window.BIG_MEMORY.rpg_data.chat_history.push({ role: 'char', text: reply + ` <span style="font-size:0.6rem;opacity:0.5;">(🔮${cardsDesc})</span>` });
        
        // 存入故事集
        if(!window.BIG_MEMORY.rpg_data.history) window.BIG_MEMORY.rpg_data.history = [];
        window.BIG_MEMORY.rpg_data.history.unshift({
            date: Date.now(),
            item: "对话 · 命运牌",
            text: `【我】${userInput}\n【Ta】${reply}\n\n🔮 牌意指引：${cardsDesc}`
        });

        // 保存数据库
        if(window.BIG_MEMORY.rpg_data.history.length > 50) window.BIG_MEMORY.rpg_data.history.pop();
        window.saveToBigDB('rpg_data', window.BIG_MEMORY.rpg_data);
        
        // === 🔥【关键修改】UI 交互逻辑 ===
        
        // 1. 关闭抽牌桌
        document.getElementById('rpg-card-table-modal').style.display = 'none'; 
        
        // 2. 确保回到聊天界面
        const chatModal = document.getElementById('rpg-chat-modal');
        chatModal.style.display = 'flex';
        chatModal.style.zIndex = '3000'; 

        // 3. 切换到“显示模式” (隐藏输入框，显示回复框)
        toggleSpeaker('npc'); 
        
        // 4. 播放打字机效果
        playRpgTypewriter(reply);
        
        // 5. 更新浮窗历史
        renderRpgChatList();

    } catch(e) {
        console.error(e);
        alert("回复生成失败: " + e.message);
    } finally {
        btn.innerText = oldText; btn.disabled = false;
    }
};

// 6. 故事集功能修复
window.toggleRpgHistory = function() {
    const panel = document.getElementById('rpg-history-panel');
    panel.classList.toggle('open');
    if(panel.classList.contains('open')) {
        renderRpgHistory();
    }
};

window.renderRpgHistory = function() {
    const data = window.BIG_MEMORY.rpg_data ? window.BIG_MEMORY.rpg_data.history : [];
    const con = document.getElementById('rpg-history-list');
    con.innerHTML = '';
    
    if(!data || data.length === 0) {
        con.innerHTML = '<div style="text-align:center; color:#999; margin-top:50px;">暂无故事<br>去和Ta对话或点击家具吧~</div>';
        return;
    }

    data.forEach((h, i) => {
        const div = document.createElement('div');
        div.className = 'morandi-card';
        div.style.padding = '12px'; 
        div.style.marginBottom = '10px'; 
        div.style.background = '#fff';
        
        div.innerHTML = `
            <div style="font-size:0.75rem; color:#888; border-bottom:1px dashed #eee; margin-bottom:6px; display:flex; justify-content:space-between;">
                <span>${new Date(h.date).toLocaleString()}</span>
                <strong style="color:#d35400;">${h.item || '事件'}</strong>
            </div>
            <div style="font-size:0.9rem; line-height:1.5; color:#333; white-space:pre-wrap;">${h.text}</div>
            <div style="text-align:right; margin-top:8px;">
                <button class="m-btn small" onclick="deleteRpgHistory(${i})" style="background:#ffcdd2; color:#c62828; font-size:0.7rem;">🗑️ 删除</button>
            </div>
        `;
        con.appendChild(div);
    });
};

window.deleteRpgHistory = function(index) {
    if(!confirm("确定删除这段回忆吗？")) return;
    window.BIG_MEMORY.rpg_data.history.splice(index, 1);
    saveToBigDB('rpg_data', window.BIG_MEMORY.rpg_data);
    renderRpgHistory();
};
</script>
</body>
<style>
@viewport { fit: cover; }
:root {
    --safe-top: max(44px, env(safe-area-inset-top)); 
}
.modal-header,           
.chat-header,            
.theater-header,         
.fridge-header-clean,    
.pickup-header,          
.hp-app-header,          
#camera-ui > div:first-child 
{
    padding-top: var(--safe-top) !important;
    height: auto !important;
    min-height: calc(50px + var(--safe-top)) !important;
    align-items: flex-end !important;
    padding-bottom: 12px !important;
    box-sizing: border-box !important;
    background-clip: padding-box !important;
    z-index: 9999 !important; 
}

    padding-top: calc(70px + var(--safe-top)) !important; 
}
.chat-settings-panel {
    padding-top: calc(20px + var(--safe-top)) !important;
}
.game-stats-panel {
    top: calc(20px + var(--safe-top)) !important;
}
.game-history-btn {
    top: calc(20px + var(--safe-top)) !important;
}
.paper-full-view {
    margin-top: var(--safe-top) !important;
    height: calc(90vh - var(--safe-top)) !important;
}
#letter-write-view > div:first-child {
    padding-top: var(--safe-top) !important;
    height: auto !important;
    min-height: calc(50px + var(--safe-top)) !important;
    align-items: flex-end !important;
    padding-bottom: 10px !important;
}
#camera-ui > div:first-child {
    background: #000 !important;
    display: flex !important;
    align-items: flex-end !important; 
}
#hp-os-view > div:first-child {
    padding-top: var(--safe-top) !important;
    height: auto !important;
    min-height: calc(30px + var(--safe-top)) !important;
    align-items: flex-end !important;
}
.hp-app-header {
    padding-top: var(--safe-top) !important;
    height: calc(50px + var(--safe-top)) !important;
    align-items: flex-end !important;
    padding-bottom: 10px !important;
}
#fan-modal .close-btn {
    top: calc(30px + var(--safe-top)) !important;
}
#gift-modal .close-btn {
    top: calc(30px + var(--safe-top)) !important;
}
.page {
    padding-top: calc(30px + var(--safe-top)) !important;
}
body, #screen {
    background-color: #cdd1d3; 
}
/* 新增样式：学习资源和思维导图 */
.study-resource-tag { 
    display: inline-block; background: #e3f2fd; color: #0277bd; 
    padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; 
    margin-right: 5px; margin-bottom: 5px; border: 1px solid #b3e5fc;
}
.study-sub-task {
    font-size: 0.85rem; color: #666; margin-top: 4px; 
    padding-left: 10px; border-left: 2px solid #cfd8dc;
}
.mind-map-box {
    font-family: "Courier New", monospace; white-space: pre-wrap; 
    font-size: 0.8rem; background: #fff; padding: 15px; 
    border-radius: 8px; border: 1px dashed #aaa; line-height: 1.4;
    overflow-x: auto; color: #37474f;
}
/* --- 日记本组件样式 --- */
.diary-book-container {
    width: 95%; max-width: 800px; height: 75vh;
    background: #fdfbf7;
    margin: auto; margin-top: 60px;
    display: flex;
    box-shadow: 0 20px 50px rgba(0,0,0,0.5);
    border-radius: 4px;
    position: relative;
}
.diary-book-container::before { /* 中缝阴影 */
    content: ""; position: absolute; top:0; bottom:0; left:50%; width:40px; transform:translateX(-50%);
    background: linear-gradient(to right, transparent, rgba(0,0,0,0.1) 45%, rgba(0,0,0,0.1) 55%, transparent);
    pointer-events: none; z-index: 5;
}
.diary-page {
    flex: 1; padding: 25px 30px; overflow-y: auto;
    background-image: repeating-linear-gradient(transparent, transparent 27px, #e0e0e0 28px);
    background-attachment: local;
    line-height: 28px; color: #4e342e; font-family: "Georgia", serif;
}
.diary-page.left { border-right: 1px solid #eee; }
.diary-status-bar {
    display: flex; gap: 10px; font-size: 0.7rem; font-family: monospace; 
    background: rgba(0,0,0,0.05); padding: 5px; border-radius: 4px; margin-bottom: 10px;
    justify-content: space-around; font-weight: bold; color: #5d4037;
}
.diary-date { text-align: right; font-style: italic; color: #888; margin-bottom: 15px; border-bottom: 2px double #ccc; }
.diary-text-body { font-size: 0.95rem; text-align: justify; white-space: pre-wrap; }
.diary-photo-frame {
    width: 120px; height: 120px; float: left; margin: 0 15px 5px 0;
    background: #eee; border: 5px solid #fff; box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
    transform: rotate(-3deg); position: relative;
}
.photo-pin { position: absolute; top: -10px; left: 50%; font-size: 1.2rem; transform:translateX(-50%); }

/* 背包物品样式 */
.bag-item-box {
    margin-bottom: 15px; border: 1px solid #d7ccc8; padding: 10px; background: rgba(255,255,255,0.6);
}
.bag-item-name { font-weight: bold; font-size: 1rem; color: #3e2723; }
.bag-item-note { 
    font-size: 0.8rem; color: #5d4037; margin-top: 5px; 
    border-top: 1px dashed #d7ccc8; padding-top: 5px; line-height: 1.4;
}
/* 移动端适配 */
@media (max-width: 600px) {
    .diary-book-container { flex-direction: column; height: 85vh; overflow-y: scroll; }
    .diary-page { min-height: 500px; border-right: none; border-bottom: 10px solid #eee; }
    .diary-book-container::before { display: none; }
}
.coin {
    width: 60px; height: 60px; background: #ffd700; border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-size: 2rem; box-shadow: 0 4px 0 #b8860b; border: 4px solid #fff;
    transition: transform 0.5s;
}
.coin.animate { animation: spinCoin 0.5s ease-out; }
@keyframes spinCoin { 0% { transform: rotateY(0); } 100% { transform: rotateY(720deg); } }

.iching-line {
    width: 200px; height: 20px; display: flex; gap: 20px; justify-content: center;
}
.line-part { background: #e2c2b3; height: 100%; border-radius: 4px; }
.line-yin .line-part { flex: 1; } /* 阴爻：两段 */
.line-yang .line-part { width: 100%; } /* 阳爻：一段 */
.line-moving { background: #ff6b6b !important; } /* 动爻变色 */
.line-label { position: absolute; left: -30px; font-size: 0.8rem; color: #aaa; }
.lofter-card {
    background: #fff; padding: 15px; margin-bottom: 10px; border-radius: 4px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05); cursor: pointer;
}
.lofter-tags { display:flex; gap:5px; margin-bottom:8px; }
.lofter-tag { font-size:0.7rem; color:#888; background:#f0f0f0; padding:2px 6px; border-radius:2px; }
.lofter-title { font-size:1.1rem; font-weight:bold; color:#333; margin-bottom:5px; line-height:1.3; }
.lofter-preview { font-size:0.9rem; color:#666; line-height:1.5; display:-webkit-box; -webkit-line-clamp:3; -webkit-box-orient:vertical; overflow:hidden; }
.lofter-meta { 
    margin-top:10px; padding-top:8px; border-top:1px solid #f5f5f5; 
    display:flex; justify-content:space-between; font-size:0.75rem; color:#999; 
}
.lofter-comment-section {
    margin-top: 30px; padding-top: 20px; border-top: 5px solid #f5f5f5;
}
.lofter-cmt-row { display:flex; gap:10px; margin-bottom:15px; font-size:0.9rem; }
.lofter-cmt-avatar { width:30px; height:30px; background:#ddd; border-radius:50%; flex-shrink:0; }
/* 老福特工具栏 */
.lofter-toolbar {
    padding: 10px 15px; background: #fff; border-bottom: 1px solid #f0f0f0;
    display: flex; gap: 10px; align-items: center;
}
.lofter-input {
    flex: 1; padding: 8px 12px; border: 1px solid #ddd; border-radius: 20px;
    font-size: 0.9rem; background: #f9f9f9; outline: none;
}
/* 删除按钮 */
.lofter-del-btn {
    position: absolute; top: 10px; right: 10px;
    width: 20px; height: 20px; text-align: center; line-height: 18px;
    color: #ccc; border-radius: 50%; font-size: 1.2rem;
    z-index: 10; padding-bottom: 2px;
}
.lofter-del-btn:hover { color: #ff4757; background: #fff0f0; }
.lofter-card { position: relative; } /* 确保删除按钮定位准确 */
/* === 老福特 (Lofter) 修复版样式 (瀑布流) === */
#lofter-feed-list {
    /* 核心：瀑布流布局 */
    column-count: 2;
    column-gap: 10px;
    padding-bottom: 60px;
}

.lofter-card-new {
    /* 防止卡片在列之间断裂 */
    break-inside: avoid;
    background: #fff;
    margin-bottom: 10px;
    border-radius: 8px; /* 圆角 */
    overflow: hidden;
    box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    position: relative;
    display: flex;
    flex-direction: column;
}

/* 模拟封面图 (用颜色代替，减少代码量) */
.lof-cover-placeholder {
    width: 100%;
    height: 120px;
    background: linear-gradient(135deg, #e0e0e0 0%, #f5f5f5 100%);
    position: relative;
}
.lof-cover-placeholder::after {
    content: "LOFTER";
    position: absolute;
    bottom: 5px; right: 10px;
    font-weight: 900; color: rgba(0,0,0,0.1);
    font-size: 1.5rem; letter-spacing: 2px;
}

.lof-body {
    padding: 10px;
    cursor: pointer;
}

.lof-title {
    font-size: 0.95rem; font-weight: bold; color: #333;
    margin-bottom: 5px; line-height: 1.3;
    display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;
}

.lof-preview {
    font-size: 0.8rem; color: #666; line-height: 1.5;
    margin-bottom: 8px;
    display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden;
}

/* 底部用户信息栏 */
.lof-footer {
    padding: 0 10px 10px 10px;
    display: flex; align-items: center; justify-content: space-between;
}
.lof-user-row {
    display: flex; align-items: center; gap: 6px;
}
.lof-avatar {
    width: 20px; height: 20px; border-radius: 50%;
    background: #ccc; font-size: 0.6rem; color: #fff;
    display: flex; align-items: center; justify-content: center;
}
.lof-author { font-size: 0.7rem; color: #888; max-width: 60px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }
.lof-hot { font-size: 0.7rem; color: #999; display: flex; align-items: center; gap: 2px;}

/* 标签样式 */
.lof-tags { display: none; } /* 首页隐藏标签保持整洁，或者你可以打开 */
.lof-del {
    position: absolute; top: 5px; right: 5px;
    width: 20px; height: 20px; background: rgba(0,0,0,0.5);
    color: #fff; border-radius: 50%; text-align: center; line-height: 18px;
    font-size: 1rem; cursor: pointer; z-index: 5; opacity: 0.6;
}
/* 🍬 扭蛋机样式 */
.gashapon-machine {
    width: 200px; height: 320px; position: relative; cursor: pointer;
    transition: transform 0.1s;
}
.gashapon-machine:active { transform: scale(0.95) rotate(1deg); }
.gashapon-machine.shaking { animation: shakeMachine 0.5s infinite; }
@keyframes shakeMachine { 0% { transform: rotate(0deg); } 25% { transform: rotate(2deg); } 50% { transform: rotate(0deg); } 75% { transform: rotate(-2deg); } 100% { transform: rotate(0deg); } }

.gm-glass {
    width: 180px; height: 180px; background: rgba(255,255,255,0.3);
    border: 4px solid #f48fb1; border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
    margin: 0 auto; position: relative; overflow: hidden;
    box-shadow: inset -10px -10px 20px rgba(255, 182, 193, 0.5), 0 5px 15px rgba(0,0,0,0.1);
    z-index: 2;
}
.gm-ball {
    width: 40px; height: 40px; border-radius: 50%; position: absolute; border: 2px solid rgba(0,0,0,0.1);
    box-shadow: inset -5px -5px 10px rgba(0,0,0,0.2);
}
.b1 { background: #ffcc80; bottom: 10px; left: 30px; transform: rotate(45deg); }
.b2 { background: #81d4fa; bottom: 40px; right: 40px; transform: rotate(-20deg); }
.b3 { background: #a5d6a7; bottom: 10px; right: 20px; }

.gm-body {
    width: 200px; height: 140px; background: #f48fb1;
    border-radius: 10px 10px 30px 30px; position: absolute; bottom: 0;
    box-shadow: inset 5px 0 10px rgba(0,0,0,0.1);
}
.gm-knob {
    width: 40px; height: 40px; background: #fff; border-radius: 50%;
    position: absolute; top: 30px; left: 50%; transform: translateX(-50%);
    border: 4px solid #e0e0e0; box-shadow: 0 4px 5px rgba(0,0,0,0.2);
}
.gm-knob::after { content:""; width: 30px; height: 6px; background: #ccc; position: absolute; top: 13px; left: 1px; transform: rotate(90deg); }
.gm-exit {
    width: 60px; height: 40px; background: #333; border-radius: 5px 5px 20px 20px;
    position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%);
    box-shadow: inset 0 5px 10px rgba(0,0,0,0.8);
}
.gm-label {
    position: absolute; top: 100px; left: 50%; transform:translateX(-50%);
    background: #fff; padding: 2px 8px; font-size: 0.7rem; color: #f48fb1; font-weight: bold; border-radius: 4px; z-index: 5;
}

/* 📜 历史记录抽屉 */
.gashapon-history-drawer {
    background: #fff; border-radius: 20px 20px 0 0; 
    box-shadow: 0 -5px 20px rgba(0,0,0,0.1);
    max-height: 60%; display: flex; flex-direction: column;
    transition: transform 0.3s;
}
.gh-handle {
    text-align: center; padding: 15px; color: #880e4f; font-weight: bold; font-size: 0.9rem; cursor: pointer;
    border-bottom: 1px solid #fce4ec;
}
.gh-list { flex: 1; overflow-y: auto; padding: 15px; display: none; }
.gh-list.show { display: block; }

/* 💊 巨大扭蛋 (未开封) */
.big-capsule {
    width: 200px; height: 200px; border-radius: 50%; 
    position: relative; cursor: pointer;
    animation: bounceIn 0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55);
    box-shadow: 0 20px 50px rgba(0,0,0,0.5);
    overflow: hidden;
    transform-origin: center; transition: all 0.5s;
}
@keyframes bounceIn { 0% { transform: scale(0); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
.bc-top { height: 50%; width: 100%; background: #ff4081; position: relative; z-index: 2; border-bottom: 4px solid rgba(0,0,0,0.1); }
.bc-bottom { height: 50%; width: 100%; background: #fff; position: relative; z-index: 1; }
.bc-text { 
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
    z-index: 3; color: rgba(0,0,0,0.5); font-weight: bold; font-family: monospace; 
    pointer-events: none; background: rgba(255,255,255,0.8); padding: 2px 5px;
}
.big-capsule.open {
    transform: scale(1.5); opacity: 0; pointer-events: none;
}

/* 📝 故事纸条 */
.story-paper {
    width: 90%; max-width: 500px; max-height: 80vh;
    background: #fffdf0; padding: 25px;
    box-shadow: 0 0 30px rgba(255,255,255,0.8);
    font-family: "Noto Serif SC", serif; color: #4a4a4a;
    display: flex; flex-direction: column;
    animation: unfold 0.8s ease-out;
    background-image: linear-gradient(90deg, rgba(200, 200, 200, 0.1) 1px, transparent 1px), linear-gradient(rgba(200, 200, 200, 0.1) 1px, transparent 1px);
    background-size: 20px 20px;
    border: 1px solid #ddd;
}
@keyframes unfold { 0% { transform: scaleY(0.1); opacity: 0; } 100% { transform: scaleY(1); opacity: 1; } }
.sp-header { 
    border-bottom: 2px double #e91e63; padding-bottom: 10px; margin-bottom: 15px; 
    display: flex; justify-content: space-between; font-size: 0.7rem; color: #e91e63; font-weight: bold; 
}
.sp-content { 
    flex: 1; overflow-y: auto; line-height: 1.8; font-size: 1rem; text-align: justify; 
    white-space: pre-wrap; padding-bottom: 20px;
}
.sp-content p { margin-bottom: 15px; }
.sp-footer { margin-top: auto; text-align: center; padding-top: 10px; border-top: 1px dashed #ccc; }
/* 宠物系统专用样式 */
.pet-item-card {
    background: #fff; border: 1px solid #ddd; border-radius: 8px;
    padding: 5px; text-align: center; cursor: pointer; position: relative;
}
.pet-item-img { width: 100%; height: 60px; object-fit: contain; }
.pet-item-price { font-size: 0.8rem; color: #d35400; font-weight: bold; }
.pet-item-count { 
    position: absolute; top: -5px; right: -5px; 
    background: #e74c3c; color: white; border-radius: 50%; 
    width: 20px; height: 20px; font-size: 0.7rem; 
    display: flex; align-items: center; justify-content: center;
}
.pet-decor-obj {
    position: absolute; pointer-events: auto; cursor: pointer;
    transition: transform 0.1s;
}
.pet-decor-obj:active { transform: scale(0.95); }
@keyframes petBreathe {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.02) translateY(-2px); }
}
.pet-anim { animation: petBreathe 3s infinite ease-in-out; }
#bag-grid, #shop-grid, #adopt-grid {
    display: grid !important;
    grid-template-columns: repeat(3, 1fr) !important; 
    gap: 10px !important;
    padding: 15px !important;
    justify-content: center !important;
}
.pet-item-card {
    width: 100% !important;
    aspect-ratio: 0.85 !important;
    min-width: 0 !important;
}
.pet-item-card {
    width: 100% !important;
    min-width: 0 !important; 
    aspect-ratio: 0.8 !important; 
    display: flex !important;
    flex-direction: column !important;
    align-items: center !important;
    justify-content: center !important;
}

.pet-item-img {
    width: 70% !important;
    height: 60% !important;
    object-fit: contain !important;
    margin-bottom: 5px !important;
}
.shadow-table {
    width: 100%;
    border-collapse: collapse;
    color: #dfe6e9;
    font-size: 0.9rem;
}
.shadow-table th, .shadow-table td {
    border: 1px solid #636e72;
    padding: 8px;
    text-align: left;
}
.shadow-table tr:nth-child(odd) {
    background: rgba(255, 255, 255, 0.05);
}
.shadow-table td:first-child {
    font-weight: bold;
    color: #ff7675; 
    width: 30%;
}
/* RPG 游戏样式 */
.rpg-sprite {
    position: absolute;
    width: 64px; 
    height: 64px;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center bottom;
    transition: left 0.1s linear, top 0.1s linear; /* 平滑移动 */
}
.rpg-decor {
    position: absolute;
    pointer-events: none; /* 让点击穿透，逻辑上处理 */
}
.rpg-dpad-btn {
    width: 40px; height: 40px;
    background: rgba(255,255,255,0.3);
    border: 1px solid rgba(255,255,255,0.5);
    border-radius: 8px; color: white;
    font-weight: bold; font-size: 1.2rem;
    display: flex; align-items: center; justify-content: center;
}
.rpg-dpad-btn:active { background: rgba(255,255,255,0.6); }

/* 聊天历史样式 */
.rpg-chat-bubble {
    font-size: 0.8rem; padding: 5px; margin-bottom: 5px; border-radius: 4px;
}
.rpg-chat-bubble.me { background: #ffeaa7; text-align: right; }
.rpg-chat-bubble.char { background: #fff; text-align: left; }
/* === RPG 修复补丁 CSS === */
#rpg-history-panel {
    z-index: 10000 !important; /* 确保浮在游戏画面和摇杆之上 */
    background: #fdfbf7 !important; /* 确保背景不透明 */
    width: 85% !important;
    max-width: 300px;
    right: 0;
    top: 0;
    height: 100%;
    position: absolute;
}

/* 确保生成的列表可以滚动 */
#rpg-history-list {
    overflow-y: auto !important;
    height: calc(100% - 60px) !important;
    padding-bottom: 50px;
}
/* 修改或添加到你的 <style> 块中 */

/* 确保底部控制区高度固定，防止切换时跳动 */
#rpg-chat-modal > div:nth-child(4) { 
    /* 对应 HTML 里的 "底部对话控制区" */
    min-height: 160px;
    padding: 20px;
    box-sizing: border-box;
}

/* 调整回复展示区域的样式，让它看起来像是在对话框里 */
#rpg-display-mode {
    display: none; 
    height: 100%; 
    color: #fff; 
    font-family: 'Songti SC', serif;
    /* 🔥 关键：让它看起来和输入框区域一样大 */
    background: rgba(255, 255, 255, 0.05); 
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    padding: 10px;
    box-sizing: border-box;
}

/* 调整打字机文字样式 */
#rpg-typewriter-text {
    font-size: 1.1rem; 
    line-height: 1.6; 
    min-height: 60px; 
    white-space: pre-wrap;
    color: #ecf0f1;
}
/* === 🛠️ RPG 修复样式 (请直接复制粘贴) === */

/* 1. 强制固定底部控制区的高度，防止切换时跳动 */
#rpg-chat-modal > div:nth-child(4) { 
    min-height: 180px !important; /* 强制高度 */
    height: 180px !important;     /* 固定高度 */
    padding: 20px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    justify-content: center;
    background: rgba(0,0,0,0.85); /* 确保背景色 */
}

/* 2. 让显示回复的框体 (display-mode) 充满这个区域 */
#rpg-display-mode {
    display: none; 
    width: 100%;
    height: 100%; 
    background: rgba(255, 255, 255, 0.05); 
    border: 1px solid rgba(255, 255, 255, 0.3); 
    border-radius: 8px;
    padding: 15px;
    box-sizing: border-box;
    cursor: pointer; 
    overflow-y: auto; /* 允许文字过多时滚动 */
}

/* 3. 打字机文字样式 */
#rpg-typewriter-text {
    color: #fff;
    font-family: 'Songti SC', serif;
    font-size: 1.1rem; 
    line-height: 1.6; 
    white-space: pre-wrap;
}
/* === RPG 必须样式 === */
#rpg-display-mode {
    display: none; 
    width: 100%;
    height: 100%; 
    background: rgba(255, 255, 255, 0.05); 
    border: 1px solid rgba(255, 255, 255, 0.3); 
    border-radius: 8px;
    padding: 15px;
    box-sizing: border-box;
    cursor: pointer; 
    overflow-y: auto;
}

/* 强制固定底部高度，防止切换时塌陷 */
#rpg-chat-modal > div:nth-child(4) { 
    min-height: 180px !important;
    height: 180px !important;
    display: flex;
    flex-direction: column;
}
</style>
<script>
// ==================== 🚑 RPG 游戏机终极修复补丁 (无限存储版) ====================

// 1. 确保数据结构存在 (防止报错)
if (!window.BIG_MEMORY) window.BIG_MEMORY = {};
if (!window.BIG_MEMORY.rpg_data) {
    window.BIG_MEMORY.rpg_data = { 
        history: [],       // 故事集 (互动+对话)
        chat_history: []   // 聊天气泡记录
    };
}

// 2. 修复：打开故事集面板
window.toggleRpgHistory = function() {
    const panel = document.getElementById('rpg-history-panel');
    panel.classList.toggle('open');
    if(panel.classList.contains('open')) {
        renderRpgHistory(); // 打开时立即刷新数据
    }
};

// 3. 修复：渲染故事集列表 (读取无限存储)
window.renderRpgHistory = function() {
    // 从大容量存储读取
    const data = window.BIG_MEMORY.rpg_data ? window.BIG_MEMORY.rpg_data.history : [];
    const con = document.getElementById('rpg-history-list');
    con.innerHTML = '';
    
    if(!data || data.length === 0) {
        con.innerHTML = '<div style="text-align:center; color:#999; margin-top:50px;">暂无故事<br>去和Ta对话或点击家具吧~</div>';
        return;
    }

    data.forEach((h, i) => {
        const div = document.createElement('div');
        div.className = 'morandi-card';
        div.style.padding = '12px'; 
        div.style.marginBottom = '10px'; 
        div.style.background = '#fff';
        
        // 渲染内容
        div.innerHTML = `
            <div style="font-size:0.75rem; color:#888; border-bottom:1px dashed #eee; margin-bottom:6px; display:flex; justify-content:space-between;">
                <span>${new Date(h.date).toLocaleString()}</span>
                <strong style="color:#d35400;">${h.item || '事件'}</strong>
            </div>
            <div style="font-size:0.9rem; line-height:1.5; color:#333; white-space:pre-wrap;">${h.text}</div>
            <div style="text-align:right; margin-top:8px;">
                <button class="m-btn small" onclick="deleteRpgHistory(${i})" style="background:#ffcdd2; color:#c62828; font-size:0.7rem;">🗑️ 删除</button>
            </div>
        `;
        con.appendChild(div);
    });
};

// 4. 修复：删除单条故事 (同步保存)
window.deleteRpgHistory = function(index) {
    if(!confirm("确定删除这段回忆吗？")) return;
    
    // 删除
    window.BIG_MEMORY.rpg_data.history.splice(index, 1);
    
    // 保存到数据库
    saveToBigDB('rpg_data', window.BIG_MEMORY.rpg_data);
    
    // 刷新界面
    renderRpgHistory();
};
// ==================== 🛠️ RPG 核心逻辑 (修改版：点击即关闭牌桌) ====================

window.finishRpgChat = async function() {
    // 1. 校验是否翻牌
    if(rpgFlippedCards.length === 0) return alert("请至少翻一张牌！");
    
    // 2. 获取用户刚才的输入
    const userInput = document.getElementById('rpg-chat-input').value;
    
    // 3. 准备数据 (牌意、世界书)
    const cardsDesc = rpgFlippedCards.map(c => (c.type==='tarot'?TAROT_NAMES[c.id]:LENORMAND_NAMES[c.id]) + (c.isReversed?"(逆)":"")).join(", ");
    const wb = window.getWBData(); 
    const globalCtx = (wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    const msgCtx = (wb['5.传讯'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    
    // 4. 获取 API Key
    let apiKey = document.getElementById('api-key').value;
    let apiUrl = document.getElementById('api-url').value || "https://api.openai.com/v1";
    let model = document.getElementById('model-select').value || "gpt-3.5-turbo";
    
    if(!apiKey) {
        try { const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}'); apiKey=s.key; apiUrl=s.url; model=s.model; } catch(e){}
    }
    if(!apiKey) return alert("请先在桌面【设置】中配置 API Key");

    // =======================================================
    // 🔥 核心修改点：在这里直接关闭牌桌，并切换 UI
    // =======================================================
    
    // A. 关闭抽牌桌
    document.getElementById('rpg-card-table-modal').style.display = 'none'; 
    
    // B. 确保回到聊天界面
    const chatModal = document.getElementById('rpg-chat-modal');
    chatModal.style.display = 'flex';
    chatModal.style.zIndex = '3000'; 

    // C. 切换到“显示模式” (隐藏输入框，显示回复框)
    // 注意：这里需要确保 toggleSpeaker 函数存在 (见下文补充)
    toggleSpeaker('npc'); 
    
    // D. 先显示一个“正在思考”的状态，让用户知道没卡死
    playRpgTypewriter(`(🔮 命运牌：${cardsDesc})\n\nTa 正在感受你的心意...`);

    // =======================================================

    // 5. 构建提示词 (Prompt)
    const prompt = `
你现在正在和用户进行面对面的亲密对话。
【角色设定】：${globalCtx}
【传讯/短信风格设定】：${msgCtx} 
【情境】：用户说："${userInput}"
【命运卡牌】：${cardsDesc}

【任务】：
请结合牌意和角色性格，给用户一个回复。
将牌面的能量转化为角色的情绪和潜台词。
**字数限制：3-4句话。**
直接输出回复内容。
`;

    try {
        const res = await fetch(`${apiUrl.replace(/\/$/, "")}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model,
                messages: [{role:"system", content:"You are a roleplay character."}, {role:"user", content:prompt}],
                temperature: 0.8
            })
        });
        const json = await res.json();
        const reply = json.choices[0].message.content.trim();

        // === 数据保存逻辑 (无限存储 - 保持不变) ===
        if(!window.BIG_MEMORY.rpg_data) window.BIG_MEMORY.rpg_data = { history: [], chat_history: [] };
        if(!window.BIG_MEMORY.rpg_data.chat_history) window.BIG_MEMORY.rpg_data.chat_history = [];
        
        // 存入聊天气泡
        window.BIG_MEMORY.rpg_data.chat_history.push({ role: 'me', text: userInput });
        window.BIG_MEMORY.rpg_data.chat_history.push({ role: 'char', text: reply + ` <span style="font-size:0.6rem;opacity:0.5;">(🔮${cardsDesc})</span>` });
        
        // 存入故事集
        if(!window.BIG_MEMORY.rpg_data.history) window.BIG_MEMORY.rpg_data.history = [];
        window.BIG_MEMORY.rpg_data.history.unshift({
            date: Date.now(),
            item: "对话 · 命运牌",
            text: `【我】${userInput}\n【Ta】${reply}\n\n🔮 牌意指引：${cardsDesc}`
        });

        // 保存数据库
        if(window.BIG_MEMORY.rpg_data.history.length > 50) window.BIG_MEMORY.rpg_data.history.pop();
        window.saveToBigDB('rpg_data', window.BIG_MEMORY.rpg_data);
        
        // === 🔥 生成完成后：更新 UI 显示真实回复 ===
        
        // 1. 播放真实的回复内容
        playRpgTypewriter(reply);
        
        // 2. 更新浮窗历史
        renderRpgChatList();
        
        // 3. 清空输入框 (下次打开是空的)
        document.getElementById('rpg-chat-input').value = ''; 

    } catch(e) {
        console.error(e);
        playRpgTypewriter(`(连接中断... ${e.message})`); // 在对话框里显示错误
    }
};

// 6. 修复：家具互动故事生成 (也确保存入无限存储)
window.generateRpgStory = async function(item) {
    // ... 前置 API 检查代码省略，直接进入保存逻辑 ...
    // 在 fetch 成功后：
    
    // (这里仅展示修改后的保存逻辑部分，你需要替换原函数中的保存部分)
    /* 
       ... API 调用成功拿到 story 变量后 ...
    */
    /* 
    if(!window.BIG_MEMORY.rpg_data) window.BIG_MEMORY.rpg_data = { history: [], chat_history: [] };
    
    window.BIG_MEMORY.rpg_data.history.unshift({
        date: Date.now(),
        item: `互动 · ${item.name}`,
        text: story
    });
    
    saveToBigDB('rpg_data', window.BIG_MEMORY.rpg_data);
    renderRpgHistory(); // 刷新侧边栏
    */
    
    // 为了完整性，这里重写整个 generateRpgStory 确保你不漏掉
    const storyList = document.getElementById('rpg-history-list');
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'morandi-card';
    loadingDiv.innerHTML = `<div class="skeleton-text">正在生成与【${item.name}】的互动故事...</div>`;
    storyList.prepend(loadingDiv);
    
    const wb = getWBData();
    const globalCtx = (wb['1.全局'] || []).filter(i=>i.enabled).map(i=>i.content).join("\n");
    
    let apiKey = document.getElementById('api-key').value;
    let apiUrl = document.getElementById('api-url').value || "https://api.openai.com/v1";
    let model = document.getElementById('model-select').value || "gpt-3.5-turbo";
    
    if(!apiKey) { 
        try { const s = JSON.parse(localStorage.getItem('api_settings_draft') || '{}'); apiKey=s.key; apiUrl=s.url; model=s.model; } catch(e){} 
    }
    if(!apiKey) { loadingDiv.remove(); return alert("请配置 API Key"); }

    const prompt = `你是一个小说家。根据设定：${globalCtx}。用户与房间里的【${item.name}】互动了。请以第二人称“你”写一段温馨的生活片段（300字左右）。直接输出正文。`;

    try {
        const res = await fetch(`${apiUrl}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model,
                messages: [{role:"user", content:prompt}],
                temperature: 0.8
            })
        });
        const json = await res.json();
        const story = json.choices[0].message.content;

        // 保存
        if(!window.BIG_MEMORY.rpg_data) window.BIG_MEMORY.rpg_data = { history: [], chat_history: [] };
        if(!window.BIG_MEMORY.rpg_data.history) window.BIG_MEMORY.rpg_data.history = [];

        window.BIG_MEMORY.rpg_data.history.unshift({
            date: Date.now(),
            item: `互动 · ${item.name}`,
            text: story
        });
        
        saveToBigDB('rpg_data', window.BIG_MEMORY.rpg_data);
        
        loadingDiv.remove();
        renderRpgHistory(); // 刷新列表
        alert("✨ 互动故事已生成！点开故事集查看。");

    } catch(e) {
        loadingDiv.innerHTML = `<span style="color:red">失败: ${e.message}</span>`;
    }
};
</html> 